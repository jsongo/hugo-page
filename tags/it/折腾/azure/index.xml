<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IT/折腾/Azure on Ethan 的思考札记</title><link>https://www.jsongo.top/tags/it/%E6%8A%98%E8%85%BE/azure/</link><description>Recent content in IT/折腾/Azure on Ethan 的思考札记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 18 Dec 2024 00:42:33 +0800</lastBuildDate><atom:link href="https://www.jsongo.top/tags/it/%E6%8A%98%E8%85%BE/azure/index.xml" rel="self" type="application/rss+xml"/><item><title>Azure Function Triggers</title><link>https://www.jsongo.top/articles/azure-function-triggers/</link><pubDate>Wed, 18 Dec 2024 00:42:33 +0800</pubDate><guid>https://www.jsongo.top/articles/azure-function-triggers/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/54ae9a6d9d56a2e58c20dc50f584fd39.jpg" alt="Featured image of post Azure Function Triggers" />&lt;h1 id="触发器各类">触发器各类
&lt;/h1>&lt;p>Azure Function 有多种模板，我们在创建 Function 时，一般会用 &lt;code>--template&lt;/code> 参数要指定用哪个模板。详细的可以参考官方文档：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings" target="_blank" rel="noopener"
>Triggers and bindings in Azure Functions | Microsoft Learn&lt;/a> 或中文版 &lt;a class="link" href="https://learn.microsoft.com/zh-cn/azure/azure-functions/functions-triggers-bindings?tabs=isolated-process,node-v4,python-v2&amp;amp;pivots=programming-language-csharp" target="_blank" rel="noopener"
>Azure Functions 中的触发器和绑定 | Microsoft Learn&lt;/a>。&lt;br>
以下是一些常见的：&lt;/p>
&lt;h2 id="基于事件触发的模板">基于事件触发的模板
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>Azure Blob Storage Trigger&lt;/strong>：当 Azure Blob 存储中的 Blob 被创建、更新或删除时触发函数。例如，可以在有新文件上传到指定 Blob 容器时，自动触发函数进行数据处理或文件转换等操作。&lt;/li>
&lt;li>&lt;strong>Azure Event Hubs Trigger&lt;/strong>：用于接收来自 Azure Event Hubs 的事件流消息，可实现对实时数据的处理。例如，在物联网场景中，接收设备发送的大量实时数据进行分析和处理。&lt;/li>
&lt;li>&lt;strong>Azure Service Bus Trigger&lt;/strong>：可以响应来自 Azure Service Bus 队列或主题的消息，支持批量接收消息。适用于处理异步消息传递场景，如订单处理、消息通知等。&lt;/li>
&lt;/ul>
&lt;h2 id="基于数据存储的模板">基于数据存储的模板
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>Azure Cosmos DB Trigger&lt;/strong>：使用 Azure Cosmos DB 的变更 feed 来监听分区中的插入和更新操作，当有数据发生变化时触发函数，可用于实时数据同步等场景。&lt;/li>
&lt;li>&lt;strong>Azure SQL Database Trigger&lt;/strong>：当 Azure SQL 数据库中的表发生数据插入、更新或删除操作时触发函数，方便进行数据的关联操作和业务逻辑处理。&lt;/li>
&lt;/ul>
&lt;h2 id="基于定时任务的模板">基于定时任务的模板
&lt;/h2>&lt;p>除了 Timer Trigger 外，还有一些定时任务相关的模板或扩展，如支持按照特定时间间隔或 cron 表达式来定期执行函数，可用于定时数据备份、报表生成等任务 。&lt;/p>
&lt;h2 id="基于-http-请求的模板">基于 HTTP 请求的模板
&lt;/h2>&lt;p>除了常见的 HTTP Trigger 外，还有一些针对特定 HTTP 场景的模板或扩展，如支持接收和处理来自 Webhook 的 HTTP 请求，可用于与第三方系统进行集成，接收外部系统推送的数据或事件。&lt;/p>
&lt;h2 id="其他模板">其他模板
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>PowerShell Trigger&lt;/strong>：允许使用 PowerShell 脚本编写函数逻辑，方便系统管理员或熟悉 PowerShell 的开发人员进行自动化脚本编写和任务调度。&lt;/li>
&lt;li>&lt;strong>Python Trigger&lt;/strong>：使用 Python 语言编写函数逻辑，适用于数据科学、机器学习等场景，可方便地调用 Python 库进行数据处理和分析。&lt;/li>
&lt;/ul>
&lt;h1 id="实践">实践
&lt;/h1>&lt;h2 id="timer-trigger">Timer Trigger
&lt;/h2>&lt;p>Http trigger 在 &lt;a class="link" href="azure%20serverless.md" >azure serverless&lt;/a> 中介绍过了。这里再讲一下 Timer Trigger，在做定时任务时非常有用，而且计费也只是按函数的执行时间来计，比较划算。&lt;br>
详细使用可以参考官方文档：&lt;a class="link" href="https://learn.microsoft.com/zh-cn/azure/azure-functions/functions-bindings-timer?tabs=python-v2,isolated-process,nodejs-v4&amp;amp;pivots=programming-language-python" target="_blank" rel="noopener"
>Azure Functions 的计时器触发器 | Microsoft Learn&lt;/a> 。&lt;br>
跟创建普通的 Azure Function 一样，还是用 CLI 的 new 命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">func new --name xxx --template &lt;span class="s2">&amp;#34;timer trigger&amp;#34;&lt;/span> --authlevel &lt;span class="s2">&amp;#34;function&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它会在你的 &lt;code>function_app.py&lt;/code> 里创建一个新的 function：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@app.timer_trigger&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">schedule&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;0 */10 * * * *&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">arg_name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;timer&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">run_on_startup&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">use_monitor&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">my_polling&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">timer&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">TimerRequest&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="kc">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">timer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">past_due&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">logging&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;The timer is past due!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">logging&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Python timer trigger function executed.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>@app.timer_trigger 里的几个参数：&lt;/p>
&lt;ul>
&lt;li>schedule：语法跟 cronjob 的配置一样，参考：&lt;a class="link" href="https://www.jsongo.top/articles/cron-syntax/" target="_blank" rel="noopener"
>Cron 表达式&lt;/a>。&lt;/li>
&lt;li>arg_name：表示计时器对象的变量的名称，没啥特别含义，就是随便定个名字能用就行。&lt;/li>
&lt;li>run_on_startup：部署完、或重新启用时，它自动触发一次。&lt;/li>
&lt;li>use_monitor：是否被 monotor 记录，如果间隔大于 1 分钟，建议设置为 true。&lt;br>
其中， &lt;code>func.TimerRequest&lt;/code> 这个参数，其实就只有 &lt;code>past_due&lt;/code> 这个 boolean 类型的属性。&lt;br>
&lt;code>past_due&lt;/code> 用于判断当前定时器触发的任务是否已经逾期：&lt;/li>
&lt;li>当定时任务由于某些原因（例如系统负载高、资源暂时不可用等）未能在预定的时间点执行，后面才被触发时，&lt;code>mytimer.past_due&lt;/code> 将为 &lt;code>True&lt;/code>。&lt;/li>
&lt;li>如果定时任务在预定时间内正常执行，那么 &lt;code>mytimer.past_due&lt;/code> 将为 &lt;code>False&lt;/code>&lt;br>
现在 &lt;code>my_polling&lt;/code> 函数里，我们可以添加一些对其它 Azure Function 的调用，由此来处理其它任务的定时执行。这样由两个触发器配合来完成特定任务。当然把逻辑全与在 Timer Trigger 里也不是不行，只不过解耦开之后，Http Trigger 还能被单独使用。&lt;/li>
&lt;/ul></description></item><item><title>Azure Function + Mysql 入门</title><link>https://www.jsongo.top/articles/azure-serverless-mysql/</link><pubDate>Mon, 16 Dec 2024 13:39:37 +0800</pubDate><guid>https://www.jsongo.top/articles/azure-serverless-mysql/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/0dba76ff89c558a40825ce7e7a507005.jpg" alt="Featured image of post Azure Function + Mysql 入门" />&lt;blockquote>
&lt;p>在 Azure Function 上使用 mysql DB，具体可以参考：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-azure-mysql?tabs=isolated-process&amp;amp;pivots=programming-language-python" target="_blank" rel="noopener"
>Azure Database for MySQL bindings for Functions | Microsoft Learn&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="mysql-申请">Mysql 申请
&lt;/h1>&lt;h2 id="免费额度">免费额度
&lt;/h2>&lt;p>免费用户其实还是有不少额度可以使用：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/31a8630222aa9b38aa0c6bedb54fb61e.webp"
width="650"
loading="lazy"
alt="|650"
>&lt;br>
详细可以阅读：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/mysql/flexible-server/how-to-deploy-on-azure-free-account" target="_blank" rel="noopener"
>Try Out With an Azure Free Account - Azure Database for MySQL - Flexible Server | Microsoft Learn&lt;/a>&lt;/p>
&lt;ul>
&lt;li>简单说，可以支持 B1MS 实例一直在线上跑，有 32G 的存储空间。B1MS 有 1~2 个 CPU 微核&lt;/li>
&lt;/ul>
&lt;h2 id="添加一个实例">添加一个实例
&lt;/h2>&lt;ul>
&lt;li>打开：[[https://portal.azure.com/#browse/Microsoft.DBforMySQL%2Fservers]]，点 &lt;code>Quick Create&lt;/code>。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/a1e23752568d6a93c878dcf2864d5a30.webp"
loading="lazy"
>&lt;/li>
&lt;li>简单填写下信息就行：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/4fee17d9e7f06b0c894723a5a2cc1c18.webp"
loading="lazy"
>&lt;/li>
&lt;li>下一步、创建，等几分钟就创建成功了：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/aab8b78c940e753bc5de50a461d49053.webp"
loading="lazy"
>&lt;/li>
&lt;/ul>
&lt;h1 id="简单使用">简单使用
&lt;/h1>&lt;h2 id="手动连接">手动连接
&lt;/h2>&lt;p>在本地默认是连接不上的， azure 为了安全，对访问做了限制，可以通过 zero trust 网络来接入，当然也可以简单的设置下网络、放行你的 ip：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/da949ffb37dbb360bb9e563577f2adf8.webp"
loading="lazy"
>&lt;br>
不过其实还有更简单的方式，直接在页面上打开连接：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/34cdbaccec72321f854ea1da97fac0b4.webp"
loading="lazy"
>&lt;br>
连接时，它会弹出一个 terminal，然后自动运行 mysql 命令进行连接。实际上，这个时候还连不上，即使你密码输入正确了也不行，它需要验证证书（也是为了安全）。&lt;br>
证书可以从这里下载：[[https://learn.microsoft.com/zh-cn/azure/mysql/flexible-server/how-to-connect-tls-ssl#download-the-public-ssl-certificate]] ，或者直接用我下图中的 wget 命令即可。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/de4826c732a4f7e2e09f0280c58246a3.webp"
width="725"
loading="lazy"
alt="|725"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">wget https://dl.cacerts.digicert.com/DigiCertGlobalRootCA.crt.pem
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>需要注意的是，直接连接 Mysql 进行操作比较危险，可以应急用，不建议当成常规操作。&lt;/p>
&lt;h2 id="操作">操作
&lt;/h2>&lt;p>刚创建的 MySQL 服务里面是空的，得自己手动创建一个 database：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">create&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">database&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">xxx&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后就可以切到这个 db 上使用了：&lt;code>use xxx&lt;/code>。&lt;/p>
&lt;h2 id="mac-上连接">Mac 上连接
&lt;/h2>&lt;p>如果是在 mac 上安装 mysql 客户端的话，用 brew install 会非常慢，直接到这个地址上去下载一个客户端：&lt;a class="link" href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener"
>Download MySQL Community Server&lt;/a>&lt;/p></description></item><item><title>azure serverless 使用</title><link>https://www.jsongo.top/articles/azure-serverless/</link><pubDate>Sat, 14 Dec 2024 01:33:06 +0800</pubDate><guid>https://www.jsongo.top/articles/azure-serverless/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/9f2713cc4890d8cf0449df9f4877fa26.jpg" alt="Featured image of post azure serverless 使用" />&lt;h1 id="基础工具">基础工具
&lt;/h1>&lt;p>Mac 上直接装：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">brew tap azure/functions
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">brew install azure-cli
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">brew install azure-functions-core-tools@4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>具体可以参考这里：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=macos,isolated-process,node-v4,python-v2,http-trigger,container-apps&amp;amp;pivots=programming-language-csharp" target="_blank" rel="noopener"
>Develop Azure Functions locally using Core Tools | Microsoft Learn&lt;/a>&lt;/p>
&lt;ul>
&lt;li>另外，这链接里也有怎么用命令行来创建的方法。下文 vscode 插件和 CLI 都会涉及。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="vscode-插件">Vscode 插件
&lt;/h1>&lt;p>参考这个：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-python?toc=/azure/developer/python/toc.json&amp;amp;bc=/azure/developer/python/breadcrumb/toc.json" target="_blank" rel="noopener"
>Create a Python function using Visual Studio Code - Azure Functions | Microsoft Learn&lt;/a>&lt;/p>
&lt;h2 id="简介">简介
&lt;/h2>&lt;p>在 vscode 中安装插件：Azure Functions&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/fb2e0acc105d63d085c40bdd1920f6a2.webp"
width="425"
loading="lazy"
alt="|425"
>&lt;br>
切到这个插件去点击添加一个函数，一步步往下都有说明，比较简单。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/ea7349816d01aa7f064eebb26475e767.webp"
width="300"
loading="lazy"
alt="|300"
>&lt;br>
我选了 HTTP 触发器的模板，最后给我生成了这个文件：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/92942fa30fb661c19c1901c6df0f73ee.webp"
width="500"
loading="lazy"
alt="|500"
>&lt;/p>
&lt;h2 id="调试运行">调试运行
&lt;/h2>&lt;p>简单的运行，可以用插件面板上，下半部分中的 Project 展开，里面有个调试相关的操作（它可点击）。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/b1f01eb135df433a4a2f8b9e91904dbb.webp"
width="850"
loading="lazy"
alt="|850"
>&lt;br>
它会先做一些安装，然后启动 function，IDE 进入 debug 模式。这时主要运行的命令是：&lt;code>func host start&lt;/code>，直接在命令行里运行这个命令也可以启动本地调试运行。但如果你想查询代码中打的日志，一定要记得加上 &amp;ndash;verbose 的参数，所以正确的使用姿势是：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">func host start --verbose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>本地调试时，其实已经默认把 AZURE_FUNCTIONS_ENVIRONMENT 这个变量设置为 &lt;code>Development&lt;/code> 了，如果你修改代码，它会触发服务的重启，非常方便。&lt;br>
它同时生成一个链接可以直接点击，它会触发函数执行：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/fe3b5f734dbe003a59b09c561687bf88.webp"
width="650"
loading="lazy"
alt="|650"
>&lt;/p>
&lt;h1 id="创建">创建
&lt;/h1>&lt;p>用 IDE 插件进行 function 创建上面已经介绍过来了，比较简单，不过读者可能会遇到网络问题而没法往下尝试。这里再介绍下 CLI 的方式来创建。&lt;br>
先初始化目录：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">func init --python
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它会生成一些基础的配置文件，包括 [[https://learn.microsoft.com/en-us/azure/azure-functions/functions-develop-local#local-settings-file]] 和 &lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-host-json" target="_blank" rel="noopener"
>&lt;em>host.json&lt;/em>&lt;/a>。&lt;br>
创建一个 api 入口：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="k">func&lt;/span> &lt;span class="n">new&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="n">combine_videos&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">template&lt;/span> &lt;span class="s2">&amp;#34;HTTP trigger&amp;#34;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">authlevel&lt;/span> &lt;span class="s2">&amp;#34;function&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Authlevel 有三个值：&lt;/p>
&lt;ul>
&lt;li>Anonymous 即任何人都可以访问，不需要带什么认证，相当于公开了。&lt;/li>
&lt;li>Function 函数级别的认证，创建的每个函数都得在 URL 上带一个 token 进行认证，参数是 &lt;code>?code=&amp;lt;token&amp;gt;&lt;/code>。&lt;/li>
&lt;li>Admin，最高级别的认证，只有具有管理员权限的用户才能访问函数，适用于包含敏感操作或数据的函数，如修改系统关键配置、访问敏感的业务数据等。这种模式依赖于复杂的身份管理系统（如 AAD）。&lt;/li>
&lt;/ul>
&lt;h1 id="部署">部署
&lt;/h1>&lt;h2 id="平台创建应用">平台创建应用
&lt;/h2>&lt;p>先打开 [[https://portal.azure.com/#browse/Microsoft.Web%2Fsites/kind/functionapp]] 这个 portal 地址，创建一个 &lt;code>Function App&lt;/code> （或者中文叫“函数应用”）。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/8c7facddd451e9fca9cba01e0b045eac.webp"
width="575"
loading="lazy"
alt="|575"
>&lt;/p>
&lt;h2 id="plugin">Plugin
&lt;/h2>&lt;p>正式部署前，肯定是需要先登录的。正常是可以在插件上操作，如下：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/91ce1f913a33cb8ab6d9d64480929b25.webp"
width="500"
loading="lazy"
alt="|500"
>&lt;br>
如果不成功，可以用下文 CLI 的方法来登录。&lt;br>
选择 Deploy to Function App，直接进行部署。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/bda580eaff46be66e6353ae23f839da6.webp"
width="700"
loading="lazy"
alt="|700"
>&lt;br>
我在使用的时候，经常遇到网络问题，因为某些你懂的原因，所以挺难的，得给 vscode 设置 Proxy (具体就不介绍了)&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/628fc45d846b96aa8dd84a59bc7f7ff7.webp"
width="700"
loading="lazy"
alt="|700"
>&lt;/p>
&lt;h2 id="cli-发布">CLI 发布
&lt;/h2>&lt;h3 id="登录">登录
&lt;/h3>&lt;p>使用前也一样需要先登录 (上面的说明都是在本地开发)：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">az login
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>运行时，它会打开一个网页进行登录授权&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/e473747eb42ae1af27de1a51d5d59e94.webp"
width="750"
loading="lazy"
alt="|750"
>&lt;br>
命令行也会有一堆打印，有如下关键信息就说明已经登录成功了。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/6d649277ba0edb949dfeb3bb2f736a94.webp"
width="900"
loading="lazy"
alt="|900"
>&lt;/p>
&lt;h3 id="发布操作">发布操作
&lt;/h3>&lt;p>当然我们也可以选择用 CLI 来做发布：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">func azure functionapp publish &amp;lt;project_name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>具体细节可以参考这里：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-cli-python?toc=/azure/developer/python/toc.json&amp;amp;bc=/azure/developer/python/breadcrumb/toc.json&amp;amp;tabs=macos,bash,azure-cli,browser" target="_blank" rel="noopener"
>Create a Python function from the command line - Azure Functions | Microsoft Learn&lt;/a>&lt;br>
这里的 &lt;code>project_name&lt;/code> 跟在平台上创建的应用名要保持一致，要不然会找不到这个 App 而发布失败。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/8ae08faed3138aeebf5aab5a595ebe9e.webp"
width="775"
loading="lazy"
alt="|775"
>&lt;br>
另外还有一点要注意的是，本地的 python 环境需要跟平台上的一致，避免本地跑的好好的、部署上去就缺一些模块：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/d4c8cfd171f834123918d1a99265533f.webp"
width="675"
loading="lazy"
alt="|675"
>&lt;br>
部署完会生成一个地址可供访问：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/3ac8969d54d4b231a0dad35cec82b39c.webp"
width="800"
loading="lazy"
alt="|800"
>&lt;br>
部署的过程是会比较慢，我们从平台的部署日志中可以看到它部署完后，会等待 1 分钟：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/a945e829b9eace8c1a74fb3afdcc9396.webp"
width="750"
loading="lazy"
alt="|750"
>&lt;br>
在线上运行后，可以访问试试。&lt;br>
线上日志可以在这里看到：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/4ca6c0c355611de0c1b3f2c29ca5f0e7.webp"
width="725"
loading="lazy"
alt="|725"
>&lt;br>
不过经常连接不稳定，所以其实可以到另一个地方查看 ：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/be1071dc6f42f0523efb4fcb176d311a.webp"
width="775"
loading="lazy"
alt="|775"
>&lt;/p>
&lt;h1 id="重要插件-azurite">重要插件 Azurite
&lt;/h1>&lt;p>安装另一个三方的 server 运行插件 Azurite，为开发人员提供了一个免费的本地环境，用于测试 Azure Blob、队列存储和表存储应用程序。常用的主要是 MySQL 操作，本地连不上线上 MySQL 或为避免脏数据时，用它就比较方便。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/02f0caabaf55d3b7cd7d1ae156e1deb3.webp"
width="550"
loading="lazy"
alt="|550"
>&lt;br>
如果没有它，本地如果运行定时任务就是出异常：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/bb208c03b576515896aa151e5a12fa6c.webp"
loading="lazy"
>&lt;br>
修改下 &lt;code>local.settings.json&lt;/code> 的配置，把 &lt;code>AzureWebJobsStorage&lt;/code> 设置成 &lt;code>&amp;quot;UseDevelopmentStorage=true&amp;quot;&lt;/code>。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/f477dc6f98630c7d9911cd2d28eb7ab5.webp"
width="550"
loading="lazy"
alt="|550"
>&lt;br>
打开命令面板，运行 Azurite start 来启动服务&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/e96da6632ab1e656b5bcdb2978135a51.webp"
width="475"
loading="lazy"
alt="|475"
>&lt;br>
这时它们的启动非常快，一闪而过，没关系，它已经在跑了。&lt;br>
比较烦的时，运行时，会在当前目录下生成一些文件：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/d08188a1cf18ec9fc4a3dd1170c2f5e0.webp"
width="450"
loading="lazy"
alt="|450"
>&lt;/p>
&lt;ul>
&lt;li>&lt;em>blobstorage&lt;/em> 和 &lt;em>queuestorage&lt;/em>
&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：
&lt;ul>
&lt;li>这些文件夹通常用于存储本地开发时的 Azure Blob 存储和 Azure Queue 存储的模拟数据。当你在本地运行和测试 Azure Functions 时，这些文件夹可以帮助模拟真实的 Azure 存储环境。&lt;/li>
&lt;li>例如，如果你有一个 Azure Function，它从 Blob 存储中读取数据或者向 Queue 存储中写入数据，在本地开发环境中，这些文件夹会存储相关的数据，以便函数能够正常运行和测试。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>使用场景&lt;/strong>：
&lt;ul>
&lt;li>在没有连接到真实 Azure 存储账户的情况下，本地开发和调试函数时需要用到。如果删除这些文件夹，可能会导致本地运行的函数在涉及到 Blob 或 Queue 操作时出现错误，因为它们找不到模拟的存储数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>以 &lt;em>azurite_db&lt;/em> 开头的.json 文件
&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：
&lt;ul>
&lt;li>这些文件是 Azurite 数据库文件。Azurite 是一个本地的 Azure 存储模拟器，用于在本地模拟 Azure Blob、Queue 和 Table 存储服务。这些.json 文件存储了 Azurite 模拟存储服务的数据结构和数据内容。&lt;/li>
&lt;li>例如，&lt;em>azurite_db_blob&lt;/em>.json 文件用于存储模拟的 Blob 存储数据结构和数据，&lt;em>azurite_db_queue&lt;/em>.json 文件用于存储模拟的 Queue 存储数据等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item></channel></rss>