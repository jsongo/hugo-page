<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IT/Server/Trace on Ethan 的思考札记</title><link>https://www.jsongo.top/tags/it/server/trace/</link><description>Recent content in IT/Server/Trace on Ethan 的思考札记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 08 Apr 2025 20:51:33 +0800</lastBuildDate><atom:link href="https://www.jsongo.top/tags/it/server/trace/index.xml" rel="self" type="application/rss+xml"/><item><title>Tracing 初步理解</title><link>https://www.jsongo.top/articles/tracing-101/</link><pubDate>Tue, 08 Apr 2025 20:51:33 +0800</pubDate><guid>https://www.jsongo.top/articles/tracing-101/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/1089988f36245b8456d63b99a86d3d2b.jpg" alt="Featured image of post Tracing 初步理解" />&lt;p>Tracing 是一种用于跟踪和记录系统运行状态、事件或资源使用情况的技术，广泛应用于软件开发、性能优化、故障排查等领域。以下是 tracing 中的一些关键概念、应用及跟 log 之间的关系。&lt;/p>
&lt;h1 id="tracing-概念">Tracing 概念
&lt;/h1>&lt;h2 id="-tracing-基础概念梳理">🔍 Tracing 基础概念梳理
&lt;/h2>&lt;h3 id="-整体结构树形">🌲 整体结构（树形）
&lt;/h3>&lt;ul>
&lt;li>一个请求的完整追踪过程被称为一个 &lt;strong>Trace&lt;/strong>，可以用一个 trace_id 唯一标识。&lt;/li>
&lt;li>一个 Trace 是由多个 &lt;strong>Span&lt;/strong> 组成的，&lt;strong>Span 形成一棵树结构&lt;/strong>。
&lt;ul>
&lt;li>根节点是最早创建的那个 Span（通常是入口请求，如前端或网关）。&lt;/li>
&lt;li>子节点 Span 表示在处理过程中产生的后续调用（如微服务之间的调用、数据库访问等）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="-核心概念一览">🧩 核心概念一览
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>概念&lt;/strong>&lt;/th>
&lt;th>&lt;strong>描述&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Trace&lt;/strong>&lt;/td>
&lt;td>表示一次完整的请求链，一般由一个唯一的 trace_id 标识。可以跨多个服务。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Span&lt;/strong>&lt;/td>
&lt;td>Trace 中的一个操作单位，表示一次具体的调用或操作，有 span_id。可以嵌套形成父子关系。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Parent Span&lt;/strong>&lt;/td>
&lt;td>一个 Span 可以有一个父 Span（用 parent_span_id 标识），用于构建调用树。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Child Span&lt;/strong>&lt;/td>
&lt;td>父 Span 内部调用的子操作，属于同一个 trace_id，形成树形结构。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Baggage&lt;/strong>&lt;/td>
&lt;td>是附着在 Trace 上的键值对，会随着 trace 传播给每个后续的 span，可用于传递业务上下文数据（如用户 ID、地域等）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Attributes / Tags&lt;/strong>&lt;/td>
&lt;td>是附着在 Span 上的键值对，用于记录执行时的状态、参数信息等。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Events / Logs&lt;/strong>&lt;/td>
&lt;td>是附着在 Span 上的时间序列事件，例如某个时刻报错、收到响应等。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="span">Span
&lt;/h2>&lt;p>🧠 每个 Span 都包含什么？&lt;/p>
&lt;ul>
&lt;li>span_id：该 Span 的唯一标识&lt;/li>
&lt;li>trace_id：所属的 Trace ID&lt;/li>
&lt;li>parent_span_id：它的父节点 Span 的 ID（根 span 没有父 ID）&lt;/li>
&lt;li>name：这个 span 的名称（如“调用用户服务”）&lt;/li>
&lt;li>start_time / end_time：起止时间&lt;/li>
&lt;li>attributes（也叫 tags）：键值对，描述上下文或运行参数&lt;/li>
&lt;li>events（或 logs）：事件序列（如异常、返回值）&lt;/li>
&lt;li>status：表示是否成功（比如 HTTP 500）&lt;/li>
&lt;li>baggage（选）：附加在 trace 上传播的键值对（所有 span 可共享）&lt;br>
但如果你每个小操作都创建一个 span，会导致：&lt;/li>
&lt;li>数据太多，观察成本高&lt;/li>
&lt;li>采样/存储开销大&lt;br>
所以建议：&lt;/li>
&lt;li>只给 &lt;strong>关键路径&lt;/strong>加 span，比如：IO 操作、外部调用、耗时步骤。&lt;/li>
&lt;li>对短暂或无关紧要的内部操作（如计算、循环等）不需要单独创建 span。&lt;/li>
&lt;/ul>
&lt;h3 id="-数据流示意树结构">🧬 数据流示意（树结构）
&lt;/h3>&lt;p>&lt;strong>Span 是可以相互嵌套的&lt;/strong>，它天生就是为了表现“一个操作内部还包含其他子操作”这种结构。它之所以是树结构，就是因为服务调用本身、或某个操作本身，就常常是“嵌套”的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">Trace (trace_id: abc123)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">│
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── Span A (root span, span_id: 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── Span B (span_id: 2, parent: 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> │ ├── Span D (span_id: 4, parent: 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> │ └── Span E (span_id: 5, parent: 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── Span C (span_id: 3, parent: 1)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="-耗时信息的采集">⏱ 耗时信息的采集
&lt;/h3>&lt;p>每个 Span 都记录 start &amp;amp; end 时间，比如&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;span_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;abc123&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;start_time&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2025-04-13T10:00:00.123Z&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;end_time&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;2025-04-13T10:00:01.456Z&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;duration_ms&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1333&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>✅ 计算方式：duration = end_time - start_time（建议保留 ms 精度）&lt;/p>
&lt;h2 id="-补充说明">✨ 补充说明
&lt;/h2>&lt;ul>
&lt;li>Span 使用
&lt;ul>
&lt;li>&lt;strong>Span != 服务&lt;/strong>，一个服务内可以产生多个 span，比如控制器、服务、DAO 等不同层级调用。&lt;/li>
&lt;li>&lt;strong>Span 的嵌套并不完全等于服务调用&lt;/strong>，可以是方法内的子步骤。&lt;/li>
&lt;li>&lt;strong>Baggage 不适合放太多数据&lt;/strong>，因为会被全链路传播，性能和隐私要注意。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="一些应用">一些应用
&lt;/h1>&lt;h2 id="展示耗时信息前端可视化">展示耗时信息（前端可视化）
&lt;/h2>&lt;h3 id="1-树形结构--耗时">1 、树形结构 + 耗时
&lt;/h3>&lt;ul>
&lt;li>展示结构 + 每一层的耗时：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">└── 用户请求（1000ms）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── 认证服务（200ms）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── 用户服务（600ms）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> │ ├── 数据库查询（400ms）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> │ └── 缓存写入（50ms）
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── 日志服务（100ms）
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2-时间线图--甘特图推荐">2 、时间线图 / 甘特图（推荐）
&lt;/h3>&lt;ul>
&lt;li>横轴是时间，纵轴是调用树层级，像这样：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">时间轴: |----100ms----|----100ms----|----100ms----|…
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">用户请求: [------------------------------]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">用户服务: [---------------]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">数据库查询: [------]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">缓存写入: [--]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>可以一眼看出：
&lt;ul>
&lt;li>谁最耗时&lt;/li>
&lt;li>哪些操作是串行的、哪些是并行的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="3判断性能瓶颈基于耗时">3、判断性能瓶颈（基于耗时）
&lt;/h3>&lt;p>根据 trace 可以自动检测一些问题：&lt;/p>
&lt;ul>
&lt;li>某个 span 耗时超过阈值（如 200ms）&lt;/li>
&lt;li>同一个服务下某些 span 总是很慢&lt;/li>
&lt;li>多个 span 串行而不是并行执行（如 A → B → C）&lt;/li>
&lt;/ul>
&lt;h2 id="-补充说明-1">✨ 补充说明
&lt;/h2>&lt;ul>
&lt;li>统一时间来源
&lt;ul>
&lt;li>使用同一个时钟源（如 performance.now() 或 process.hrtime()，不要用 Date.now() 混用）&lt;/li>
&lt;li>建议用 &lt;strong>高精度时间&lt;/strong>（纳秒或微秒），落库前可以转成毫秒或浮点秒数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="tracing-与-logging-的关系">Tracing 与 Logging 的关系
&lt;/h1>&lt;p>在软件开发中，&lt;strong>Tracing（追踪）&lt;/strong> 和 &lt;strong>Logging（日志记录）&lt;/strong> 是两种常用的技术，尽管它们的功能相似，但在应用场景和实现方式上有显著差异。&lt;br>
一句话：Tracing 是用于“跨服务的调用链分析”，而 Logging 是用于“记录事件和调试信息”。&lt;/p>
&lt;h2 id="tl-dr">TL; DR
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>Tracing 和 Logging 是互补的技术&lt;/strong>：
&lt;ul>
&lt;li>Tracing 更适合实时监控和动态数据上报，而 Logging 则适合长期记录和调试。&lt;/li>
&lt;li>它们可以结合使用：例如，在应用运行期间使用 Tracing 技术获取实时数据（如资源使用情况），然后通过 Logging 技术将错误信息记录下来。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>没有严格的包含关系&lt;/strong>：
&lt;ul>
&lt;li>它们各自服务于不同的场景和技术需求，但两者并不互相覆盖所有功能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="核心能力对比">核心能力对比
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">&lt;strong>维度&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Logging&lt;/strong>&lt;/th>
&lt;th>&lt;strong>Tracing&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">📍 关注点&lt;/td>
&lt;td>记录本地事件（debug/info/error）&lt;/td>
&lt;td>跨服务的请求链路与时序&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">🧩 粒度&lt;/td>
&lt;td>每一行日志就是一条信息&lt;/td>
&lt;td>每个 trace 是一个整体请求，包含多个 span&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">🔍 定位问题&lt;/td>
&lt;td>看错误堆栈、日志内容&lt;/td>
&lt;td>看请求链在哪个环节耗时多/出错&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">⏱ 时间维度&lt;/td>
&lt;td>一条日志有个 timestamp&lt;/td>
&lt;td>Trace 有 start/end + 每个 Span 有耗时&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">🌐 上下文&lt;/td>
&lt;td>通常只看当前服务&lt;/td>
&lt;td>可以跨多个服务传播 context（trace_id, baggage）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">📈 可视化&lt;/td>
&lt;td>日志系统展示（Elasticsearch, Loki）&lt;/td>
&lt;td>链路图、时间线（如 Jaeger, Zipkin）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">🧰 典型工具&lt;/td>
&lt;td>Log4j、SLF4J、Winston、Loki&lt;/td>
&lt;td>OpenTelemetry、Jaeger、SkyWalking&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="软件开发视角">软件开发视角
&lt;/h2>&lt;h3 id="1-tracing-的作用">1. Tracing 的作用
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>追踪应用程序的行为&lt;/strong>：Tracing 主要用于跟踪应用程序的运行状态、资源使用情况（如 CPU、内存）、错误发生等。&lt;/li>
&lt;li>&lt;strong>实时监控&lt;/strong>：常用于实时应用中，例如浏览器插件、云服务监控等。&lt;/li>
&lt;/ul>
&lt;h3 id="2-logging-的作用">2. Logging 的作用
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>记录详细信息&lt;/strong>：Logging 是记录日志文件或直接发送到云服务的详细信息（如错误堆栈、调用链）。&lt;/li>
&lt;li>&lt;strong>调试和分析&lt;/strong>：用于调试错误源，并提供详细的运行轨迹。&lt;/li>
&lt;/ul>
&lt;h3 id="3-tracing-和-logging-的关系">3. Tracing 和 Logging 的关系
&lt;/h3>&lt;ul>
&lt;li>两者其实是可以相辅相成的。一个系统通常这样用：
&lt;ul>
&lt;li>Tracing → 提供“全局视角”：看到某个请求走了哪些服务、在哪一步慢了或失败了&lt;/li>
&lt;li>Logging → 提供“局部细节”：具体方法内部执行了什么、变量值、堆栈、报错&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>举例说明下，比如 Tracing 信息如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">TraceID: abc123
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Span: [用户服务处理订单] 150ms
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── [调用库存服务] 90ms ❌ Timeout
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>Logging 里，有如下信息：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">[WARN]TraceID=abc123 无法连接库存数据库
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[ERROR] TraceID=abc123 查询失败，返回500
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当看到 trace 知道问题出在“调用库存服务”，再用 trace_id 去日志里一搜，就能看到详细原因。&lt;/p>
&lt;h2 id="替代性和建议">替代性和建议
&lt;/h2>&lt;h3 id="-理论上可以把-tracing-当-log-用">✅ 理论上可以把 Tracing 当 Log 用
&lt;/h3>&lt;blockquote>
&lt;p>如 OpenTelemetry 就是一个记录很细的系统，可以当 log 用。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>Tracing 的每个 span 可以附加 &lt;strong>事件（event）/ 日志（log）&lt;/strong>&lt;/li>
&lt;li>可以做到类似 logger.info(…) 的功能&lt;/li>
&lt;li>可以把 span.addEvent(&amp;quot; 准备开始数据库查询 &amp;ldquo;) 当作 log&lt;/li>
&lt;/ul>
&lt;h3 id="-但不建议只用-tracing-替代-logging">❌ 但不建议只用 Tracing 替代 Logging
&lt;/h3>&lt;ul>
&lt;li>Tracing 会采样（不是所有请求都记录）→ 有的错误日志你找不到&lt;/li>
&lt;li>写日志的自由度高（结构、内容、格式），Tracing 更偏结构化&lt;/li>
&lt;li>日志可以本地保存、不依赖全链路链路系统&lt;/li>
&lt;li>Tracing 更适合宏观链路分析，不适合长期审计、安全排查等用途&lt;/li>
&lt;/ul>
&lt;h3 id="-推荐做法实际工程中">🧠 推荐做法（实际工程中）
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>级别&lt;/strong>&lt;/th>
&lt;th>&lt;strong>工具&lt;/strong>&lt;/th>
&lt;th>&lt;strong>用途&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>🔭 全局观&lt;/td>
&lt;td>Tracing (OpenTelemetry)&lt;/td>
&lt;td>分布式链路追踪，定位请求瓶颈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>🛠 细节&lt;/td>
&lt;td>Logging (Winston, Logback…)&lt;/td>
&lt;td>开发调试、审计、错误定位&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>📊 聚合&lt;/td>
&lt;td>Metrics (Prometheus…)&lt;/td>
&lt;td>吞吐量、请求数、错误率等统计指标&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在写日志时 &lt;strong>附带 trace_id&lt;/strong> 是非常推荐的做法（比如 MDC、trace context），这样就可以轻松做到 “trace 定位后，日志深入排查”。比如在 log 里统一打出：&lt;code>[INFO][trace_id=abc123]查询成功&lt;/code> 。&lt;br>
一个请求来了，你可以：&lt;/p>
&lt;ul>
&lt;li>用 Trace 找到问题在哪个服务&lt;/li>
&lt;li>用 Log 看服务内部报错细节&lt;/li>
&lt;li>用 Metrics 看整体健康趋势&lt;/li>
&lt;/ul></description></item></channel></rss>