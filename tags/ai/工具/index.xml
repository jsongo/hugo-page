<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AI/工具 on Ethan 的思考札记</title><link>https://www.jsongo.top/tags/ai/%E5%B7%A5%E5%85%B7/</link><description>Recent content in AI/工具 on Ethan 的思考札记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 25 Dec 2024 21:16:20 +0800</lastBuildDate><atom:link href="https://www.jsongo.top/tags/ai/%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><item><title>用 Cursor 开发未知语言代码</title><link>https://www.jsongo.top/articles/coding-with-cursor/</link><pubDate>Wed, 25 Dec 2024 21:16:20 +0800</pubDate><guid>https://www.jsongo.top/articles/coding-with-cursor/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/a7f752e124242dcebca6f80af1173db0.jpeg" alt="Featured image of post 用 Cursor 开发未知语言代码" />&lt;h1 id="概述">概述
&lt;/h1>&lt;h2 id="一句话总结">一句话总结
&lt;/h2>&lt;p>Cursor 对于研发来说，是一个非常有用的提效工具。一句话来总结 Cursor 就是：&lt;/p>
&lt;div class="admonition tip">
&lt;div class="details-summary admonition-title">
&lt;i class='icon fas fa-lightbulb fa-fw'>&lt;/i>
提示&lt;br
&lt;/div>&lt;/div>
&lt;div class="details-content">
&lt;div class="admonition-content">
&lt;p>语言、语法不再重要，Cursor 可以把思路和逻辑很好的翻译成代码，但开发者的还是要设计好整个项目的研发框架和方案，然后指挥工具干活。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>&lt;p>开发 KMP 跨端框架的代码，开始时我不懂它的 Kotlin 语法；开发完之后，我依然还不懂怎么写 Kotlin，但不影响我实现相关的功能。&lt;/p>
&lt;h2 id="感受">感受
&lt;/h2>&lt;p>cursor 有点像 code review 的交互：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/4673799a9001151d68a5ceb7f9de9d51.webp"
loading="lazy"
alt="001aadc69264ca248e71eeee340a33ff_MD5|0"
>&lt;br>
开发时的感受也确实像 Code Review，只不过多了一个“yes or no”的选择操作。认可这个修改点它旁边的 Accept 按钮，觉得不对，就 “Reject”。&lt;/p>
&lt;h2 id="本文-case-说明">本文 Case 说明
&lt;/h2>&lt;p>本文中，我们以 Coze OpenAPI 的 SDK 开发为例，目前（2024.12） 已经有 JS、Python、Java 版的 SDK 了，不过还是有用户提了其它语言的诉求，我们只有前后端，所以这时 Cursor 成了我们开发多种语言版本的 SDK 的有力助手。&lt;br>
不过不管是什么语言，第一件事，都是先搭环境，把最简单的该语言 Hello World 跑起来。对习惯 JS/Go/Python 的同学来说，可能觉得这不是个问题，但当你遇到 Java、Kotlin、Android、iOS 等这些语言时，准备环境经常是一个很麻烦的事。&lt;/p>
&lt;blockquote>
&lt;p>小建议：&lt;br>
如果遇到了一些新框架的话，还得跟着 Quick Start 跑一下，不要着急、上来就想要结果。&lt;br>
在 KMP 的项目中，这一点让我感触颇深。开始花了挺多时间踩坑，后来发现其实 Quick Start 里都有，KMP 前些天刚升级 3.0 之后，很多玩法都不一样了，网上的很多代码都跑不起来（Cursor 生成的代码还都基于老的框架写，训练数据就是这样），折腾半天没结果，第二天发现，还不如抽几分钟把 Quick Start 跑一下，问题全解了。&lt;/p>
&lt;/blockquote>
&lt;h2 id="cursor-agent-composer">Cursor Agent (Composer)
&lt;/h2>&lt;p>Cursor 刚出的 agent 比之前简单的 Chat 强不少。之前的 Chat 它记不住太远的上下文，多问几轮，最开始的问题它会重复地犯错。&lt;br>
简单的讲：&lt;/p>
&lt;ul>
&lt;li>Cursor Chat：帮助开发者理解代码片段、提供代码优化建议、协助查找代码错误或者回答关于特定编程语言和框架的一般性问题；&lt;/li>
&lt;li>Cursor Agent：更全面，首先可以让 Agent 读取整个项目文件，快速掌握项目的主要功能和关键文件，也能同时操作多个文件，根据需要增删改，甚至还能对整个项目做分析，帮你优化项目结构等。&lt;br>
下面例子中 大都基于 Composer 来实现的。下图是一个简单的例子：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/4eda348bfcc4a6e8a603326467a6840f.webp"
width="500"
loading="lazy"
alt="1145cf430e1f015e5a552747f0f4a7c7_MD5|500"
>&lt;/li>
&lt;/ul>
&lt;h1 id="cursor-基于代码生成代码的基本步骤">Cursor 基于代码生成代码的基本步骤
&lt;/h1>&lt;p>&lt;img src="https://cdn.jsongo.top/2025/01/c9e05dbfde43c7dbb0f8f24909166b6c.webp"
loading="lazy"
>&lt;/p>
&lt;h2 id="1先把相应的目录结构建好">&lt;strong>1、先把相应的目录结构建好&lt;/strong>
&lt;/h2>&lt;p>因为不同的语言，代码组织的习惯和方式都不太一样。要做的第二件事，是先把代码结构先想清楚，然后发给 AI 问下比较合理的结构是什么样。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/0469fa103c6ebb26a2747e1491292465.webp"
width="500"
loading="lazy"
alt="011aee5c56b4b53497b5d789c0fbeffb_MD5|500"
>&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/0f0fef12795483bddb7e3d4bf5ffa74e.webp"
width="400"
loading="lazy"
alt="4ed11244d635908bdf3aaffee68c1db6_MD5|400"
> &lt;img src="https://cdn.jsongo.top/2025/01/71d3277a1c9450424f1175f05714cbd9.webp"
width="250"
loading="lazy"
alt="56695bc97506c77d525a8b7a30786162_MD5|250"
>&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/34125f9d5d186efc995f3f421e8ea716.webp"
width="600"
loading="lazy"
alt="3562669265f694cc8e5a37537570e387_MD5|600"
>&lt;br>
最后我调整了下，改成上文最后那张图。&lt;/p>
&lt;h2 id="2实现第一个-demo">&lt;strong>2、实现第一个 Demo&lt;/strong>
&lt;/h2>&lt;p>在我们的例子中，首先要解决的是不同语言里的请求方法不一样，先选一个最简单的请求来跑通流程。&lt;br>
把 js 里的请求代码找出来，帮 cursor 圈出来（加到上下文里），然后让它实现一个 Kotlin 的请求。&lt;/p>
&lt;blockquote>
&lt;p>当时让 Cursor 改了好几版都不能用，主要问题还是在于 KMP 这东西比较新，3.0 又做了大改，引用的包得去做下排列组合。后来在官方文档里找到了 3.0 的正确姿势发请求，把它丢给 Cursor，这时它才写出了正确的请求。&lt;br>
然后找到最基础的模块，比如本例中我选了 Chat 相关的接口，跑通非 Stream 模式比较简单，所以作为第一个接入。实现后，再研究了下 Kotlin 里怎么实现 SSE（这个 cursor 死活写不出正确的来），也跑通之后，一个模块算是比较完整了。&lt;/p>
&lt;/blockquote>
&lt;h2 id="3把这套模块复制到其它模块中">&lt;strong>3、把这套模块复制到其它模块中&lt;/strong>
&lt;/h2>&lt;p>第二个模块选择了 &lt;strong>Auth&lt;/strong> &lt;strong>模块&lt;/strong>，用它来验证第一个模块用到的通用方法是否可迁移。&lt;br>
首先是让 Cursor 把&lt;strong>请求模块的代码&lt;/strong>抽出来，做成一个通用的请求基类，其它模块继承它就行。把这个思路告诉 Cursor，让它改好后，进入下一步：把 JS 的 auth.ts 代码加入到 Context 中，在相应的目录下新建一个 Auth.kt 的 kotlin 模块，告诉 Cursor &lt;!-- raw HTML omitted -->把 auth 的逻辑从 ts 翻译成 kotlin&lt;!-- raw HTML omitted -->。&lt;br>
写完后，再在 Demo 文件夹里创建一个 Auth 的 &lt;strong>Demo 文件&lt;/strong>，让 Cursor 仿照 Chat 的 Demo 把 Auth 里的方法都用起来、去生成一个 Auth Demo。这步也做完后，进入第四步。&lt;br>
到 App 界面中去添加按钮，绑定 Demo，去触发它的方法，验证刚的代码是否可行。&lt;br>
这一步是最费时间的，因为第一版基本都不行，到处有问题，需要不断的试、不断的 fix bug。好在这些操作也可以让 Cursor 来做。&lt;/p>
&lt;h2 id="4都开发完之后发包写文档开源">&lt;strong>4、都开发完之后，发包、写文档、开源……&lt;/strong>
&lt;/h2>&lt;p>这个就不展开了，不是重点，不同语言也不一样，讲这个意义不大。&lt;/p>
&lt;h1 id="完整例子">完整例子
&lt;/h1>&lt;p>&lt;strong>让&lt;/strong> &lt;strong>Cursor&lt;/strong> &lt;strong>帮我写&lt;/strong> &lt;strong>Auth&lt;/strong> &lt;strong>模块的代码&lt;/strong>。&lt;br>
背景：我把 Coze API SDK 代码从 JS 迁移到 Kotlin，里面有很多个模块。之前已经实现了 Chat 模块的 API，这次实现 Auth 模块。代码也是不少、而且有点分散。&lt;/p>
&lt;h2 id="初步生成">初步生成
&lt;/h2>&lt;p>找到主入口文件，这个例子中，是 &lt;code>auth.ts&lt;/code> ，我把它加入到 Context 里。另外我自己也创建了一个文件在特定的目录里，把它也加到 Context 里（Kotlin 的代码结构组织跟 JS 还是有比较大的区别，下面再讲），这个文件让 Cursor 创建也行，只不过我还得给他描述路径/位置，还不如直接点“+”就创建了。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/1b108415bafc10678d91c7888802cb53.webp"
loading="lazy"
alt="600b7d39aa5a96c84d23b1409c0e1eac_MD5|0"
>&lt;br>
其中 auth.ts 只是一个入口文件，它涉及到很多相关的类和函数等，定义在其它文件，所以我在 prompt 里告诉它要把相关的定义都搬过去。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/86f176619ca75c5a4777eac559dfdf55.webp"
loading="lazy"
alt="414f29730ce41fba0d1bbc12407f4a87_MD5|0"
>&lt;br>
一下子写了 361 行，里面涉及到很多个方法都需要一个个验证，这个后面说。截图中可以看到，它还问我们要不要把一些相关的函数搬过来，让它继续。然后又给我搬了几百行过来，之后发现有一些依赖库缺失，所以问我是否要加到 gradle 配置里：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/83a947616392ee8d6a6dffb361e7b387.webp"
width="600"
loading="lazy"
alt="571c38e14c2b4c8c21c66b5194d2c0a1_MD5|600"
>&lt;/p>
&lt;h2 id="解决小问题">解决小问题
&lt;/h2>&lt;p>在上面这个地方就遇到了问题，它认为我其它文件里的逻辑可能没有用，直接大段大段地删除我原本的代码，如 Http.kt，&lt;code>auth.ts&lt;/code> 里用到了一个封装过的 HTTP 请求，所以在引入的时候，它找到我原来的 HTTP 请求的封装直接改了它。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/09954d7c01331cac66d6c52fd36252b6.webp"
width="800"
loading="lazy"
alt="205dc1e6d24d761c009260ac8cae8bb2_MD5|800"
>&lt;br>
这种事要能多盯着点、注意下可能的问题，及时补救，引导 Cursor 去修正。&lt;br>
一些小问题，在采用它的代码时，稍微留意下：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/3ae3a5bf297f7eda62ed740f33c619f4.webp"
width="800"
loading="lazy"
alt="b240a1222ec78b5b5382fdbbf75ea0e2_MD5|800"
>&lt;br>
再比如这种写法一看就感觉有点问题：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/568a319a389daad0a61def5e22073059.webp"
width="800"
loading="lazy"
alt="1116262183daa190d5cb3cc88895d884_MD5|800"
>&lt;br>
追问下，它就会纠正过来了：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/58c18e5e8bf2848a5561f5dd99d07c71.webp"
width="800"
loading="lazy"
alt="74847ffb18466f90a2d6c6ee88d114ac_MD5|800"
>&lt;br>
另一个比较大块的问题是，它生成完可能是有一些包引入问题的，因为它只有局部信息，缺少全局的，会犯像重复定义这样的错。而且可能有一堆 import 问题等着你解决，比如下面这个例子：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/1ea57a695273330b3ed5dd5661554b66.webp"
width="700"
loading="lazy"
alt="49ec0378de615efc9371ecab36f0c033_MD5|700"
> &lt;img src="https://cdn.jsongo.top/2025/01/d69d33cc46da8ae71cff9d95535d1e7a.webp"
width="700"
loading="lazy"
alt="aa7d0534cf5f6fc17177f5c45d157e25_MD5|700"
>&lt;/p>
&lt;p>&lt;strong>重复定义&lt;/strong>。&lt;br>
左边这个截图里的 RequestOptions，其实我已经在其它地方定义过了，但它又重新定义了一次，造成了多个地方冲突。这种情况也可以把问题描述给 Cursor 让它解决，但我看问题不大直接就手动合并了下这两个定义。&lt;br>
右边的截图中，跨端涉及到 Android 的包安装，开发过 Java 的同学都知道，这个有点麻烦，得找到合适的包添加到 library 里才行。这个也只能手动去做，因为过程有点麻烦：&lt;/p>
&lt;blockquote>
&lt;p>另外，两个截图都是 Android Studio 里的，在 Cursor 上是没有报相关的异常，而前者是专门为开发 KMP 定制的 IDE，它能找到更深层次的异常。所以我开两个 IDE，一个写代码，一个改 Bug。&lt;/p>
&lt;/blockquote>
&lt;h2 id="对接">对接
&lt;/h2>&lt;p>经过一系列操作，终于能正常跑起来了，但只能说&lt;strong>写完了&lt;/strong>。接下去是更麻烦的事情，我们调试 JWT Auth，在 Android 里 Cursor 建议用 &lt;code>com.auth0.jwt&lt;/code> 这个包，代码它也帮写好了，但运行时，接口一直返回签名错误，接下来就要一个字段一个字段的比对。&lt;br>
这里难免就要去打印过程中的每个数据，比如加密的 Payload、几个 key、algorithm、timestamp 等，用 JS 也跑一个、&lt;strong>打印出来，做下对比&lt;/strong>，看哪个字段有问题。&lt;br>
改完后，还是签名错误。参数对了，但还是不行，那就是算法问题，接下去核对了下 Base64 encode 的地方、RSA 算出的数据跟 JS 的跑出来是否一致。这里发现了问题，但没有头绪。&lt;br>
这时，死马当活马医，让 cursor 再帮我检查一遍：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/85a79b192ec91ca09d2fa5c60f3a996e.webp"
width="800"
loading="lazy"
alt="037c1ba6aa4295b45bc15c1a7a930e5d_MD5|800"
> &lt;img src="https://cdn.jsongo.top/2025/01/307e4e2a0ab807513480c86855068e19.webp"
width="700"
loading="lazy"
alt="1512af0b52ab204e684d567bc9c2b510_MD5|700"
>&lt;br>
看起来似乎是喂给算法的数据格式有问题（虽然数据都是对的），Cursor 实现了一个 toMap 的方法对原来的代码做了个转化，但这次代码跑不起来，重新让它改了一版，这下居然拿到正确的返回了。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/4ae11c7b01875dd3c0fab873498c6b90.webp"
width="700"
loading="lazy"
alt="ca3cf6410c6eafc5a7566ed550156a83_MD5|700"
>&lt;br>
返回解析失败，序列化的问题，不过是小问题，让它改完后，这次真的拿到了：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/cd181081d32b5a238a808949013c280e.webp"
width="800"
loading="lazy"
alt="bace8e15ef5ddc1d884a2b7da0919947_MD5|800"
>&lt;br>
就这个过程，搞了一个多小时。&lt;/p>
&lt;blockquote>
&lt;p>所以其实 Cursor 更像是一个帮程序员写简单代码、改 Bug 的一个辅助工具，在我们这个场景中，不太可能一次性把所有的代码从 TS 转过来，然后一次性成功。都得一个个调试。&lt;/p>
&lt;/blockquote>
&lt;h1 id="还能做什么">还能做什么
&lt;/h1>&lt;p>过程中发现，还有一些事情可以交给 Cursor，能解决的很好。&lt;/p>
&lt;h2 id="1整理代码变得更整洁些">1、整理代码，变得更整洁些
&lt;/h2>&lt;p>有一招简单的小技巧，可以让 Cursor 帮你整理下代码（至少看起来不像刚入门的人写的水平）：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/ed005e1d1081f932d31c31ae426b6f24.webp"
width="700"
loading="lazy"
alt="3c5dbaed0244273f9faac47623a5c284_MD5|700"
>&lt;br>
以及：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/d72c40dd0185031bddc7b1ca07d1ecdf.webp"
width="700"
loading="lazy"
alt="64f0e1e71796b58da1d0939017c89c96_MD5|700"
>&lt;br>
Prompt:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">把代码改得极其整洁，风格保持一致，能简化的处理下，但同一行不要太多字符。注释的话，不合理的注释可以删掉，但也不要随便删，同时把中文的注释翻译成英文
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="2解决拼写问题">2、解决拼写问题
&lt;/h2>&lt;p>比如这个 README，我们研发同学写的比较匆忙，有比较多的拼写或表达上的问题，https://github.com/coze-dev/coze-java/pull/3/files ，用 cursor 一键完成修改，重点是它能发现 README 里的示例代码中，用的字段名不正确的问题：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/a2a57432caf6934023aca6188eb999b2.webp"
width="800"
loading="lazy"
alt="67eef2544216d5bc05746b5e1f26b2b5_MD5|800"
> &lt;img src="https://cdn.jsongo.top/2025/01/90d987a8fead9f2db45c1afd91824e58.webp"
width="700"
loading="lazy"
alt="09bbb3747c1a278eef3f672f204c3f79_MD5|700"
>&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/55496ca31ffb05f169c550e905810115.webp"
width="700"
loading="lazy"
alt="41011b38b591252aea92768c14e304c2_MD5|700"
>&lt;/p>
&lt;h2 id="3批量修改小问题">3、批量修改小问题
&lt;/h2>&lt;p>遇到问题比较多的时候，直接截图，丢给 cursor，它会一个个帮你改。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/ae4af222ea296426b04ddd084b1ddfd0.webp"
width="500"
loading="lazy"
alt="f77a083c5ee957658f80d19e5582c6f1_MD5|500"
> &lt;img src="https://cdn.jsongo.top/2025/01/2b61dce38f2bd6f806ffc42af1da764b.webp"
width="500"
loading="lazy"
alt="4afb655c9393f474cadb8c0f6f4241b5_MD5|500"
>&lt;br>
还有一个技巧是，让它参考其它同类的代码来实现：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/406acbce7072a3e2cadf3a5c6ebe34da.webp"
width="500"
loading="lazy"
alt="|500"
>&lt;br>
以及：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/8e6d7d1522cd199bba69fd23f96b799d.webp"
width="500"
loading="lazy"
alt="|500"
>&lt;/p>
&lt;p>还有一次给我引入了 java 包，在 common 里：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/3c13e95894243029f6d9878688fa5b47.webp"
width="700"
loading="lazy"
alt="|700"
>&lt;br>
不太合理，这时就要让他修正下，同时我也丢给它一个 KMP 官方给的参考，让它照着改，这总不会再弄错吧。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/a4a4c7a782729d0a708fbd710c1dd048.webp"
width="600"
loading="lazy"
alt="|600"
>&lt;/p>
&lt;blockquote>
&lt;p>下面的例子，是我开发另一个 Coze 插件时遇到的，顺便都整合到这个文档里、不单独拆开了。&lt;/p>
&lt;/blockquote>
&lt;h2 id="4强有力的工具logging">4、强有力的工具：logging
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsongo.top/2025/01/efb2c1134ac77e7c50e5248f01c62265.webp"
width="500"
loading="lazy"
alt="05b5da00f57db097cdb439b39e55cfdb_MD5|500"
>&lt;br>
我连续让它改了很多次（不下 10 次），它也换了好几种实现方法，都不行。后来我提示他是否需要再加一些打印来定位问题，然后他发现确实应该这样。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/53f82d55f491285c2ee9132dd69636db.webp"
width="500"
loading="lazy"
alt="35c347109c19e7421b89c2ff4a705ed0_MD5|500"
>&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/f18aa994a02b7255bed74408f76f80fc.webp"
width="500"
loading="lazy"
alt="accbaf51486af45cdbec970b93dbeb8e_MD5|500"
>&lt;/p>
&lt;blockquote>
&lt;p>语气也变得更客气，本来一直说“我”，这次改了称呼“我们”，仿佛在说这是我们的共同成果&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>用这个技巧可以极大的提升问题修复的速度。当然如果你的代码都是在 cursor 里跑的、输出也在它的 terminal 里，那会更方便一些。我的场景是，代码在 serverless runtime 里运行，本地只是为了让 cursor 来改代码。&lt;/li>
&lt;/ul>
&lt;h2 id="5思考并引导">5、思考并引导
&lt;/h2>&lt;p>有的时候，Cursor 掉坑里去了，试了一二十次了，都不太行。后来我想到一个重要的信息，给他补充了下，结果不到 5 次就跑起来了，方向对了。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/be8fdee4ad64d56b435aab0e2ceb9ac4.webp"
width="500"
loading="lazy"
alt="9a7218f4b8ab4400b9a059cca2dfbea6_MD5|500"
>&lt;/p>
&lt;blockquote>
&lt;p>这从里来看，Cursor 并不能让完全不懂代码的人来写出各种复杂的逻辑，甚至一些看似简单、但潜藏着很多细节的功能，他们也很难很难搞定。&lt;strong>所以广大程序员，暂时还能松一口气&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="6及时给反馈有时能有些惊喜">6、及时给反馈，有时能有些惊喜
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsongo.top/2025/01/964e3bd7d40baea9275703a22dba7fb4.webp"
width="500"
loading="lazy"
alt="4c72cba33e74267f72c6e802ba14b6ff_MD5|500"
>&lt;br>
然后 blabla 跟我说了一堆，它会把之前几次尝试为什么没成功、这次为什么成功了，给你做个总结。很有意思。&lt;/p>
&lt;h1 id="过程记录">过程记录
&lt;/h1>&lt;h2 id="kmp-sse-遇到的一些坑">KMP SSE 遇到的一些坑
&lt;/h2>&lt;p>1、SSE 以前是用外部库，到了 3.0 之后，官方原生支持了，其它方案试了下没通。&lt;br>
2、iOS 跑 SSE 会抛错：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Uncaught&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Kotlin&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">exception&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">io&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ktor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">plugins&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sse&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">SSEClientException&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Exception&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">http&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">request&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Domain&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">NSURLErrorDomain&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Code&lt;/span>&lt;span class="o">=-&lt;/span>&lt;span class="mi">1200&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;An SSL error has occurred and a secure connection to the server cannot be made.&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>跟豆包“交流”了几回后，她终于找到问题点了，我改了下配置果然就可以了：&lt;br>
&lt;a class="link" href="https://www.doubao.com/thread/w18b43c12a58af46c" target="_blank" rel="noopener"
>https://www.doubao.com/thread/w18b43c12a58af46c&lt;/a>&lt;br>
简单说就是打开 Info.plist 添加：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-XML" data-lang="XML">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;key&amp;gt;&lt;/span>NSAppTransportSecurity&lt;span class="nt">&amp;lt;/key&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;dict&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;key&amp;gt;&lt;/span>NSAllowsArbitraryLoads&lt;span class="nt">&amp;lt;/key&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;true/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;key&amp;gt;&lt;/span>NSExceptionDomains&lt;span class="nt">&amp;lt;/key&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;dict&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;key&amp;gt;&lt;/span>api.coze.com&lt;span class="nt">&amp;lt;/key&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;dict&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;key&amp;gt;&lt;/span>NSExceptionAllowsInsecureHTTPSLoads&lt;span class="nt">&amp;lt;/key&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;true/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;key&amp;gt;&lt;/span>NSExceptionMinimumTLSVersion&lt;span class="nt">&amp;lt;/key&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;string&amp;gt;&lt;/span>TLSv1.2&lt;span class="nt">&amp;lt;/string&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;key&amp;gt;&lt;/span>NSExceptionRequiresForwardSecrecy&lt;span class="nt">&amp;lt;/key&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;false/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/dict&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/dict&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/dict&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>原因主要是：iOS 系统默认信任一系列常见的证书颁发机构（CA）所颁发的证书，但如果服务器使用的是比较小众或者自签名的证书，iOS 设备可能不会自动信任它。上面把 &lt;code>NSExceptionAllowsInsecureHTTPSLoads&lt;/code> =&amp;gt; true，&lt;code>NSExceptionRequiresForwardSecrecy&lt;/code> =&amp;gt; false。&lt;/p>
&lt;h2 id="语言框架带来的麻烦">语言框架带来的麻烦
&lt;/h2>&lt;p>开发 KMP 比较麻烦的点是，它动不动就炸💥💥💥：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/75eb7e325f7128c528fbfb128db05263.webp"
width="800"
loading="lazy"
alt="bf7c2bde8023209700897ad92f5412cd_MD5|800"
>&lt;br>
Git diff 看不到任何区别，后来查了下，是环境上的包冲突，一不小心装了版本冲突的包就会出问题。版本的匹配关系还有人专门做了个表：https://github.com/realm/realm-kotlin#version-compatibility-matrix 但还是不全，真遇到了问题还是得多试，没啥技术含量。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/191bc2fd51984c29da43d5c355562e7b.webp"
width="500"
loading="lazy"
alt="e3c399703cd2afa57208ac3c424603f2_MD5|500"
>&lt;br>
上面这个异常，试了很久都没解决（可能是我对 Kotlin 环境不熟悉），后来干脆重建一个目录，把代码原样的 clone 过去，再重新用 Android Studio 加载、编译，居然就好了…… 不知道 Java 类语言的开发者，平时要花多少时间在环境和包依赖上，这些纯属无产出的事情。&lt;/p></description></item><item><title>Stable Diffusion 生图技术（一）</title><link>https://www.jsongo.top/articles/stable-diffusion-gen-image-1/</link><pubDate>Tue, 19 Nov 2024 16:36:27 +0800</pubDate><guid>https://www.jsongo.top/articles/stable-diffusion-gen-image-1/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/772c64fbb07e3cd46573602f922a7829.jpg" alt="Featured image of post Stable Diffusion 生图技术（一）" />&lt;h1 id="概述">概述
&lt;/h1>&lt;h2 id="背景">背景
&lt;/h2>&lt;p>Stable Diffusion 最初是由德国慕尼黑大学的 CompVis 研究小组、纽约的 RunwayML 公司等组成的国际研究团队开发的，后来 Stability AI 参与其中并推动了其发展。&lt;br>
Stable Diffusion 的发展历程如下：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/afb65322de6b531c0c01e86e6d27c0e0.webp"
width="900"
loading="lazy"
alt="|900"
>&lt;/p>
&lt;h2 id="技术简介">技术简介
&lt;/h2>&lt;p>Stable Diffusion 在模型架构中采用了 Transformer 架构的一些特性，基于扩散模型架构来生成图片。&lt;br>
它的原理用白话说，比较简单：加噪和去噪（专业术语叫前向扩散和反向扩散）。加噪后的图片主要用于训练或作为初始输入（latent），然后训练一个模型去实现某些图像生成目标（去噪过程）。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>前向扩散&lt;/strong>：在前向阶段，通过向原始图像数据（如真实的照片或绘画）添加噪声，逐步将图像转换为纯噪声。这个过程是在多个时间步（time - steps）中完成的，每一步都按照一定的规则（通常是基于高斯分布）添加噪声，使得图像信息逐渐被噪声掩盖。例如，开始时图像可能还比较清晰，随着时间步的增加，图像越来越模糊，最终变成完全的噪声。&lt;/li>
&lt;li>&lt;strong>反向扩散&lt;/strong>：这是生成图像的关键阶段。从纯噪声开始，模型通过学习到的去噪过程，逐步恢复图像信息。模型会预测每个时间步中需要去除的噪声，经过多个时间步的迭代，最终生成一张类似于训练数据分布的图像。这个过程类似于从无序的噪声中逐渐 “雕刻” 出有意义的图像。&lt;/li>
&lt;/ul>
&lt;h1 id="生图过程">生图过程
&lt;/h1>&lt;p>&lt;img src="https://cdn.jsongo.top/2024/11/d66a5473be54d712b3aa8e879f9a8c3a.webp"
width="700"
loading="lazy"
alt="|700"
>&lt;/p>
&lt;h2 id="模型-checkpoint跟采样的关系">模型 （Checkpoint）跟采样的关系
&lt;/h2>&lt;p>Checkpoint 包含了模型在特定训练阶段的所有权重、偏置以及优化器的状态等信息，而采样模型的参数是由 Checkpoint 所确定的，采样模型使用该 Checkpoint 中存储的权重和其他参数进行计算。不同的 Checkpoint 会导致采样模型在生成图像时表现出不同的性能和风格。例如，某些 Checkpoint 可能侧重于生成高分辨率的图像，而另一些可能更擅长生成具有特定艺术风格的图像。这是因为在训练过程中，不同的 Checkpoint 所对应的训练数据和训练目标可能有所不同，从而影响了采样模型的行为。&lt;/p>
&lt;h2 id="clip-text-encode">CLIP Text Encode
&lt;/h2>&lt;p>属于 Condition 节点，它用 CLIP 模型对文本 Prompt 进行编码，对模型生成的结果进行方向上的引导，其实可能理解为文本模型中的 embedding。&lt;/p>
&lt;h2 id="采样">采样
&lt;/h2>&lt;p>生图其实就是一个反向扩散的过程，从一个完全是噪声的图像开始，通过模型逐步去除噪声来生成图像。这个过程通过一个采样函数来实现，它基于模型预测的噪声来更新噪声图像。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/dd2433499e7a9229aa5bd816177c8988.webp"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Steps&lt;/strong>，迭代生图，每次更新噪声图像，需要经过多个 Step 的迭代。随着 Step 反复执行，图像中的噪声逐渐减少，最终生成一个近似原始图像分布的图像。不过生成的图像质量可能会受到多种因素的影响，如模型的性能、采样方法、时间步数等。在实际应用中，可能需要对生成的图像进行后处理（如调整颜色、对比度等）来提高图像质量。&lt;/li>
&lt;li>&lt;strong>seed&lt;/strong>，种子值，用于初始化随机数生成器。相同的种子值在相同的模型和参数设置下会生成相同的图像，这有助于复现结果。&lt;/li>
&lt;li>&lt;strong>control_after_generate&lt;/strong>：这个参数可能与生成后的控制操作有关，例如对生成的图像进行随机化处理&lt;/li>
&lt;li>&lt;strong>steps&lt;/strong>：指生成过程中的迭代步数。步数越多，生成的图像通常会越精细，但也会增加计算时间。&lt;/li>
&lt;li>&lt;strong>cfg&lt;/strong>（Classifier-Free Guidance）：无分类器引导的强度，它是一种在生成式模型（如 Stable Diffusion）中用于引导图像生成方向的技术，决定了模型在生成图像时对正向提示（你希望在图像中出现的内容）的遵循程度。较高的 CFG 值会使生成的图像更紧密地遵循正向 Prompt，但也有可能导致图像过度拟合。
&lt;ul>
&lt;li>取值范围：
&lt;ul>
&lt;li>CFG 的值通常在 1 到 20 之间，理论上可以取更高的值，但在实际应用中，过高的值往往会导致图像质量下降。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>较低值（1 - 4）：
&lt;ul>
&lt;li>当 CFG 值较低时，生成的图像会更具随机性和创造性。模型对正向提示的遵循程度较弱，因此可能会生成一些与提示不太相关但具有独特创意的图像。这种情况下，图像可能会包含一些意外的元素或风格。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>中等值（4 - 10）：
&lt;ul>
&lt;li>在这个范围内，是比较常用的取值。模型会在遵循正向提示和保持一定的创造性之间取得较好的平衡。能够生成与提示较为符合的图像，同时也不会显得过于刻板。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>较高值（10 - 20）：
&lt;ul>
&lt;li>当 CFG 值较高时，生成的图像会非常紧密地遵循正向提示。这可能会导致图像过于 “完美” 地符合提示，但也可能会出现一些问题，比如图像的细节可能会显得不自然，色彩可能会过于饱和，或者图像可能会失去一些自然的随机性和美感&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>sampler_name&lt;/strong>：这是指采样器的名称。不同的采样器（如 Euler、Langevin 等）有不同的特性，会影响图像生成的速度和质量。&lt;/li>
&lt;li>&lt;strong>scheduler&lt;/strong>：调度器，用于控制生成过程中的步长和其他参数。不同的调度器会影响生成的效率和结果。&lt;/li>
&lt;li>&lt;strong>denoise&lt;/strong>：去噪参数控制生成过程中对噪声的去除程度。较低的去噪值会使生成的图像更具随机性，而较高的值会使图像更平滑和可预测。&lt;/li>
&lt;/ul>
&lt;h2 id="vae-decoder变分自解码器">VAE Decoder（变分自解码器）
&lt;/h2>&lt;p>图像数据往往是高维的，包含大量的像素信息，所以一般训练和计算时，往往要压缩到低维来处理，用更紧凑的方式表示图像的关键特征，就像文本模型中的 Embedding 处理，变成稠密的数据，在图像处理领域叫潜在空间（Latent Space）。而解码器则是将潜在空间中的表示再转换回图像数据空间，尽可能地重建原始图像。&lt;br>
生成新图的过程，由于潜在空间是连续的，稍微改变潜在空间中的向量值，就可以生成与原始图像在某些特征上有所变化的新图像。例如，在生成人脸图像的 VAE 模型中，在潜在空间中沿着某个方向移动向量可能会改变人脸的表情、发型或者年龄等特征。&lt;/p>
&lt;h2 id="latent-image">Latent Image
&lt;/h2>&lt;p>一般在整个 ComfyUI 流程中，会插入一张空的（Empty） Lantent Image，它提供了一个初始的 “画布”，让模型在这个基础上进行生成或转换操作。&lt;br>
当然如果是对已有的图片进行调整、修复或优化，则可以把空的图换成一张现成的图片，这时就要把它加载并转换为合适的潜在表示形式后，可以作为生成过程的起点。在 ComfyUI 中，可能涉及到将图片通过适当的预处理步骤，如调整大小、归一化等操作后，然后将其编码为潜在空间中的表示，这样就可以基于已有的图像内容进行修改、风格转换或者其他生成操作。&lt;/p>
&lt;h1 id="stability-ai-官方">Stability AI 官方
&lt;/h1>&lt;p>Stable Diffusion 的官方可用的模型，可以从 API 文档中看到： &lt;a class="link" href="https://platform.stability.ai/pricing" target="_blank" rel="noopener"
>Stability AI - Developer Platform&lt;/a>。最新的是 SD 3.5（2024 年 11 月）。&lt;/p>
&lt;ul>
&lt;li>1 credit = $0.01&lt;/li>
&lt;li>这么算，生成一张 SD 3.5 的图片，medium 要 $0.035，差不多 0.25 元，4 张 1 块。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/11/207f1abc8b1be591d3f76ec236344c3c.webp"
width="700"
loading="lazy"
alt="736deaffc1c02497df089d14539fba5d_MD5|700"
>&lt;/li>
&lt;/ul>
&lt;h2 id="体验">体验
&lt;/h2>&lt;p>&lt;a class="link" href="https://stabledifffusion.com/tools/ai-image-generator" target="_blank" rel="noopener"
>Free AI Image Generator - Turn Text to Image Online | Stable Diffusion Online&lt;/a>&lt;/p>
&lt;h1 id="字节的-lighting-模型">字节的 Lighting 模型
&lt;/h1>&lt;p>&lt;a class="link" href="https://huggingface.co/ByteDance/SDXL-Lightning" target="_blank" rel="noopener"
>ByteDance/SDXL-Lightning at main&lt;/a> 字节的这个模型生成效果相当不错。&lt;br>
它同时提供了 Full UNet 和 LoRA 版本，都是相对比较小的蒸馏模型（虽然 UNet 也有几个 G）。&lt;/p>
&lt;blockquote>
&lt;p>We provide both full UNet and LoRA checkpoints. The full UNet models have the best quality while the LoRA models can be applied to other base models.&lt;/p>
&lt;/blockquote>
&lt;h2 id="小科普可跳过">小科普（可跳过）
&lt;/h2>&lt;h3 id="概念">概念
&lt;/h3>&lt;ul>
&lt;li>UNet 是卷积神经网络（CNN）的一种特殊架构，在生成对抗网络 (GANs) 和扩散模型中广泛使用。它是一种完整的网络架构，专门用于图像分割任务，从输入图像到输出分割结果，有自己独立的结构和训练流程。&lt;/li>
&lt;li>LoRA 不是一种独立的网络架构，而是一种模型微调策略，可以应用于各种现有的预训练模型（包括但不限于基于 UNet 架构的模型），用于在不大量修改原始模型结构的情况下进行任务适配。&lt;/li>
&lt;/ul>
&lt;h3 id="从参数规模与训练成本来看">从参数规模与训练成本来看
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>UNet&lt;/strong>：在训练过程中，需要对整个网络的参数进行学习和更新，尤其是在处理高分辨率图像或复杂任务时，可能需要大量的训练数据和计算资源。&lt;/li>
&lt;li>&lt;strong>LoRA&lt;/strong>：通过低秩分解减少了需要训练的参数数量，在对大型预训练模型进行微调时，训练成本显著降低，对数据量的要求也相对较少。&lt;br>
UNet 的模型一般都比较大：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/11/8f1f152a35835044e0ea8fc381a9333b.webp"
width="475"
loading="lazy"
alt="|475"
>&lt;br>
LoRA 则小很多&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/11/36b48790266f80b2cb03cfc22ded0f13.webp"
width="475"
loading="lazy"
alt="|475"
>&lt;/li>
&lt;/ul>
&lt;h2 id="使用">使用
&lt;/h2>&lt;p>它们都有 2-Step, 4-Step, 8-Step，其中 1-step 只是实验性的、效果不好、质量不稳定，一般建议用折中的 4-step，如果资源充足可以选质量最好的 8-step。&lt;br>
ComfyUI 中的使用非常简单：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/11/fc799454d0483ec8b7fea253e7ce45e4.webp"
width="675"
loading="lazy"
alt="|675"
>&lt;br>
如果只是想玩玩，可以直接在 huggingface 上试试：&lt;a class="link" href="https://huggingface.co/spaces/ByteDance/SDXL-Lightning" target="_blank" rel="noopener"
>SDXL-Lightning spaces&lt;/a> ，效果还是不错的：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/11/22638b08323398c180c2d2ff0d1e59f8.webp"
width="700"
loading="lazy"
alt="|700"
>&lt;/p></description></item></channel></rss>