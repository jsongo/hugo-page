---
updated_at: 2024-10-27T11:31:09.698+08:00
edited_seconds: 220
tags:
  - IT/server/trace
created_at: Tue, Apr 8, 2025 - 20:51:33
date: 2025-04-08T20:51:33.101+08:00
banner_icon: 👷🏼
banner: https://cdn.jsongo.top/banners/1089988f36245b8456d63b99a86d3d2b.jpg
title: Tracing 基础
description: 简单介绍 Tracing技术，它是一种用于跟踪和记录系统运行状态、事件或资源使用情况的技术，广泛应用于软件开发、性能优化和故障排查等领域。
slug: tracing-101
draft: false
---
Tracing 是一种用于跟踪和记录系统运行状态、事件或资源使用情况的技术，广泛应用于软件开发、性能优化、故障排查等领域。以下是 tracing 中的一些关键概念、应用及跟 log 之间的关系。
# Tracing 概念
## 🔍 Tracing 基础概念梳理
### 🌲 整体结构（树形）
- 一个请求的完整追踪过程被称为一个 **Trace**，可以用一个 trace_id 唯一标识。
- 一个 Trace 是由多个 **Span** 组成的，**Span 形成一棵树结构**。
    - 根节点是最早创建的那个 Span（通常是入口请求，如前端或网关）。
    - 子节点 Span 表示在处理过程中产生的后续调用（如微服务之间的调用、数据库访问等）。
---
### 🧩 核心概念一览
| **概念**                | **描述**                                                            |
| --------------------- | ----------------------------------------------------------------- |
| **Trace**             | 表示一次完整的请求链，一般由一个唯一的 trace_id 标识。可以跨多个服务。                          |
| **Span**              | Trace 中的一个操作单位，表示一次具体的调用或操作，有 span_id。可以嵌套形成父子关系。                 |
| **Parent Span**       | 一个 Span 可以有一个父 Span（用 parent_span_id 标识），用于构建调用树。                 |
| **Child Span**        | 父 Span 内部调用的子操作，属于同一个 trace_id，形成树形结构。                            |
| **Baggage**           | 是附着在 Trace 上的键值对，会随着 trace 传播给每个后续的 span，可用于传递业务上下文数据（如用户 ID、地域等） |
| **Attributes / Tags** | 是附着在 Span 上的键值对，用于记录执行时的状态、参数信息等。                                 |
| **Events / Logs**     | 是附着在 Span 上的时间序列事件，例如某个时刻报错、收到响应等。                                |

## Span
🧠 每个 Span 都包含什么？
- span_id：该 Span 的唯一标识
- trace_id：所属的 Trace ID
- parent_span_id：它的父节点 Span 的 ID（根 span 没有父 ID）
- name：这个 span 的名称（如“调用用户服务”）
- start_time / end_time：起止时间
- attributes（也叫 tags）：键值对，描述上下文或运行参数
- events（或 logs）：事件序列（如异常、返回值）
- status：表示是否成功（比如 HTTP 500）
- baggage（选）：附加在 trace 上传播的键值对（所有 span 可共享）  
但如果你每个小操作都创建一个 span，会导致：
- 数据太多，观察成本高
- 采样/存储开销大  
所以建议：
- 只给 **关键路径**加 span，比如：IO 操作、外部调用、耗时步骤。
- 对短暂或无关紧要的内部操作（如计算、循环等）不需要单独创建 span。

### 🧬 数据流示意（树结构）
**Span 是可以相互嵌套的**，它天生就是为了表现“一个操作内部还包含其他子操作”这种结构。它之所以是树结构，就是因为服务调用本身、或某个操作本身，就常常是“嵌套”的。
```text
Trace (trace_id: abc123)
│
└── Span A (root span, span_id: 1)
    ├── Span B (span_id: 2, parent: 1)
    │   ├── Span D (span_id: 4, parent: 2)
    │   └── Span E (span_id: 5, parent: 2)
    └── Span C (span_id: 3, parent: 1)
```

### ⏱ 耗时信息的采集
每个 Span 都记录 start & end 时间，比如
```json
{
  "span_id": "abc123",
  "start_time": "2025-04-13T10:00:00.123Z",
  "end_time": "2025-04-13T10:00:01.456Z",
  "duration_ms": 1333
}
```
✅ 计算方式：duration = end_time - start_time（建议保留 ms 精度）
## ✨ 补充说明
- Span 使用
	- **Span != 服务**，一个服务内可以产生多个 span，比如控制器、服务、DAO 等不同层级调用。
	- **Span 的嵌套并不完全等于服务调用**，可以是方法内的子步骤。
	- **Baggage 不适合放太多数据**，因为会被全链路传播，性能和隐私要注意。

# 一些应用
## 展示耗时信息（前端可视化）
### 1 、树形结构 + 耗时
- 展示结构 + 每一层的耗时：
```text
└── 用户请求（1000ms）
    ├── 认证服务（200ms）
    ├── 用户服务（600ms）
    │   ├── 数据库查询（400ms）
    │   └── 缓存写入（50ms）
    └── 日志服务（100ms）
```
### 2 、时间线图 / 甘特图（推荐）
- 横轴是时间，纵轴是调用树层级，像这样：
```text
时间轴:  |----100ms----|----100ms----|----100ms----|…
用户请求:  [------------------------------]
用户服务:     [---------------]
数据库查询:   [------]
缓存写入:                   [--]
```
- 可以一眼看出：
	- 谁最耗时
	- 哪些操作是串行的、哪些是并行的
### 3、判断性能瓶颈（基于耗时）
根据 trace 可以自动检测一些问题：
- 某个 span 耗时超过阈值（如 200ms）
- 同一个服务下某些 span 总是很慢
- 多个 span 串行而不是并行执行（如 A → B → C）

## ✨ 补充说明
- 统一时间来源
	- 使用同一个时钟源（如 performance.now() 或 process.hrtime()，不要用 Date.now() 混用）
	- 建议用 **高精度时间**（纳秒或微秒），落库前可以转成毫秒或浮点秒数。

# Tracing 与 Logging 的关系
在软件开发中，**Tracing（追踪）** 和 **Logging（日志记录）** 是两种常用的技术，尽管它们的功能相似，但在应用场景和实现方式上有显著差异。  
一句话：Tracing 是用于“跨服务的调用链分析”，而 Logging 是用于“记录事件和调试信息”。
## TL; DR
- **Tracing 和 Logging 是互补的技术**：
  - Tracing 更适合实时监控和动态数据上报，而 Logging 则适合长期记录和调试。
  - 它们可以结合使用：例如，在应用运行期间使用 Tracing 技术获取实时数据（如资源使用情况），然后通过 Logging 技术将错误信息记录下来。
- **没有严格的包含关系**：
  - 它们各自服务于不同的场景和技术需求，但两者并不互相覆盖所有功能。
## 核心能力对比
| **维度**  | **Logging**                 | **Tracing**                          |
| :-----: | --------------------------- | ------------------------------------ |
| 📍 关注点  | 记录本地事件（debug/info/error）    | 跨服务的请求链路与时序                          |
|  🧩 粒度  | 每一行日志就是一条信息                 | 每个 trace 是一个整体请求，包含多个 span           |
| 🔍 定位问题 | 看错误堆栈、日志内容                  | 看请求链在哪个环节耗时多/出错                      |
| ⏱ 时间维度  | 一条日志有个 timestamp            | Trace 有 start/end + 每个 Span 有耗时      |
| 🌐 上下文  | 通常只看当前服务                    | 可以跨多个服务传播 context（trace_id, baggage） |
| 📈 可视化  | 日志系统展示（Elasticsearch, Loki） | 链路图、时间线（如 Jaeger, Zipkin）            |
| 🧰 典型工具 | Log4j、SLF4J、Winston、Loki    | OpenTelemetry、Jaeger、SkyWalking      |
## 软件开发视角
### 1. Tracing 的作用
- **追踪应用程序的行为**：Tracing 主要用于跟踪应用程序的运行状态、资源使用情况（如 CPU、内存）、错误发生等。
- **实时监控**：常用于实时应用中，例如浏览器插件、云服务监控等。
### 2. Logging 的作用
- **记录详细信息**：Logging 是记录日志文件或直接发送到云服务的详细信息（如错误堆栈、调用链）。
- **调试和分析**：用于调试错误源，并提供详细的运行轨迹。
### 3. Tracing 和 Logging 的关系
- 两者其实是可以相辅相成的。一个系统通常这样用：  
	- Tracing → 提供“全局视角”：看到某个请求走了哪些服务、在哪一步慢了或失败了  
	- Logging → 提供“局部细节”：具体方法内部执行了什么、变量值、堆栈、报错
- 举例说明下，比如 Tracing 信息如下：
```text
TraceID: abc123
Span: [用户服务处理订单] 150ms
└── [调用库存服务] 90ms ❌ Timeout
```
- Logging 里，有如下信息：
```text
[WARN]TraceID=abc123 无法连接库存数据库
[ERROR] TraceID=abc123 查询失败，返回500
```
当看到 trace 知道问题出在“调用库存服务”，再用 trace_id 去日志里一搜，就能看到详细原因。

## 替代性和建议
### ✅ 理论上可以把 Tracing 当 Log 用
>  如 OpenTelemetry 就是一个记录很细的系统，可以当 log 用。
- Tracing 的每个 span 可以附加 **事件（event）/ 日志（log）**
- 可以做到类似 logger.info(…) 的功能
- 可以把 span.addEvent(" 准备开始数据库查询 ") 当作 log
### ❌ 但不建议只用 Tracing 替代 Logging
- Tracing 会采样（不是所有请求都记录）→ 有的错误日志你找不到
- 写日志的自由度高（结构、内容、格式），Tracing 更偏结构化
- 日志可以本地保存、不依赖全链路链路系统
- Tracing 更适合宏观链路分析，不适合长期审计、安全排查等用途
### 🧠 推荐做法（实际工程中）
|**级别**|**工具**|**用途**|
|---|---|---|
|🔭 全局观|Tracing (OpenTelemetry)|分布式链路追踪，定位请求瓶颈|
|🛠 细节|Logging (Winston, Logback…)|开发调试、审计、错误定位|
|📊 聚合|Metrics (Prometheus…)|吞吐量、请求数、错误率等统计指标|        
在写日志时 **附带 trace_id** 是非常推荐的做法（比如 MDC、trace context），这样就可以轻松做到 “trace 定位后，日志深入排查”。比如在 log 里统一打出：`[INFO][trace_id=abc123]查询成功` 。  
一个请求来了，你可以：
- 用 Trace 找到问题在哪个服务
- 用 Log 看服务内部报错细节
- 用 Metrics 看整体健康趋势
