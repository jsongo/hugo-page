[{"content":"作者：华生医生 那是1890年11月一个寒风凛冽的傍晚，伦敦的天空阴沉得仿佛要压下来，贝克街221B的壁炉烧得正旺。我正埋头记录前一周那桩“切尔西画像失窃案”的细节，而歇洛克·福尔摩斯则站在窗前，拉着小提琴，琴声低沉而忧郁。他已经三天没碰过食物，显然又陷入了那种只有新谜团才能打破的倦怠。\n就在这时，楼梯上传来急促的脚步声，紧接着门被猛地推开。一位身材高大的男子闯了进来，他约莫五十岁，头发花白，穿着厚实的呢大衣，脸上带着一种难以掩饰的惊恐。他的到来让福尔摩斯立刻放下了琴弓，眼中闪过一丝期待的光芒。\n“福尔摩斯先生，我是亨利·巴克利，住在萨里郡的布兰德庄园，”他喘着粗气说道，“我需要您的帮助——我的侄子失踪了，而我收到了一封信，暗示他可能已经死了！”\n福尔摩斯示意他坐下，语气平静却带着一丝急切：“巴克利先生，从头说起。细节越多越好。”\n巴克利掏出一块手帕擦了擦额头的汗，开始叙述：“我侄子菲利普·巴克利是个年轻的工程师，三天前他从伦敦回来，说要去庄园的钟楼检查一座老铜钟——那是座有百年历史的钟，据说是我们家族的传家宝。可那天晚上后，他就再也没出现。昨天，我收到一封匿名信，信上说：‘菲利普已随铜钟长眠，勿寻。’我搜遍了庄园，甚至报警，可毫无线索！”\n福尔摩斯接过那封信，信纸泛黄，字迹歪斜，显然是用左手匆匆写成。他嗅了嗅信纸，又用放大镜仔细观察。“油墨味很淡，纸上有轻微的煤灰痕迹。寄信人可能在工业区附近。巴克利先生，您侄子最近有何异常举动？”\n“他一直在研究那座铜钟，”巴克利回忆道，“说是发现了什么秘密，还提到要找专家验证。他性格开朗，没什么敌人，这事让我完全摸不着头脑。”\n福尔摩斯站起身，抓起外套。“华生，收拾一下，我们即刻前往布兰德庄园。这案子有意思了。”\n当晚，我们乘火车抵达萨里郡，夜色中，布兰德庄园显得阴森而古老。庄园坐落在一片荒凉的丘陵间，周围环绕着稀疏的松林。一座孤零零的钟楼耸立在庄园东侧，铜钟的轮廓在月光下若隐若现。巴克利领我们走进主宅，仆人们神色不安，显然被最近的事件搅得人心惶惶。\n福尔摩斯直奔钟楼。钟楼内部阴冷潮湿，一座巨大的铜钟悬挂在顶端，钟面上刻着模糊的花纹和拉丁铭文。福尔摩斯用手杖敲了敲钟身，发出一声低沉的回响。他蹲下检查地面，发现几滴干涸的蜡迹和一小块撕碎的纸片，纸上写着“下方”二字。\n“华生，这钟有问题，”他低声道，“蜡迹说明有人深夜在此活动，而这纸片可能是菲利普留下的线索。”\n他转向巴克利：“这座钟是否能移动或打开？”\n巴克利摇头：“它固定在梁上，几代人都没动过。不过菲利普说过，钟底似乎有机关。”\n福尔摩斯爬上梯子，用放大镜细查钟底。片刻后，他按下一块不起眼的凸起，只听“咔哒”一声，钟底露出一道暗门。他示意我递上提灯，探头一看，里面竟是一条狭窄的石梯，直通地下。\n我们三人顺梯而下，来到一个阴暗的地窖。空气中弥漫着霉味和淡淡的化学气味。地窖中央摆着一张木桌，桌上散落着工具、图纸和几瓶不明液体。墙角堆着几个木箱，箱盖上沾着新鲜的泥土。福尔摩斯迅速翻看图纸，发现那是铜钟的结构设计，旁边还有一行潦草的笔记：“核心在基座，勿信表面。”\n“菲利普显然发现了什么，”福尔摩斯喃喃道，“这些液体是硝酸和硫酸——他可能在实验某种金属成分。”\n就在这时，巴克利突然惊叫一声，指着地窖一角。我们转头看去，只见阴影中躺着一具人形物体。我急忙上前，却发现那只是个穿了旧衣的稻草人，手里握着一根断裂的铁棒。\n“有人故意布置这个假象，”福尔摩斯冷笑，“想让我们以为菲利普已死。可这稻草人太新，泥土是今晨才沾上的。华生，我们被监视着。”\n话音未落，头顶传来一声巨响，铜钟猛地摇晃起来，暗门随之关闭。我冲向梯子，却发现石壁无缝可寻。福尔摩斯冷静地环顾四周，目光落在木箱上。他撬开一箱，里面竟是一堆闪亮的金币和几页羊皮纸。\n“黄金伪造案！”他低声道，“这些是假币模具。菲利普无意中撞破了一个犯罪团伙的秘密，他们把他抓走了。”\n接下来的几个小时，我们在地窖中寻找出路。福尔摩斯终于在墙角发现一处松动的石板，推开后露出一条地道。地道尽头通向庄园外的一片树林，我们爬出时已是凌晨，雾气笼罩着一切。远处传来马蹄声，福尔摩斯立刻拉我们躲进灌木丛。\n三名男子骑马经过，其中一人提着灯笼，另一人肩上扛着个麻袋，麻袋里隐约露出挣扎的痕迹。“菲利普！”巴克利低呼。我正要拔枪，福尔摩斯按住我：“时机不对，跟着他们。”\n我们尾随至一座废弃磨坊。磨坊内灯火通明，麻袋被扔在地上，里面果然是菲利普，嘴被堵住，手脚被绑。他脸色苍白，但显然还活着。三名男子中，一个满脸疤痕的高个子冷笑道：“巴克利，这秘密你不该碰。现在你叔叔也来了，正好一网打尽。”\n福尔摩斯低声对我说：“华生，准备好。那疤脸是头目。”他从口袋掏出一枚信号弹，点燃后扔向磨坊外。火光冲天，片刻后，远处传来警笛声——他早已通知了雷斯垂德探长。\n混乱中，我和福尔摩斯冲进磨坊。我击倒一名喽啰，福尔摩斯则用手杖精准地打中疤脸的手腕，匕首落地。雷斯垂德带人赶到，三名罪犯束手就擒。菲利普被解救出来，虽受了惊吓，但并无大碍。\n次日，我们回到贝克街。福尔摩斯坐在扶手椅上，向我和巴克利父子解释了一切。“菲利普在检查铜钟时，发现钟基座藏有伪造金币的模具。这是个老把戏——利用古物掩盖罪行。那个团伙多年来利用庄园的地窖生产假币，销往伦敦。菲利普的失踪是他们为了灭口，而那封信是故意引您下地窖，好一并解决。”\n“可他们怎么知道我们在地窖？”巴克利问道。\n“很简单，”福尔摩斯点燃烟斗，“您的仆人中有内应。我注意到管家昨晚眼神闪烁，手上有煤灰——和信纸上的痕迹一致。他已被雷斯垂德带走。”\n菲利普感激地说：“福尔摩斯先生，若不是您，我恐怕凶多吉少。”\n福尔摩斯摆摆手：“逻辑和观察，菲利普。你的笔记救了你自己。”\n","date":"2025-02-20T18:35:01.137+08:00","image":"https://cdn.jsongo.top/banners/a3cfc9a156da68c50afbe2e6e4824ac4.jpg","permalink":"https://www.jsongo.top/articles/holmes-secret-beneath-the-bronze-bell/","title":"《铜钟下的秘密》福尔摩斯探案 - 续集"},{"content":"那是一个阴郁的秋日清晨，浓雾如厚重的帷幕笼罩着伦敦，贝克街221B的窗户上凝结着细密的水珠。我坐在壁炉旁整理医疗笔记，而我的朋友歇洛克·福尔摩斯则倚在扶手椅上，手指轻轻敲击着烟斗，神情若有所思。自从我们解决了那桩“红宝石失窃案”后，他已经好几天没有接到值得一试的案子，这让他显得有些焦躁。\n就在这时，门铃急促地响起，打破了屋内的沉寂。片刻后，我们的房东哈德森太太敲门进来，身后跟着一位衣着考究却神色慌张的绅士。他大约四十岁，身材瘦削，戴着一顶礼帽，手里紧握着一根乌木手杖。\n“福尔摩斯先生，”他开门见山地说道，“我是詹姆斯·卡特赖特，住在肯辛顿。我需要您的帮助——我相信有人要谋害我！”\n福尔摩斯眼中闪过一丝興味，示意来客坐下。“请详细说说，卡特赖特先生。谋害的证据是什么？”\n卡特赖特深吸一口气，开始叙述：“过去三晚，每当我深夜归家时，总能听到身后传来脚步声。可当我回头去看，那声音便戛然而止，浓雾中什么也看不见。昨晚更离奇，我在书房里发现了一张字条，上面用潦草的笔迹写着：‘今夜是你的末日。’我确信这不是恶作剧——我没有仇人，也没有理由被人威胁！”\n福尔摩斯拿起烟斗，点燃后缓缓吐出一圈烟雾。“有趣。字条带来了吗？”\n卡特赖特从口袋中掏出一张皱巴巴的纸递了过去。福尔摩斯接过，眯眼细看片刻，又递给我。我注意到纸张粗糙，像是从廉价笔记本上撕下的，墨迹有些模糊，显然是用蘸水笔匆忙写成。\n“您从事什么职业？”福尔摩斯问道。\n“我是一家小型航运公司的经理，负责北海的货运调度。生意平稳，没什么特别之处。”\n“您昨晚几点发现这张字条？”\n“大约十点。我从俱乐部回来后直接进了书房，字条就放在我的书桌上。可我发誓，仆人都已睡下，门窗也锁得好好的！”\n福尔摩斯站起身，走到窗边，凝视着外面的雾气。“华生，拿上你的外套。我们得去卡特赖特先生的宅邸看看。”\n一小时后，我们抵达肯辛顿一栋整洁的三层住宅。雾气依然浓重，能见度不足十码。卡特赖特领我们走进书房，这是一间摆满航海书籍和地图的房间，书桌上除了一盏油灯和几份文件外别无他物。福尔摩斯立刻开始检查，先是研究门锁，又蹲下查看地毯。\n“看这里，华生，”他指着书桌旁的一小块泥迹说道，“这泥土是湿的，带有淡淡的海腥味，显然是今晨才留下的。卡特赖特先生，您家里可有谁今早出门？”\n“没有，”卡特赖特困惑地说，“仆人们都在屋里忙活。”\n福尔摩斯微微一笑，转身检查窗户。窗闩完好，但窗台上有一道浅浅的刮痕。“有人用工具撬过这里，但没成功。您的威胁者显然不擅长开锁。”\n接着，他要求查看宅子周围。我们绕到后院，发现一处低矮的围墙，墙头有几处新鲜的磨损痕迹。福尔摩斯蹲下，从墙根的泥土中捡起一小块烧焦的纸片，上面隐约可见“货物清单”几个字。\n“华生，这可不是普通的恐吓，”他低声道，“卡特赖特先生的职业是个关键。”\n当晚，福尔摩斯提议留在卡特赖特家中观察。我们熄了灯，躲在书房窗帘后守候。午夜刚过，雾中果然传来一阵轻微的脚步声，随后是围墙处传来的窸窣声。我握紧了左轮手枪，而福尔摩斯则纹丝不动，目光如鹰。\n突然，一道黑影出现在窗外，手持一根细棒试图撬窗。福尔摩斯猛地拉开窗，喝道：“站住！”那人一惊，转身就跑，但我和福尔摩斯早已扑出，迅速将他按倒在地。\n那是个瘦小的男人，穿着粗布外套，满脸胡茬。他怀里掉出一把匕首和一叠文件。福尔摩斯捡起文件，借着月光扫了一眼，脸上露出满意的笑容。\n次日清晨，我们在贝克街向卡特赖特解释了一切。“您的威胁者名叫汤姆·里德，是您公司的一名仓库工人，”福尔摩斯说道，“他试图恐吓您，好让您辞职。他和一伙走私犯勾结，利用您的航运公司偷运私货。那些脚步声和字条是为了让您精神崩溃，而昨晚，他打算更进一步。”\n“可他怎么进的我的书房？”卡特赖特惊讶道。\n“很简单。他白天混在送货的工人中，趁人不备溜进宅子，留下字条。泥土和纸片暴露了他的身份——他昨晚带着伪造的货物清单，打算栽赃给您。”\n卡特赖特长舒一口气，连声道谢。案件结束后，我看着福尔摩斯点燃烟斗，忍不住问道：“你怎么这么快就猜到是公司内部的人？”\n他笑了笑：“华生，泥土里的海腥味和那张烧焦的纸片告诉我，这与航运有关。而能在浓雾中准确找到这栋房子的人，必然对卡特赖特的习惯了如指掌。逻辑，仅仅是逻辑罢了。”\n","date":"2025-02-20T18:17:09.187+08:00","image":"https://cdn.jsongo.top/banners/102f6705bfb2660ca093692c2d7a6677.jpg","permalink":"https://www.jsongo.top/articles/holmes-shadow-in-the-mist/","title":"《雾中之影》 - 福尔摩斯探案 - 续集"},{"content":"背景 拥有了一间相对安静、专注、有氛围的书房，可以让人把更多的时间投入在学习上，看书也好、在线学习也好，写作等生产性活动也好，总之一个好的氛围可以让人更有欲望和意愿投入到学习或创造上。\n基于这个想法，本文就来聊聊我的思路，怎么逐步打造成一个让我一进入就想学习或创造的环境。\n几个维度 隔离性 首先，空间的隔离至关重要，确保我在工作时不会打扰到正在房间休息的家人。另一边是活动频繁的大厅，孩子们在那里玩耍也不会影响到我在书房开会。这两点决定了书房的实用性。\n基础保障 网络 为了能够高效工作，书房需要配备一些必要的设施。\n首先，网络必须稳定，这里已经布设有线网。\nWiFi 信号也还不错，只隔了一面非承重墙，问题不大。\n书桌 其次，书桌要选择质量好、稳固的，避免晃动影响工作。\n第三，升降桌是必不可少的，可以让我在工作时坐站交替，减轻疲劳。\n绿色 第四，绿色植物能够美化环境，让眼睛得到适当休息，心情愉悦。\n可以选择一些不太香、花粉少的花卉，以及水培的大叶绿色植物。\n阳台上也可以种植一些藤蔓植物，但要注意不要覆盖整个窗户，以免遮挡阳光。\n窗帘 最后，窗帘的选择也很重要，百叶帘和纱帘都是不错的选择，方便收放。关于百叶帘，之前并未对此进行充分考虑和预留。\n纱帘具有一种朦胧的美感，虽然无法直接看到窗外，但营造出一种半封闭的空间感，在疲惫时可以拉起帘子，欣赏窗外的风景，交替变换心情。\n如果阳台上的藤蔓植物能够延伸至此，例如百香果，开花时吸引蜜蜂和蝴蝶，这样的工作环境将非常理想。\n这一设想并非不可实现，未来可以进一步研究。\n照明 灯光方面，房间中央有一个大灯，窗台上装有灯带，整体照明效果良好。不过，角落可能会稍显昏暗，这时就需要台灯来补充照明。\n桌面上应放置一盏台灯，以提升工作舒适度。可以选择长条形台灯，将其置于屏幕上方或高于屏幕的位置，使光线自然向下照射，避免直射眼睛。\n氛围营造 书房的布置也需精心考虑。\n书架上可以摆放一些书籍，对面的柜子可以设置开放格，营造出一种文化氛围。\n同时，配备一张小型懒人沙发，工作疲惫时可以坐在上面阅读，放松身心。\n屏幕尺寸和电脑性能同样重要。需要配备一台==性能优越的电脑==，可能需要动用家庭预算。\n我个人偏好使用 Mac，因此 Windows 服务站可能不太适合。\n桌面上可以摆放一些有趣的挂件、摆件、奖杯、奖牌以及全家福照片，营造出积极的工作氛围，激发工作动力。\n墙面无需张贴海报或激励标语，保持空白反而显得简洁大方。当然，也可以悬挂一些风景图，工作疲惫时抬头欣赏，甚至可以定期更换。\n桌面上可以放置一个计时时钟，可以将家中的现有时钟搬来使用。这款设备具备时间管理功能，虽然目前尚未充分利用，但未来可以深入研究。\n书桌上可以适当摆放一些书籍，占据一小块区域，具体布局需根据屏幕摆放后的剩余空间来调整。完成这些布置后，书房的整体氛围将得到显著提升。\n理想情况下，书桌上可以放置一个小爱同学的小屏幕，这将极大提升使用体验。\n升降桌 关于升降桌的选择，可以考虑两种方案：\n一是使用升降台，但可能不够实用； 二是选择整体可升降的桌子，最佳方案是两侧可独立升降。\n因为与队友工作时，双方的站立和坐下节奏可能不同，独立控制的升降桌更为理想。不过，这需要在物品摆放时考虑两侧的平衡（不能架在中间），这也是需要仔细规划的一个方面。 防打扰 为了避免打扰，可以在门上安装人体感应器，当有人靠近时，桌面上会有相应的提示。或者，简单地放置一面镜子，也能观察到后方的情况。实际上，工作环境和家人之间并没有太多秘密，这个问题并不大。\n其它事情 关于饮用水，从书房到倒水台的距离并不远，整体上非常方便。 全屋的花卉可以每周采购一次，保持新鲜。虽然目前工作量不大，但未来可能需要逐步培养更勤奋的习惯。不过，有时候环境会推动人主动完成事情，所以在这方面不必过于担心。 ","date":"2025-01-12T23:09:45.93+08:00","image":"https://cdn.jsongo.top/banners/cf6f79652cb30bd591d55b7e797cf3b8.jpg","permalink":"https://www.jsongo.top/articles/study-room/","title":"书房的氛围营造"},{"content":"麦理浩径（The MacLehose Trail），是中国香港西贡的一条著名徒步线路。也有叫麦林浩径。\n概述 基本概况：1979 年 10 月 26 日启用，全长 100 公里。以西贡北潭涌为起点，绕过万宜水库，由东向西横贯新界，以屯门为终点，共分为十段 12。 沿途景观 ： 自然风光：麦理浩径横跨香港 24 个郊野公园中的 8 个，沿途要翻越二十多座山头，如 420 米的牛耳石山、702 米的马鞍山、649 米的草山和 957 米的大帽山等。全程风景各异，不论山岭、岸边、丛林、溪涧，全都美丽得叫人叹为观止。其中，第二段的浪茄湾至北潭凹被誉为是体验香港海岸线之美的最佳路线，可欣赏到山海交融的壮丽景色；第八段则能挑战香港最高峰大帽山 124。 人文景观：途径赤径古村等具有历史文化价值的地方，能让人感受到原汁原味的香港文化 。 难度分级 ： 第一段：北潭涌至浪茄，长度 10.6km，主要以柏油马路为主，难度 *，全程无补给。 第二段：浪茄至北潭凹，长度 13.5km，难度 **，在西湾可以买水、吃饭、露营 。 第三段：北潭凹至企岭下，长 10.2km，难度 ***，嶂上有士多和营地 。 第四段：企岭下至大老山，长 12.7km，难度 ***，全程无补给 。 第五段：大老山至大埔公路，长 10.6km，难度 **，狮子亭有士多，可以买水 。 第六段：大埔公路至城门，长 4.6km，难度 *，全程无补给 。 第七段：城门至铅矿坳，长 6.2km，难度 **，全程无补给 。 第八段：铅矿坳至荃锦公路，长 9.7km，难度 **，终点有士多可以补充食物和水 。 第九段：荃锦公路至田夫仔，长 6.3km，难度 *，终点有田夫仔营地以及田夫仔士多，可以补充水以及吃饭 。 第十段：田夫仔至屯门，长 15.6km，难度 *，田夫仔有两三处食店，可吃饭、补充水 。 为啥有名 出名的原因主要有以下几点：\n自然景观壮美 山海相连：麦理浩径横跨香港 24 个郊野公园中的 8 个，沿途要翻越二十多座山头，如 420 米的牛耳石山、702 米的马鞍山、649 米的草山和 957 米的大帽山等。全程风景各异，不论山岭、岸边、丛林、溪涧，全都美丽得叫人叹为观止。其中，第二段的浪茄湾至北潭凹被誉为是体验香港海岸线之美的最佳路线，可欣赏到山海交融的壮丽景色；第八段则能挑战香港最高峰大帽山。 生态多样：徒步旅行者能观察到各种动植物，这里是许多珍稀物种的栖息地，如香港瘰螈、卢文氏树蛙等。丰富多样的生态环境为徒步旅行增添了管理的复杂性与趣味性，也让徒步者能亲近自然、感受大自然的魅力 。 徒步体验绝佳 难度分级合理：麦理浩径共分为十段，长度由 5 至 16 公里不等，大部分约长 10 公里，每段都有不同的难度和特点，能满足不同水平徒步者的需求。既有适合初学者的路段，也有对经验丰富的徒步者具有挑战性的路段，例如第一段北潭涌至浪茄，长度 10.6km，主要以柏油马路为主，难度较低；而第八段铅矿坳至荃锦公路，长 9.7km，需要攀登大帽山，难度较高 。 配套设施完善：每个段落都有设置营地和水源，这在长途徒步中至关重要，避免旅行者因缺水而中途放弃。同时，清晰的标识和健全的交通系统确保了即使是初次尝试者，也能顺畅地完成这次冒险。沿途每 500 米设有一个标志柱，全程共 200 个标志柱，上面清晰标注编号、点位等信息，方便山客拨打电话求助及时定位 。 历史文化意义深厚 以港督命名：麦理浩径是以香港第 25 任港督麦理浩的名字命名，他在任期间推动了香港多项重要改革，包括《野郊公园条例》和麦理浩径的启用 。 见证香港发展：麦理浩径自 1979 年建成以来，改变了香港人探索大自然的方式，让更多人开始走进山野深处，也见证了香港在城市发展过程中对自然保护和户外运动的重视与发展 。 赛事活动丰富 乐施毅行者：1986 年，国际知名发展援助与人道救援机构香港乐施会应邀与驻港英军合办毅行者，并首次向公众开放。该比赛要求四人组队，在 48 小时内走完麦理浩径全程，且全队需完成一定额度的公益筹款。乐施毅行者迅速发展成为香港规模最大的远足筹款活动，吸引了大量香港市民和世界各地的参与者，也提升了麦理浩径的知名度 。 香港 100 越野赛：港百赛道大约有 71% 的线路与麦理浩径线路重合，是国际上最具影响力的赛事之一，吸引了整个东南亚地区选手、乃至众多国际精英在香港的越野赛道上竞技交流，进一步提升了麦理浩径在国际上的影响力 。 ","date":"2025-01-11T01:02:36.076+08:00","image":"https://cdn.jsongo.top/banners/c1e2de3d85f49231f2290e3ec17b3940.jpg","permalink":"https://www.jsongo.top/articles/the-maclehose-trail/","title":"香港麦理浩径"},{"content":"跑力值 跑力有一个衡量指标，叫做 BDOT。查了一下该表，我当前数值大概在 33 左右，表中最低值有不到 30 的，最高值是 50 甚至可能还有更高。\n以 5km 为例，最高 56 的跑力值，只需 18 分钟就能跑完，而我大概需要 28 分钟，差距还是挺大的。从 2019 年记录到的 12 个项目男子世界纪录成绩来看，5km 的最佳成绩，也就是人类的最好成绩大概是 12 分 37 秒，平时可将其视为一个极限值，知道上限的可能性，能给自己一些前进的动力。\n力量训练 5 类力量训练 力量训练可分为 5 大类，\n一是上肢推训练，比如俯卧撑、杠铃卧推等； 二是上肢拉训练，主要有引体向上、划船器械训练等； 三是下肢推动作，像简单的快速站立推动动作； 四是核心训练，很多人跑步时上身晃动幅度大，主要原因是核心不稳，这会浪费很多能量。还有人走路时臀部左右扭动厉害，也是核心力量不足导致的。\n另外，有一个常被误解的观点：腹肌的锻炼效果主要取决于饮食，而非核心练习。\n以前进行力量训练时，教练常说要做到力竭，因为力竭时对肌肉的刺激最大。不仅容易受伤，还易出现精神疲劳。精神疲劳通常表现为反应迟钝、容易误防、注意力不集中等。 注意事项 对于力量训练，其实有几个要点。\n首先，标准不宜过高，每次都要做到力竭，没太必要。这不仅容易受伤，效果也不佳。 其次，如果想提升力量训练效果，将训练次数控制在最佳区间内，会更有效。 最后，比做到最好更重要的是持续进步。不用苛刻地要求自己每次训练都要做到极致，只要比上一阶段有所进步就是成功，不必强迫自己。 跑得更远 更远 - 耐力跑 关于如何跑得更远，这涉及到锻炼方法。比如，可以进行快速冲刺 4 分钟、行走 1 分钟的训练。再逐步拉长时间间隔，例如冲刺 7 分钟、行走 1 分钟。\n耐力跑是一种节奏跑。为了提高耐力，需要提升运动强度，使人体达到更高的乳酸代谢阈值，同时提升身体清除乳酸的能力，达到生成和消耗的平衡。这样，在某个强度的配合下，我们就能坚持更久。\n乳酸代谢 随着活动强度增大、跑步时间增长，乳酸会逐渐增加，心跳也会加速，这是正常现象。因为血液加速流动，会将乳酸代谢掉，并带到肝脏进行处理。人体代谢乳酸的速度提高后，运动能力也会增强。\n不过，乳酸大量堆积会导致肌肉酸痛，从而影响正常运动。当我们进行节奏跑时，乳酸产生的速度大致等于排出的速度，此时跑步最为轻松。正常情况下，运动后 30 分钟到 1 小时，乳酸基本清理完了，而肌肉会有些酸痛，之后酸痛会逐渐消失，然后肌肉会更有力量。所以酸痛并不是因为乳酸堆积导致，而是肌肉使用过多，会慢慢恢复的。\n怎么找到适合自己的节奏 可以先进行测试。你将 1.6 公里分成 4 段，一段比一段快，分别是全速状态下的 40%、50%、60%、70% 的速度跑，最后 100 米再冲刺全速 100%。\n按这种方式测出用了多久，然后按书中的那些表来比对下，找到跑步的每个时段大概的配速。由于表格比较多，这里就不贴了，可以去原书查。\n","date":"2025-01-10T00:59:33.152+08:00","image":"https://cdn.jsongo.top/banners/578c0c31502d45694f84e64e5795be79.jpeg","permalink":"https://www.jsongo.top/articles/run-faster/","title":"《跑步治愈》提升跑步能力"},{"content":"验证\u0026amp;提交 打开 网址检查工具 - Search Console 帮助 站点，在上面点击验证，如果你的网站放在 cloudflare 等比较有名的服务商那，这个验证过程会非常简单，比如我就只需要跳转到 cloudflare 上再点一个按钮即可。它会给你添加一个 TXT 记录，之后就认证成功了：\n进入 Google Search Console 后，可以看到你的网站还没被索引，需要等一天再来看下。\n由于已经验证了这个网站就是你的，之后就可以在这个 Console 上看到每天的搜索数据。\nSitemap 如果你的站点有 sitemap 也尽量提交下。我的站点是用 hugo 实现的，加了 sitemap 插件，所以可以直接提供给它地址。提交后，Google 就会定期地从你的 sitemap 上更新内容。\n","date":"2025-01-10T00:35:01.642+08:00","image":"https://cdn.jsongo.top/banners/614e6ce3faae3eecaea68591b783ca2e.jpeg","permalink":"https://www.jsongo.top/articles/add-google-index/","title":"让 google 索引你的网站"},{"content":"成长\u0026amp;输出 最大化每小时的收获 Important","date":"2025-01-10T00:24:52.374+08:00","image":"https://cdn.jsongo.top/banners/2984e26d335bb7e9c65d0dee3e48d61f.jpg","permalink":"https://www.jsongo.top/articles/meditations-w2-2025/","title":"Daily Meditations - W2 of 2025"},{"content":"概述 从盲目跑步到科学跑步的转变 其实之前我或多或少都会去跑跑步，不过是断断续续的，大概几天跑一次。然而，跑到一定程度后，就很难再有大的突破了，一直也没怎么关注过数据，随性跑。我大概能跑个两三公里，跑得上气不接下气时，就走一会儿，然后接着再跑一段。顶多能跑到 5 公里，这对我来说已经算是极限了。这就是我之前的状态。\n以前跑步时，我不太关注心率。后来，在一位朋友的带动下，我开始留意心率等数据，结果发现我的心率总是比他们高很多。比如，我跑个三四公里，心率就会飙升到 180 以上，而他们只有 150 多，差距十分明显。不过当时，我并没有太把这个数据当回事。后来才知道，180 已经非常极限了，这种状态跑不了太久，而且也是对身体有些伤害，健康的跑步应该是在比较舒适的区间，消耗身上的脂肪和多余的糖分，多进行有氧运动，这能给人带来非常多的好处。这些我以前都不太懂。\n后来，另一位出差来的朋友带着我跑了 10 公里。这过程简直要了我的命，我中途停了好多次，还借口在路边喝水休息。跑到五六公里时，我就感觉快到极限了，后面那段路基本上是连走带跑，全靠他拉着我才坚持往前跑完，最累的时候，我都差点吐了出来。\n这次经历让我意识到，跑步其实大有学问。每个人看似身体状况差不多，但真正跑起来，就能看出水平差异了。我以前也专门进行过肌肉锻炼，做过力量训练，可这对跑步并没有太大帮助。跑步并非肌肉越发达就跑得越远，而是需要科学训练。\n后来，我看了《跑步治愈》这本书，学到了许多科学的理念和方法。按照这些指引，我开始越来越科学地跑步。到现在写这篇文章时，差不多看了快一周了。如今我能在跑完 5 公里后也不怎么喘气，平均心率能控制在 130 - 150，根据身体疲劳程度有所波动。\n从这本书上，我不仅学到了方法，还学到了一些跑步的哲学。跑步能让人越来越健康，其效果可能远超大家的认知。或许我们很多人都把这件事想得过于简单了，实际上，甚至很多疾病都能通过跑步逐步治愈，到了七老八十还能保持坚韧的体质。\n成长","date":"2025-01-07T10:49:18.496+08:00","image":"https://cdn.jsongo.top/banners/4e076eb4ff636b6bf9f74fb25b6536ac.jpg","permalink":"https://www.jsongo.top/articles/start-running/","title":"《跑步治愈》让我爱上跑步"},{"content":"现状概述 我现在大部分笔记都是用 Obsidian 写，免费、安全、自由定制。甚至你看到的这些博客，我也都是用它写的，然后加上一些简单的设置就把内容同步到博客上了。Banner 等都是自动生成的，笔记的排版和格式，它都（通过插件）提到了非常强大的支持。\n历程 我研究了大量笔记，许多听过的都尝试过。实际上，大多数笔记功能相近，互相抄来抄去，很多都是类似 Notion 的交互。区别仅在于谁家的软件做得更出色、更流畅，或者 Bug 更少，更便宜。\n我最初长时间使用印象笔记，但它实在令人难以忍受，Bug 超多，还不认真修复问题。每次都推出一堆新功能，接着诱导用户升级会员，充了钱还得再充，实在让人受不了，亏我还充了 10 年的会员，都不知道它能不能再活这么久。\n后来我试用了很多其他笔记软件，大部分都要收费，而且功能扩展性差，提供什么功能就只能用什么。刚开始还觉得一些功能新鲜，用多了、用久了，一对比就发现并不那么理想，很多宣传都夸大其词。\n用着用着，我又开始担忧笔记内容的安全性。曾听闻一款笔记软件，小道消息称其创始人会随意查看用户笔记，这触及了底线，无法接受。由此我开始关注数据安全，想起以前用过一款软件，名字记不清了，编辑格式是 markdown，数据存在本地，相对安全。以前用这个软件时是通过一些同步软件来同步笔记，但在手机上就无法使用了。\n两年前，一个大佬给我介绍了一款叫 Obsidian 的软件。当时下载试用了一下，感觉…… 有点简洁，很多功能都没有。没太玩明白。最近又读了些介绍这款软件的文章，所以心生好奇，便再次研究起来。那段时间，每晚我都沉浸在探索这款软件中，着实投入了不少时间。然而，随着深入使用，我越发惊叹于它强大的功能，许多设计都精准地契合了我对笔记软件的定义与功能需求。\n此后，我对它的使用愈发频繁。因为它几乎能满足我所有需求，即便有些功能缺失，众多插件也能予以补充，甚至我还能自行定制。后来，我惊喜地发现它还能与博客联动，将笔记转化为博客文章发出去，过程还十分简单。当然这些都得花时间折腾。\n有一天，我赫然发现自己在这款笔记软件上安装的插件竟多达 60 个。这数量着实不少，充分彰显了该笔记软件强大的扩展性，而且多数插件都十分实用，不好用的早已被我卸载。\n我留意到许多文章在介绍这款笔记软件时，都提到深入去使用时会很复杂，得花时间研究。不少人在使用过程中选择放弃，毕竟想要深入挖掘其功能，需要投入大量时间钻研，而大多数人都倾向于拿来即用，不愿花费过多精力折腾。而我就是这种喜欢折腾的人。\n我是在试用了众多笔记软件，却始终未能找到心仪之选后，才邂逅了它。我已经投入了大量时间在各种笔记上了，再投入一个月研究都是值得的。之后我逐步将过往的日记迁移至此，我写了 3 年多的日记全都一点点迁过来了（每天迁一点点）。虽说不是所有的笔记都进行转移，但这些年撰写的日记也基本收集齐全了。\n我之所以如此信赖它，是因为经过一段时间的使用，我切实感受到它既安全又功能强大。 而且扩展性非常强，还能自行定义，这十分符合我作为一个开发者的思维。\n这款笔记软件本身自带的功能本身就颇为丰富，比如有分层式的标签体系，具备目录管理能力。还有它的卖点之一，双向链接和网状关联，该功能可以将各种笔记链接成网，做了个交互和动画效果，能把各种笔记的关系梳理得起来。但我不太喜欢用这个功能，一直觉得它有点鸡肋。我之前看过一篇文章，提到这个功能其实没多少人能真正用的起来。\n我现在主要用的是它的标签体系，其分层逻辑我很习惯，因为之前一直在用 flomo，标签体系几乎一样，所以对我来说只是习惯的平移。另外，这个笔记软件还能与我之前研究过的 cloudflare 上的 CDN 联系起来，图片、视频等都可以传上去。\n其实，我对于笔记软件的使用并非局限于某一款。比如说，除了 Obsidian、flomo，我最常用的还有幕布。它们的用途各不相同，但我用得最多的还是 Obsidian。甚至我工作时很多时候也会用它来规划当天的日程，因为它有一些插件能让日常管理变得较为简单。当然，我主要的日常管理软件还是滴答清单。\n","date":"2025-01-07T01:18:06.881+08:00","image":"https://cdn.jsongo.top/banners/ea9086434bf26f0e29a7f53c30916e06.jpg","permalink":"https://www.jsongo.top/articles/note-using-experience/","title":"聊聊我的笔记软件使用历程"},{"content":"概述 环境 Android 环境上，内置（或拉取）私钥证书后，向服务端请求交换 JWT token，获取 OAuth token。\n场景 企业内部应用集成：在企业级的 Android 应用中，当应用需要与企业内部的多个服务（如企业资源规划系统 ERP、客户关系管理系统 CRM 等）进行深度集成时，可能会内置私钥证书。这些服务通常都有严格的身份验证要求，应用需要通过私钥证书向认证服务器请求交换 JWT（JSON Web Token）令牌，进而获取 OAuth（Open Authorization）令牌来访问受保护的资源。例如，企业内部的移动办公应用，员工需要使用该应用访问企业内部的文档管理系统和工作流系统，应用就会通过这种方式获取访问权限。 金融服务应用：在银行或者金融机构的移动应用中，为了确保用户资金交易等敏感操作的安全性，应用可能会预先安装经过严格安全认证的私钥证书。在用户登录或者进行特定高风险操作（如转账、理财购买等）时，应用通过内置的私钥证书向服务端请求交换 JWT 令牌，然后获取 OAuth 令牌，以此来验证用户身份并且授权后续的操作。这种方式可以确保只有合法的、经过认证的应用才能与服务端进行安全的交互。 代码实现 实现核心逻辑 getJWTToken 这里拿 Coze 的 JWT 接口 来写例子，这个意义可能不大（Coze 的 JWT 私钥不太建议放到 App 中），主要是为了演示接口的调用，让代码可以跑通。\n下面是完整代码（可以直接 copy 运行）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 import kotlinx.datetime.Clock import io.ktor.client.statement.bodyAsText import io.ktor.http.HttpMethod import kotlinx.serialization.json.Json import kotlinx.serialization.json.JsonObject import kotlinx.serialization.json.buildJsonObject import kotlinx.serialization.json.put import kotlinx.serialization.serializer import com.auth0.jwt.JWT import com.auth0.jwt.algorithms.Algorithm import kotlinx.serialization.SerialName import kotlinx.serialization.Serializable import java.security.KeyFactory import java.security.interfaces.RSAPrivateKey import java.security.spec.PKCS8EncodedKeySpec import java.util.Base64 object JWTService { suspend fun getJWTToken( config: JWTTokenConfig, options: RequestOptions? = null ): JWTToken { // Trim private key and validate format val trimmedPrivateKey = config.privateKey.trim() val keyFormat = when { trimmedPrivateKey.contains(\u0026#34;BEGIN RSA PRIVATE KEY\u0026#34;) -\u0026gt; \u0026#34;RSA\u0026#34; trimmedPrivateKey.contains(\u0026#34;BEGIN PRIVATE KEY\u0026#34;) -\u0026gt; \u0026#34;PKCS8\u0026#34; else -\u0026gt; null } if (keyFormat == null) { throw Exception( \u0026#34;Invalid private key format. Expected PEM format (RSA or PKCS8)\u0026#34; ) } // 准备JWT payload val now = Clock.System.now().epochSeconds val jwtPayload = buildJsonObject { put(\u0026#34;iss\u0026#34;, config.appId) put(\u0026#34;aud\u0026#34;, config.aud) put(\u0026#34;iat\u0026#34;, now) put(\u0026#34;exp\u0026#34;, now + 3600) // 1小时 put(\u0026#34;jti\u0026#34;, now.toString(16)) if (config.sessionName != null) { put(\u0026#34;session_name\u0026#34;, config.sessionName) } } // 将JsonObject转换为Map val jwtPayloadMap = jwtPayload.toMap() // 使用JWT provider签名获取token val token = sign( payload = jwtPayloadMap, privateKey = trimmedPrivateKey, algorithm = config.algorithm ?: \u0026#34;RS256\u0026#34;, keyid = config.keyId ) // 交换JWT token获取OAuth token val tokenConfig = buildMap\u0026lt;String, Any\u0026gt; { put(\u0026#34;token\u0026#34;, token) config.baseURL?.let { put(\u0026#34;baseURL\u0026#34;, it) } put(\u0026#34;durationSeconds\u0026#34;, config.durationSeconds ?: 900) config.scope?.let { put(\u0026#34;scope\u0026#34;, it) } } return doGetJWTToken(tokenConfig, options) } private suspend fun doGetJWTToken( config: Map\u0026lt;String, Any\u0026gt;, options: RequestOptions? = null ): JWTToken { val api = APIClient(token = config[\u0026#34;token\u0026#34;] as String, baseURL = config[\u0026#34;baseURL\u0026#34;] as? String) val payload = buildJsonObject { put(\u0026#34;grant_type\u0026#34;, \u0026#34;urn:ietf:params:oauth:grant-type:jwt-bearer\u0026#34;) put(\u0026#34;duration_seconds\u0026#34;, (config[\u0026#34;durationSeconds\u0026#34;] as? Int ?: 900).toInt()) if (config[\u0026#34;scope\u0026#34;] != null) { put(\u0026#34;scope\u0026#34;, config[\u0026#34;scope\u0026#34;].toString()) } } val jsonPayload = Json.encodeToString(JsonObject.serializer(), payload) val response = api.request(HttpMethod.Post, \u0026#34;/api/permission/oauth2/token\u0026#34;, config[\u0026#34;token\u0026#34;] as String, payload, options) return Json.decodeFromString(serializer\u0026lt;JWTToken\u0026gt;(), response.bodyAsText()) } // 对 json 里的内容做下处理，方便未来扩展 private fun JsonObject.toMap(): Map\u0026lt;String, Any\u0026gt; { return entries.associate { (key, element) -\u0026gt; key to when (element) { is kotlinx.serialization.json.JsonPrimitive -\u0026gt; { when { element.isString -\u0026gt; element.content element.content.toLongOrNull() != null -\u0026gt; element.content.toLong() element.content.toDoubleOrNull() != null -\u0026gt; element.content.toDouble() element.content == \u0026#34;true\u0026#34; -\u0026gt; true element.content == \u0026#34;false\u0026#34; -\u0026gt; false else -\u0026gt; element.content } } else -\u0026gt; element.toString() } } } private fun sign( payload: Map\u0026lt;String, Any\u0026gt;, privateKey: String, algorithm: String, keyid: String ): String { val cleanKey = privateKey .replace(\u0026#34;-----BEGIN PRIVATE KEY-----\u0026#34;, \u0026#34;\u0026#34;) .replace(\u0026#34;-----END PRIVATE KEY-----\u0026#34;, \u0026#34;\u0026#34;) .replace(\u0026#34;-----BEGIN RSA PRIVATE KEY-----\u0026#34;, \u0026#34;\u0026#34;) .replace(\u0026#34;-----END RSA PRIVATE KEY-----\u0026#34;, \u0026#34;\u0026#34;) .replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;) .trim() println(\u0026#34;JWT sign - 私钥清理完成\u0026#34;) val keyBytes = Base64.getDecoder().decode(cleanKey) // requires API level 26 println(\u0026#34;JWT sign - 私钥解码完成，${keyBytes}\u0026#34;) val keySpec = PKCS8EncodedKeySpec(keyBytes) val keyFactory = KeyFactory.getInstance(\u0026#34;RSA\u0026#34;) val privateKeyObj = keyFactory.generatePrivate(keySpec) as RSAPrivateKey val alg = Algorithm.RSA256(null, privateKeyObj) println(\u0026#34;JWT sign - 私钥引用创建完成，${alg}\u0026#34;) return JWT.create() .withKeyId(keyid) .apply { payload.forEach { (key, value) -\u0026gt; when (value) { is String -\u0026gt; withClaim(key, value) is Int -\u0026gt; withClaim(key, value) is Long -\u0026gt; withClaim(key, value) is Double -\u0026gt; withClaim(key, value) is Boolean -\u0026gt; withClaim(key, value) } } } .sign(alg) } } @Serializable data class JWTToken( @SerialName(\u0026#34;access_token\u0026#34;) val accessToken: String, @SerialName(\u0026#34;token_type\u0026#34;) val tokenType: String, @SerialName(\u0026#34;expires_in\u0026#34;) val expiresIn: Long ) @Serializable data class JWTTokenConfig( val appId: String, val privateKey: String, val aud: String = \u0026#34;api.coze.com\u0026#34;, // 这里可以换成自己的 AUD val algorithm: String? = \u0026#34;RS256\u0026#34;, val keyId: String, val sessionName: String? = null, val baseURL: String? = null, val durationSeconds: Int? = 900, val scope: String? = null ) TokenManager 让 Token 能复用 另外还可以再实现一个 TokenManager 来做一个单例，管理最终 Token 的获取。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import kotlinx.datetime.Clock object TokenManager { private var _token: String? = null private var tokenExpireTime: Long = 0 suspend fun getTokenAsync(forceRefresh: Boolean = false): String { val now = Clock.System.now().epochSeconds // 如果token不存在或已过期（提前30秒认为过期），重新获取 if (_token == null || now \u0026gt;= tokenExpireTime - 30 || forceRefresh) { val (token, expireIn) = generateToken() _token = token // 根据返回的过期时间设置 tokenExpireTime = now + expireIn } return _token ?: throw IllegalStateException(\u0026#34;Token not available\u0026#34;) } private suspend fun generateToken(): Pair\u0026lt;String, Long\u0026gt; { try { val config = JWTTokenConfig( appId = GetApiConfig.APP_ID, aud = GetApiConfig.AUD, keyId = GetApiConfig.KEY_ID, privateKey = GetApiConfig.PRIVATE_KEY .trimIndent() .lines() .joinToString(\u0026#34;\\n\u0026#34;) .trim() ) val jwtRsp = JWTService.getJWTToken(config) val token = jwtRsp.accessToken if (token.isEmpty()) { throw IllegalStateException(\u0026#34;Received empty access token from server\u0026#34;) } // 返回token和过期时间 return Pair(token, jwtRsp.expiresIn ?: 900L) } catch (e: Exception) { println(\u0026#34;Token generation failed: ${e.message}\u0026#34;) throw IllegalStateException(\u0026#34;Failed to generate token: ${e.message}\u0026#34;, e) } } private object GetApiConfig { const val APP_ID = \u0026#34;xxx\u0026#34; const val AUD = \u0026#34;api.coze.com\u0026#34; const val KEY_ID = \u0026#34;xxx\u0026#34; const val PRIVATE_KEY = \u0026#34;\u0026#34;\u0026#34; -----BEGIN PRIVATE KEY----- xxx -----END PRIVATE KEY----- \u0026#34;\u0026#34;\u0026#34; } } 安全 安全问题分析 把私钥内置到 App 中是有一些安全问题的，这里做些分析。\n私钥证书存储安全风险：如果 Android 设备被恶意攻击者获取了 root 权限，或者应用本身存在安全漏洞（如代码注入、反编译漏洞等），存储在设备上的私钥证书可能会被窃取。一旦私钥证书泄露，攻击者就有可能伪装成合法的应用向服务端请求令牌，从而获取未经授权的访问权限。 传输过程安全风险：在向服务端请求交换令牌的过程中，如果通信没有采用足够的加密措施（如 TLS/SSL 协议未正确配置或者被中间人攻击绕过），那么私钥证书和令牌相关的信息可能会在传输过程中被窃取。例如，攻击者通过在公共 WiFi 环境中进行中间人攻击，拦截并篡改请求和响应信息。 JWT 和 OAuth 令牌滥用风险：即使令牌的获取过程是安全的，但是如果令牌的有效期过长或者没有正确的权限管理机制，被窃取的令牌可能会被滥用。例如，JWT 令牌没有设置合适的过期时间，或者 OAuth 令牌的权限范围没有得到精细的控制，攻击者获取令牌后可能会在有效期内持续访问受保护的资源。 安全建议 安全存储私钥证书：使用 Android 系统提供的安全存储机制，如 KeyStore 系统。它可以将私钥证书存储在一个受硬件保护的区域（如果设备支持），并且通过密码学手段对访问进行限制。同时，对应用进行加固，防止反编译和代码注入等攻击方式。 确保传输安全：在与服务端的通信过程中，强制使用 TLS/SSL 协议，并进行严格的证书验证。可以采用双向认证的方式，即服务端和客户端（Android 应用）互相验证对方的证书，确保通信双方的身份真实可靠。 令牌管理优化：合理设置 JWT 和 OAuth 令牌的有效期，对于高风险操作可以采用短有效期的令牌，并要求用户频繁重新认证。同时，对 OAuth 令牌的权限进行精细的划分，确保每个令牌只能访问其授权范围内的资源。例如，对于只需要读取用户基本信息的操作和需要修改用户密码的操作，分别使用不同权限范围的令牌。 ","date":"2025-01-06T22:21:06.393+08:00","image":"https://cdn.jsongo.top/banners/3f4ffe39bbfde173de3bf6ee638fda5b.jpg","permalink":"https://www.jsongo.top/articles/kotlin-jwt/","title":"用 kotlin 实现 JWT 认证"},{"content":"Azure 的 Functions 是一种 Serverless 基建，不过它提供了多种用法，计费方式和适用的场景也不太一样。\n下文对 Flex Consumption plan、Premium plan、Dedicated plan、Container Apps 和 Consumption plan 这 5 种方式进行下对比。\n直观表格对比 托管方式 缩放方式 容器支持 执行超时 实例数量限制 适用场景 计费方式 Flex Consumption plan 基于每函数事件驱动缩放，部分触发器类型分组共享实例缩放 无 默认 30 分钟，最大无限制 受区域总内存使用限制，每函数应用实例数受内存限制 需快速水平缩放、有虚拟网络需求、按使用量付费且希望减少冷启动 基于函数执行次数、执行时实例内存及预配置实例成本 Premium plan 基于事件驱动自动缩放，有预热工作进程 Linux 默认 30 分钟，最大无限制 Windows 最多 100 个，Linux 部分地区可达 20 - 100 个 函数应用持续或近乎持续运行、需更多实例控制、有事件驱动缩放需求、执行次数多但消费计划费用高、代码执行时间长、需虚拟网络连接或自定义 Linux 镜像 基于所需和预热实例的核心秒数及内存使用 Dedicated plan 支持手动或自动缩放 Linux 默认 30 分钟，最大无限制 一般 10 - 30 个，ASE 中可达 100 个 有现有未充分利用虚拟机、需要完全可预测计费、在同一计划运行多个 Web 和函数应用、需要大计算规模或 ASE 提供的安全网络访问的长运行场景 按 App Service 计划常规费率计费，ASE 有固定月费和按 vCPU 计费 Container Apps 根据应用负载自动调整资源分配 Linux 依具体配置和底层资源决定 根据自动缩放机制调整 适合快速部署和运行容器化应用，特别是微服务架构应用，适合容器应用迁移到云端 基于容器实例数量、运行时间、所占用资源（如 CPU、内存等） Consumption plan 基于事件驱动自动缩放，依传入触发事件数量增减主机实例 无 默认 5 分钟，最大 10 分钟 Windows 最多 200 个，Linux 最多 100 个，每小时 500 个实例缩放限制 适合函数运行时付费、希望自动缩放且无复杂配置需求 函数运行时按执行次数、执行时间和内存使用计费 展开介绍 更全面的总结对比下。\nFlex Consumption plan - 弹性消耗 Azure Functions Flex Consumption plan hosting | Microsoft Learn 缩放方式：基于每函数的事件驱动缩放，除特定触发器外，不同函数触发器类型可在独立实例上缩放，如 HTTP、Blob 存储（Event Grid）、Durable Functions 分别成组共享实例缩放，提供更确定的缩放方式。 资源与限制：无容器支持；支持指定预配置实例减少冷启动；支持虚拟网络；函数执行超时默认 30 分钟，最大无限制；每实例内存等资源限制因配置而异，受区域总内存使用限制；每函数应用实例数受内存限制。 适用场景与计费：适合需要快速水平缩放、有虚拟网络需求、按使用量付费且希望减少冷启动的场景；计费基于函数执行次数、执行时实例内存及预配置实例成本。 Premium plan - 函数高级计划 Azure Functions Premium plan | Microsoft Learn 缩放方式：基于事件驱动自动缩放，使用预热工作进程，根据函数触发事件数量增加主机实例，在空闲后能无延迟运行应用。 资源与限制：支持 Linux 容器；运行在更强大实例上；函数执行超时默认 30 分钟，最大无限制；Windows 最多 100 个实例，Linux 部分地区可达 20 - 100 个实例；提供更多 CPU 和内存选项。 适用场景与计费：适用于函数应用持续或近乎持续运行、需要更多实例控制、在同一计划部署多个应用且有事件驱动缩放需求、执行次数多但消费计划费用高、代码执行时间长、需虚拟网络连接或自定义 Linux 镜像的场景；计费基于所需和预热实例的核心秒数及内存使用。 Dedicated plan - 应用服务 Azure Functions Dedicated hosting | Microsoft Learn 缩放方式：支持手动或自动缩放。 资源与限制：支持 Linux 容器；可在 App Service 计划内以常规费率运行函数；提供完全可预测计费和手动缩放；能访问更大计算规模选项；在 App Service Environment（ASE）中提供完全计算隔离和安全网络访问；内存使用和扩展能力高；函数执行超时默认 30 分钟，最大无限制；实例数一般 10 - 30 个，ASE 中可达 100 个。 适用场景与计费：适合有现有未充分利用虚拟机、需要完全可预测计费、在同一计划运行多个 Web 和函数应用、需要大计算规模或 ASE 提供的安全网络访问的长运行场景；按 App Service 计划常规费率计费，ASE 有固定月费和按 vCPU 计费。 Container Apps - 容器应用环境 Azure Container Apps hosting of Azure Functions | Microsoft Learn 缩放方式：具有自动缩放功能，能够根据应用程序的负载自动调整资源分配，可依据传入请求数量或工作负载增减容器实例数量。 资源与限制：支持 Linux 容器，运行环境可靠，资源限制依配置和定价层而定。 适用场景与计费：适合快速部署和运行容器化应用，特别是微服务架构应用，计费基于容器实例数量、运行时间和占用资源等使用情况。 Consumption plan - (按) 消耗 Azure Functions Consumption plan hosting | Microsoft Learn 缩放方式：基于事件驱动自动缩放，根据传入触发事件数量添加或删除函数主机实例。 资源与限制：无容器支持；是默认的无服务器托管计划；函数执行超时默认 5 分钟，最大 10 分钟；每实例内存等资源有限；Windows 最多 200 个实例，Linux 最多 100 个实例；有每小时 500 个实例的缩放限制。 适用场景与计费：适合函数运行时付费、希望自动缩放且无复杂配置需求的场景；仅在函数运行时按执行次数、执行时间和内存使用计费。 价格 5 种函数托管方式在价格上的差别不小。\nFlex Consumption Plan 它是基于每函数事件驱动缩放的，有些触发器类型还分组共享实例缩放。\n计费就看函数执行次数、执行时实例内存，还有预配置实例的成本。要是你配置的预配置实例少，低流量的时候费用就低；可要是高流量，需要大量实例了，那随着实例增多，费用自然也跟着涨，具体花多少钱，得看实际用了多少实例、多少内存，还有执行次数这些情况。\n不支持自定义容器。\nPremium Plan 它是基于事件驱动自动缩放，还有预热工作进程。计费是根据所需和预热实例的核心秒数以及内存使用情况来的。这个计划适合函数应用持续或者近乎持续运行、执行次数又多的情况。虽说基础费用比 Consumption plan 高些，但要是你的应用使用率高，或者有一些特殊需求，用它反而能把总体成本控制得更好，需要自己做好提前的计划。\n支持自定义容器。\nDedicated Plan 它支持手动或自动缩放，计费是按 App Service 计划常规费率来的，要是在 App Service Environment（ASE）里，还有固定月费和按 vCPU 计费。要是你手头有现有没充分利用的虚拟机，或者需要完全可预测的计费，又或者想在同一个计划里运行多个 Web 和函数应用，选它就挺合适。不过要注意，它前期投入成本相对高些。\nContainer Apps 它是根据容器实例数量、运行时间，还有占用的资源，像 CPU、内存这些来计费的。比如说，你运行一个小型 Linux 容器实例，配置 1 vCPU 和 2GB 内存，跑 1 个小时，费用可能在几美分到几十美分不等，具体得看你在哪个区域，还有那个区域的资源单价是多少。\n支持自定义容器。\nConsumption Plan 这可是个完全无服务器托管的选项，简单来讲，只有函数运行的时候才会产生费用。它是怎么计费的呢？主要看函数的执行数量、执行时间，还有占用的内存。\n举个例子，要是在美国西部区域，有个内存消耗为 512MB 的函数，这个月执行了 3,000,000 次，每次执行就持续 1 秒。咱们来算算账，内存资源消耗费用大概是这样算：\n{（3百万秒 * 512GB/1,024） - 0.4百万GB - 秒} * 0.000016美元/GB - 秒 = 17.6美元\n函数执行次数费用如下：\n（3百万次执行 – 1百万次执行） * 0.20美元 = 0.4美元\n把这两项一加，总费用就是 17.6 美元 + 0.4 美元 = 18 美元。\n不支持自定义容器。\n","date":"2025-01-05T20:51:24.063+08:00","image":"https://cdn.jsongo.top/banners/5d75a43553c8d4b677794dc7b70c2f7e.jpg","permalink":"https://www.jsongo.top/articles/azure-functions-hostings/","title":"Azure Functions 的5种托管方式"},{"content":" 示例中用的是 Kotlin (KMP) 2.x ，Ktor 3.x\n网络请求 基础的请求方法 用 ktor 提供的 HttpClient 来创建一个发请求的 handler，实例化之后，我们包一个通用的 request，定义一个通用的返回类型。\n官方文档中给了不少 示例，相对比较简单，如：\n1 2 3 4 5 6 import io.ktor.client.request.* import io.ktor.client.statement.* val response: HttpResponse = client.request(\u0026#34;https://ktor.io/\u0026#34;) { // Configure request parameters exposed by HttpRequestBuilder } 封装序列化等逻辑 不过这只能做一些相对简单场景的请求处理，如果要做 json 解析或 payload 序列化的话，还得引入 ContentNegotiation 、serializer 等，如果还需要 token 认证的话，还得加 header，下面我们一步步封装一个比较通用的请求类。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 import io.ktor.client.* import io.ktor.client.plugins.contentnegotiation.ContentNegotiation import io.ktor.client.plugins.logging.* import io.ktor.client.request.* import io.ktor.client.request.forms.* import io.ktor.client.statement.* import io.ktor.http.* import io.ktor.serialization.kotlinx.json.* import kotlinx.serialization.json.Json import kotlinx.serialization.json.JsonObject import kotlinx.serialization.serializer const val BASE_URL = \u0026#34;https://api.xxx.com\u0026#34; open class MyHttpClient(private val baseURL: String? = BASE_URL, private val token: String? = null) { val jsonUtil = Json { prettyPrint = true isLenient = true ignoreUnknownKeys = true encodeDefaults = true explicitNulls = false coerceInputValues = true } private val client = HttpClient { install(ContentNegotiation) { json(jsonUtil) } install(Logging) { logger = Logger.DEFAULT level = LogLevel.INFO sanitizeHeader { header -\u0026gt; header == HttpHeaders.Authorization } } } suspend fun request( method: HttpMethod, path: String, token: String? = null, body: Any? = null, options: RequestOptions? = null ): HttpResponse { val queryString = options?.params?.let { params -\u0026gt; if (params.isNotEmpty()) { params.entries.joinToString(\u0026#34;\u0026amp;\u0026#34;) { \u0026#34;${it.key}=${it.value}\u0026#34; } } else \u0026#34;\u0026#34; } ?: \u0026#34;\u0026#34; val fullPath = if (path.contains(\u0026#34;?\u0026#34;)) { \u0026#34;$path\u0026amp;$queryString\u0026#34; } else if (queryString.isNotEmpty()) { \u0026#34;$path?$queryString\u0026#34; } else path val url = (baseURL ?: BASE_URL) + fullPath println(\u0026#34;[HTTP] Request URL: $url\u0026#34;) return try { val response = client.request(url) { this.method = method headers { val actualToken = token ?: this@MyHttpClient.token actualToken?.let { append(HttpHeaders.Authorization, \u0026#34;Bearer ${it}\u0026#34;) } options?.headers?.forEach { (key, value) -\u0026gt; append(key, value) } } if (method != HttpMethod.Get \u0026amp;\u0026amp; body != null) { when (body) { is MultiPartFormDataContent -\u0026gt; { contentType(ContentType.MultiPart.FormData) setBody(body) } is String -\u0026gt; { contentType(ContentType.Text.Plain) setBody(body) } is JsonObject -\u0026gt; { contentType(ContentType.Application.Json) setBody(jsonUtil.encodeToString(JsonObject.serializer(), body)) } else -\u0026gt; { contentType(ContentType.Application.Json) setBody(body) } } } } if (response.status != HttpStatusCode.OK) { println(\u0026#34;[HTTP] Error response: ${response.status} - ${response.bodyAsText()}\u0026#34;) } response } catch (e: Exception) { println(\u0026#34;[HTTP] Request failed: ${e.message}\u0026#34;) throw e } } jsonUtil 用于统一 json 的序列化和反序列化，这是 Kotlin 等语言里比较特殊的地方，不过也挺好用，可以对“序列化”这个操作做统一的设置，ignoreUnknownKeys 设置为 true，来避免 response 里遇到一些不认识的字段时出错。习惯了动态语言的同学可能不觉得这是个问题，但强类型语言，json 的序列化还是挺讲究的。 token 可以在创建类实例的时候传入，也可以在调用具体请求方法的时候传入，灵活些。 RequestOptions 用于带入额外的请求头，因为有些接口可能会有特殊的 header 需求。另外为了方便支持 URL 中有多个参数的场景，也可以让用户传入 params，我们把它拼接到 URL 后面。\n上方的代码里还有很多细节，不一一讲了，可以自己查文档。 进一步封装简洁的方法 接着我们常用的其实还是 post 或 get 等，request 本身的参数还是比较多的。所以在 request 方法下方，再添加下更具体的请求方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 suspend inline fun \u0026lt;reified T\u0026gt; get( path: String, options: RequestOptions? = null ): T { val opts = if (options?.params != null) { RequestOptions( params = options.params + options.params, headers = options.headers ) } else options val response = request(HttpMethod.Get, path, null, options = opts) val responseText = response.bodyAsText() // println(\u0026#34;[HTTP] Raw Response: $responseText\u0026#34;) return jsonUtil.decodeFromString(serializer\u0026lt;T\u0026gt;(), responseText) } suspend inline fun \u0026lt;reified T\u0026gt; post( path: String, payload: Any? = null, options: RequestOptions? = null ): T { println(\u0026#34;[HTTP] Posting to $path with payload $payload\u0026#34;) val response = request(HttpMethod.Post, path, null, payload, options) val responseText = response.bodyAsText() // println(\u0026#34;[HTTP] Raw Response: $responseText\u0026#34;) return jsonUtil.decodeFromString(serializer\u0026lt;T\u0026gt;(), responseText) } suspend inline fun \u0026lt;reified T\u0026gt; put( path: String, payload: Any? = null, options: RequestOptions? = null ): T { println(\u0026#34;[HTTP] Putting to $path with payload $payload\u0026#34;) val response = request(HttpMethod.Put, path, null, payload, options) val responseText = response.bodyAsText() return jsonUtil.decodeFromString(serializer\u0026lt;T\u0026gt;(), responseText) } suspend inline fun \u0026lt;reified T\u0026gt; delete( path: String, payload: Any? = null, options: RequestOptions? = null ): T { println(\u0026#34;[HTTP] Deleting from $path with payload $payload\u0026#34;) val response = request(HttpMethod.Delete, path, null, payload, options) val responseText = response.bodyAsText() return jsonUtil.decodeFromString(serializer\u0026lt;T\u0026gt;(), responseText) } 用泛型来让用户定义想返回什么类型的结果。 用 jsonUtil.decodeFromString 来对结果做反序列化处理。 支持 SSE 在 AI 流行的时代，SSE (Server Sent Event) 成了标配。在前端 JS 等场景中，有 axios 等库做了封装，使用起来很方便，在 Kotlin 里要实现还是得费些工夫。\n实现 幸运的是，Ktor 3.0 在 2024 年底发布的时候，原生支持 SSE 了。\nServer 端：Server-Sent Events | Ktor Documentation Client 端：Server-Sent Events | Ktor Documentation\nKMP Client 端接入现在变得很简单，也不需要什么特殊依赖：\n扩展上文中的代码，添加一个 sse 方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 fun sse( path: String, body: Any? = null, options: RequestOptions? = null ): Flow\u0026lt;ServerSentEvent\u0026gt; = flow { println(\u0026#34;[HTTP] SSE posting to $path with payload $body\u0026#34;) client.sse(baseURL + path, { method = HttpMethod.Post token?.let { header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer $it\u0026#34;) } header(\u0026#34;Accept\u0026#34;, \u0026#34;text/event-stream\u0026#34;) header(\u0026#34;Cache-Control\u0026#34;, \u0026#34;no-cache\u0026#34;) header(\u0026#34;Connection\u0026#34;, \u0026#34;keep-alive\u0026#34;) options?.headers?.forEach { (key, value) -\u0026gt; header(key, value) } contentType(ContentType.Application.Json) body?.let { setBody(it) } }) { var shouldContinue = true var eventCount = 0 val maxEvents = 500 // 最大事件数限制 while (shouldContinue \u0026amp;\u0026amp; eventCount \u0026lt; maxEvents) { try { incoming.collect { event -\u0026gt; if (!isActive) { println(\u0026#34;[HTTP] SSE connection is no longer active\u0026#34;) shouldContinue = false return@collect } eventCount++ println(\u0026#34;[HTTP] SSE event ($eventCount/$maxEvents): $event\u0026#34;) val eventType = event.event?.let { EventType.fromValue(it) } // 如果 event.event 是 EventType.ERROR，则打印 msg 然后结束 if (eventType == EventType.ERROR) { shouldContinue = false return@collect } emit(event) if (eventType == EventType.DONE || eventType == EventType.WORKFLOW_DONE) { shouldContinue = false return@collect } } } catch (e: Exception) { println(\u0026#34;[HTTP] SSE connection error: ${e.message}\u0026#34;) shouldContinue = false throw e } } if (eventCount \u0026gt;= maxEvents) { println(\u0026#34;[HTTP] SSE reached maximum event limit ($maxEvents)\u0026#34;) throw Exception(\u0026#34;SSE reached maximum event limit\u0026#34;) } } } 这里要多引入几个包：\n1 2 3 4 5 import io.ktor.client.plugins.sse.sse import io.ktor.sse.ServerSentEvent import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flow import kotlinx.coroutines.isActive 这个实现看起来有点复杂。几个关键点：\nclient.sse 是官方提供的、做 SSE 请求的方法，直接就可以使用。 header(\u0026quot;Accept\u0026quot;, \u0026quot;text/event-stream\u0026quot;) 添加一个 Accept header 指定为 text/event-stream。 maxEvents 设置一个最大的事件数，以免 while 在边缘的情况下进入无限的死循环。 shouldContinue 用于控制 while 是否继续，逻辑里当发现结束标志的时候，把 shouldContinue 设置成 false。 Flow，下面专门讲解。 Kotlin Flow What\u0026rsquo;s Flow 这是属于语言基础的问题，不过多展开。简单说就是在 Kotlin 中，Flow 是一种用于处理异步数据流的类型安全的 API。它可以用于处理像网络请求返回的数据、数据库查询结果等一系列按顺序产生的数据。Flow 是 \u0026ldquo;冷流\u0026quot;（Cold Stream），这意味着它只有在被收集（collect）的时候才会开始执行。\nSSE 的场景不正好就是“按顺序生成数据”嘛，所以自然就跟 Flow 结合了。在 JS、Python 里可能会自然的联想到 generator（yield），写起来很简单，如 JS 里用 for await 来消费就行。\nIncoming 代码中的 incoming 是 client.sse 引入的、表示 SSE 事件流数据的一个内置变量，它本身就是一个 Flow，直接拿来用即可。这是源码中的定义：\n1 2 3 4 5 6 7 8 9 /** * A Server-sent events session. */ public interface SSESession : CoroutineScope { /** * An incoming server-sent events flow. */ public val incoming: Flow\u0026lt;ServerSentEvent\u0026gt; } incoming 怎么来的： client.sse 是由 serverSentEvents 方法生成的，它返回一个 ClientSSESession，而 ClientSSESession 继承了 SSESession，所以 incoming 一直传到了 client.sse 的 scope 里。\n当调用 incoming.collect 时，它会触发这个 Flow 开始工作，并且会将 Flow 发射出的每个数据项传递给 collect 函数内部定义的操作进行处理。Collect 参数是一个 lambda 表达式，参数就是一个 ServerSentEvent，定义如下图，遵守 SSE 的数据流协议，比较标准，没什么好说的。\nEventType 是我们自己定义的，根据业务来定制的，开发者可以自己命令（跟服务端接口对齐好就行），大概的定义可以参考这个实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Event types for all events (chat, workflow, etc.) */ @Serializable enum class EventType(val value: String) { // Chat events CONVERSATION_CHAT_CREATED(\u0026#34;conversation.chat.created\u0026#34;), CONVERSATION_CHAT_IN_PROGRESS(\u0026#34;conversation.chat.in_progress\u0026#34;), CONVERSATION_CHAT_COMPLETED(\u0026#34;conversation.chat.completed\u0026#34;), CONVERSATION_CHAT_FAILED(\u0026#34;conversation.chat.failed\u0026#34;), // Common events DONE(\u0026#34;done\u0026#34;), ERROR(\u0026#34;error\u0026#34;), companion object { fun fromValue(value: String): EventType? { return entries.find { it.value == value } } } } 其中 DONE 表示这个流已经结束了，字符串“done”是后端定的，换成其它标识也行，但不管怎么说得有这么一个结束标识，要不然就会一直卡在那等。\n协程 Flow 的 collect 函数本身其实不是用于启动协程的。\n它是一个挂起函数，有点类似其它语言中的 yield。挂起就意味着它必须在协程的上下文中被调用（要不然主线程就被阻塞了）。\n协程是一种轻量级的线程，可以暂停和恢复，用于处理异步操作。运行一个协程有几种方式，介绍两种：\n1、runBlocking\n我们可以在 runBlocking 协程构建器的上下文中可以调用 collect。runBlocking 是一个顶层协程启动器，它会阻塞当前线程，直到其内部的协程（包括调用 collect 的操作）完成，所以使用时，我们可以用它来包一下，让 Flow 在里面被消费。 不过 runBlocking 是一个顶层协程启动器，会阻塞当前线程，直到其内部的协程（包括所有子协程）执行完成。这意味着在 runBlocking 内部的代码执行完之前，外部的代码（如果有的话）是无法继续执行的。 示例： 1 2 3 4 5 6 7 8 fun main() { println(\u0026#34;Before runBlocking\u0026#34;) runBlocking { delay(1000) println(\u0026#34;Inside runBlocking\u0026#34;) } println(\u0026#34;After runBlocking\u0026#34;) } Before runBlocking 会先打印，然后 runBlocking 内部的协程开始执行，由于 delay 操作暂停了协程 1 秒钟，在这期间当前线程被阻塞。当协程内部的代码执行完后，才会打印 After runBlocking 2、 CoroutineScope\nCoroutineScope 本身并不阻塞线程。它主要是用于定义协程的作用域，确定了协程的生命周期和上下文。协程在 CoroutineScope 内启动后，CoroutineScope 可以继续执行其他操作，不会等待协程完成。 改下上面的例子： 1 2 3 4 5 6 7 8 9 fun main() = runBlocking { println(\u0026#34;Before CoroutineScope\u0026#34;) val scope = CoroutineScope(Dispatchers.Default) scope.launch { delay(1000) println(\u0026#34;Inside launched coroutine\u0026#34;) } println(\u0026#34;After CoroutineScope\u0026#34;) } 这次 Before CoroutineScope 和 After CoroutineScope 会先打印，然后才是 Inside launched coroutine。\ncollect 的一些特点和注意事项\n顺序处理：collect 会按照 Flow 发射数据的顺序来处理数据。如果 Flow 发射的数据有先后顺序，collect 也会按照这个顺序依次处理每个数据项。 挂起函数：collect 是一个挂起函数，这意味着它要在协程（Coroutine）内部被调用，并且可以暂停协程的执行，直到 Flow 有新的数据需要处理或者 Flow 完成。而 runBlocking 是一个用于在主函数中启动协程的函数，它会阻塞当前线程，直到所有协程完成。 异常处理：如果 Flow 在发射数据过程中出现异常，collect 函数可以通过合适的异常处理机制来捕获和处理这些异常。例如，可以在 collect 函数内部使用 try - catch 块来处理可能出现的异常。 使用 SSE 使用上肯定是直接用 collect 只不过如果要不阻塞当前的主线程，可以用上文介绍的 CoroutineScope。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import kotlinx.coroutines.* import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.collect suspend fun startEventFlowProcessing(apiUrl: String, payload: Any, options: RequestOptions? = null) { val eventFlow = client.sse(apiUrl, payload, options?: RequestOptions()) // 使用 launch 开启一个新的协程来执行收集操作 CoroutineScope(Dispatchers.Default).launch { eventFlow.collect { event -\u0026gt; val chatData = sseEvent2ChatData(event) emit(chatData) // If event is \u0026#34;[DONE]\u0026#34;, end if (chatData.event == EventType.DONE) { println(\u0026#34;SSE DONE.\u0026#34;) return@collect } } } } 要阻塞，就换成 runBlocking。这里就不再补充代码示例了。\n","date":"2025-01-05T16:24:30.751+08:00","image":"https://cdn.jsongo.top/banners/c1e2de3d85f49231f2290e3ec17b3940.jpg","permalink":"https://www.jsongo.top/articles/kmp-http-sse/","title":"网络请求 - 用 Kotlin(KMP) 做跨端原生开发"},{"content":"Azure Function 默认是跑在它官方的 microsoft/azure-functions-base 这个镜像上。当然你可以定义自己的镜像，Azure 开放了这个能力。本文主要介绍如何操作。\n创建自己的镜像 创建 Dockerfile 1 func init --docker 它会初始化一个 Dockerfile 等文件，如果你只需要 Dockerfile 可以把参数改成 --docker-only。\n生成的 Dockerfile 里面有如下基础的配置：\n1 2 3 4 5 6 7 8 9 10 11 # To enable ssh \u0026amp; remote debugging on app service change the base image to the one below # FROM mcr.microsoft.com/azure-functions/python:4-python3.12-appservice FROM mcr.microsoft.com/azure-functions/python:4-python3.12 ENV AzureWebJobsScriptRoot=/home/site/wwwroot \\ AzureFunctionsJobHost__Logging__Console__IsEnabled=true COPY requirements.txt / RUN pip install -r /requirements.txt COPY . /home/site/wwwroot 这些不要改动。不过可以在上面添加你自己的东西，比如我在做视频相关的处理，所以我需要一个 ffmpeg 库安装上去，所以我添加了如下的代码：\n1 2 3 4 5 # 安装 ffmpeg RUN apt-get update \u0026amp;\u0026amp; \\ apt-get install -y ffmpeg \u0026amp;\u0026amp; \\ apt-get clean \u0026amp;\u0026amp; \\ rm -rf /var/lib/apt/lists/* 注册 在 Azure Container Registry（容器注册表）这里注册一个你自己的命令空间。\n创建完你就有一个自己的专属 Azure 镜像的域，如我这里的是 jsongo.azurecr.io。\n在 CLI 中登录：\n1 az acr login --name jsongo 如果你的 az 命令之前登录过，这里直接就成功了。记住后面再遇到 docker 操作提示登录的问题，直接运行上面这个命令即可。\n接下去你就可以构建镜像，并把它推到你的这个域上了。\n构建 首先你本地得有一个 Docker 软件安装并运行起来，可以到 Docker 官网上去下载，这个比较简单。当然如果你有一个线上的虚拟机，那就直接在上面处理也行，只不过还得在上面安装 azure 的 CLI。上一篇已经介绍过了、不再赘述。\n接下去在本地构建上面创建的镜像。\n1 docker build --tag jsongo/azure-video:0.1.0 . 如下示例。\n比如我这个镜像，由于加了 ffmpeg 之后，构建完成时整个镜像很大，一下子撑到了 2G。\n构建完，试着把它运行起来看看：\n1 docker run --rm -e WEBSITES_INCLUDE_CLOUD_CERTS=true -p 8080:80 --name test-azure-video -it jsongo.azurecr.io/azure-video 当然你的 auth level 要设置成 anonymous authorization 才可以直接访问，如果没问题它能正常跑起来。接下去在本地 curl 一下 8080 端口就可以看到有没有正确返回。\n用 Azure CLI 更新镜像 Azure 也提供了相应的指令用于更新你的镜像。\n1 az acr build --registry jsongo --image jsongo.azurecr.io/azure-video:0.2.0 . 这里我们构建一个 0.2.0 版本，它同时会把新构建完的镜像 push 到 Registry 里。\n推到 Azure 平台上 先打个 tag，刚构建时，默认是用的 dockerhub 的。\n1 docker tag jsongo/azure-video:0.1.0 jsongo.azurecr.io/azure-video:0.1.0 其中 jsongo.azurecr.io 就是我们上面创建的域，它标识了一个 Docker Registry 的地址（默认是 docker.io）。\n接下去运行 docker push 的时候，就可以找到 azure 的 Registry。\n1 docker push jsongo.azurecr.io/azure-video:0.1.0 然后就是等了。我这个镜像 2G+，着实是要等好一会儿。\nPush 完，打开你的 容器注册表页面，在这里就可以看到你刚推送上去的镜像了。\n使用镜像 下面介绍两种使用镜像的方式，分别对应下图中的两个红框。\n创建函数应用 创建一个 Function 如果要使用自己的镜像，“弹性消耗”是不支持的。要选“高级计划”或“应用服务”才行。\n一步步往下直到创建完成。\n接下去就可以打开 azure 函数首页，去看刚部署的函数。\n至于哪些计划可以支持自定义容器部署可以参考这里：Azure Functions scale and hosting | Microsoft Learn。\n创建函数容器环境（Container Apps） 其实如果要更好的跟 Azure Function 结合的话，可以试下“容器应用环境”(Azure Container Apps environment)，它可以用于你已经在跑的函数中。\n同样我们也在首页创建一个，在“基本”（basics）中填写一些基础信息，这里不再赘述，比较简单。\n接着到“部署”选项卡中，设置你刚 push 上去的镜像。先把“使用快速入门图像”勾选去掉，另外映像类型选专用的（Private），如图一样填写你的镜像信息。 费用是按需支付的，跟之前的两种方式不太一样：\n而且单个机子的配置选项也足够灵活，如图。\n应用开发和部署 如果使用了第一种方式创建了函数应用，它的部署方式就有所变化。之前在 [[azure serverless]] 里做过一些简单的介绍，当时提到发布方式比较简单，即 func azure functionapp publish xxx 就行。\n不过现在我们是把代码打包到容器里，所以没法再使用这种方式去部署。现在需要改成 azure CLI 提供的 build 命令，其实在上文中提过了，只不过要稍加修改。\n1 az acr build --registry jsongo --image jsongo.azurecr.io/azure-video:latest . 它推到远程去构建，并也 push 到远程 acr。\n多次使用下来，其实我发现直接使用 docker 命令在本地构建会快很多，因为有缓存，所以我把面上的命令改成了：\n1 2 docker build -t jsongo.azurecr.io/azure-video:latest . docker push jsongo.azurecr.io/azure-video:latest 构建完成后，接下来，我们再运行下之前的更新命令即可：\n1 func azure functionapp publish video-handler 其它 关于 Premium Plan 和 Dedicated Plan 这些 Plan 其实都涉及到了多种服务和资源，根据不同情况来选择。\nPremium Plan 计算资源：通常指高性能的虚拟机或计算实例等。以虚拟机为例，不同规格的虚拟机收费不同，一般每小时的费用在 0.5 美元到几美元不等，如 DS 系列虚拟机可能比普通系列的虚拟机费用要高，高性能的虚拟机每小时费用可能要 0.834 美元甚至更高。 存储资源：如果是 Premium Storage，收费标准通常按磁盘的最大容量阶梯收费，而不是用多少算多少，且其读写操作也可能会有额外的收费，如每 10 万个存储事务为 3 元，不过每月一般会提供 100 亿次免费的事务 13。 网络资源：对于使用流量较大的公网 IP，每月费用可能在 1.2 美元及以上，负载均衡器每小时也会有一定的费用，如标准负载均衡器每小时的费用是 0.016 美元左右。 Dedicated Plan 计算资源：如 Dedicated Host，一般会根据主机的配置和租用时长收费，一台配置中等的 Dedicated Host 每月费用可能在 1000 美元到 3000 美元左右。 存储资源：若使用专用的存储设备或特定的存储方案，收费也会因存储容量、性能要求等因素而异，通常专用存储的费用相对较高，每 GB 每月的费用可能在 0.2 美元到 0.5 美元之间，具体取决于存储类型和性能等级。 网络资源：如果需要专用的网络设备或带宽保证，费用也会相应增加，专用网络带宽每 Mbps 每月的费用可能在 10 美元到 50 美元左右。 选择 可以根据需求来选择：\n如果对计算性能要求极高，但对资源的独占性要求不是特别高，Premium plan 可能更合适，因为它可以提供高性能的计算资源，同时成本相对较低。 如果对安全性、合规性以及资源的独占性有严格要求，需要完全隔离的计算和存储环境，那么 Dedicated plan 可能是更好的选择，尽管费用相对较高，但能满足特定的业务需求。\n实在不好选择，直接就选 Premium plan，比较经济些，一般也用不到比较太高级的配置。它目前有以下三个配置可以选：\n不过价格上… 是有点高些，具体可以看这里：定价 - Functions | Microsoft Azure。\n小时视角：\n月视角：\n补：后来在函数的设置里，看到了比较实际的价格。\n这个看起来比较切合实际，1 小时不到 2 块。 参考 Working with Azure Functions in containers | Microsoft Learn Create Azure Functions in a local Linux container | Microsoft Learn Azure Container Registry roles and permissions - Azure Container Registry | Microsoft Learn 使用自定义云容器在 Azure Functions 中增强云安全性 ","date":"2025-01-05T11:25:49.289+08:00","image":"https://cdn.jsongo.top/banners/772c64fbb07e3cd46573602f922a7829.jpg","permalink":"https://www.jsongo.top/articles/azure-function-custom-containers/","title":"azure Function 自定义镜像"},{"content":"Kotlin 是由 JetBrains 开发的编程语言，Google 将其作为 Android 应用开发的首选语言，并且它通过相关跨平台框架（如 Kotlin Multiplatform Platform - KMP）发展出了跨端开发的能力。\n示例中用的是 Kotlin (KMP) 2.x ，Ktor 3.x\n概述 跨端 用 KMP 来做跨端的好处是，它能静态编译成原生的 Android、iOS 代码，如果单独作为工程使用，性能上原生会更好；如果是作为组件供原生开发的客户端使用，也能共享代码逻辑。\n代码共享优势：Kotlin 在跨端开发中，主要优势在于能够共享业务逻辑代码。例如，在开发一个同时有 Android 和 iOS 版本的应用时，应用中关于数据处理（如数据加密、数据验证等）、网络请求（如 API 调用、数据解析）等业务逻辑部分的 Kotlin 代码可以在两个平台间共享，这大大减少了开发工作量。 支持多平台类型：除了 Android 和 iOS，Kotlin 还可以用于后端开发（如使用 Kotlin 与 Spring Boot 结合开发服务器端应用），这样就有可能构建从后端到移动端完整的跨平台应用生态系统。 原理 在 KMM 框架里，Kotlin 代码会被编译为不同平台的目标代码。\n对于 Android，Kotlin 代码可以直接编译为字节码在 Android 设备上运行（就像它在传统 Android 开发中的方式一样）。 对于 iOS，Kotlin 代码通过中间表示（Intermediate Representation，IR）与 iOS 原生开发环境进行交互。这个中间表示是一种抽象的代码形式，它可以与 iOS 的 Swift 或 Objective-C 代码进行互操作。\n除了 Android，本质上，Kolit 是通过编译成能与其它语言互操作的中间代码来实现的。它跟 Flutter 类的框架有比较明显的区别，Flutter 最终是通过 Dart 虚拟机来抹平底层的差异，而 KMP 则是顺应各端的语言环境，编译成它们更友好的中间语言来做集成。\n为了更好的理解，我再进一步讲下：在 iOS 应用中使用 KMP（借助 Kotlin/Native）开发的场景中，Kotlin 代码会被编译为机器码，这个过程是通过 Kotlin/Native 编译器完成的。编译后的代码会生成一个类似 XCFramework 的库文件，它可以被链接到 iOS 应用中。这个库文件在 iOS 应用运行时并没有一个像 Flutter 那样的单独的 “runtime” 概念。所以性能上会比 Flutter 类的框架好很多。\n从性能上看，由于 Kotlin/Native 编译后的代码直接与 iOS 原生代码集成，性能方面基本就是原生代码的性能。没有额外的运行时解释层，使得代码执行效率较高。\n在资源占用方面，因为不需要加载一个单独的运行时环境，相对来说对设备资源（如内存、CPU 等）的占用会少些。 更多资料 官网提供了比较详细的指引，可以参考这里： Create your first cross-platform app | Kotlin Multiplatform Development Documentation。\n本文简单地介绍它在跨端开发上体验。\n背景：尝试 KMP 框架，主要是因为在做一个 SDK 的客户端版本时，需要开发 iOS 和 Android 版本，大概看了下当前的趋势和性能、认可度等方面，综合判断选择了这个框架。\n跑起第一个 KMP 应用 官方指定用 Android Studio，可以从这里 下载 Android Studio 和应用工具 。默认是内置了 Gradle 来做编译，包含跨端的代码编译。\n生成项目及初始代码介绍 官方给了一个工具用于生成初始化的项目代码：https://kmp.jetbrains.com/，在这上面配置下应用相关的信息即可。一般只需要 Android 和 iOS 两个端即可：\n下载到本地，然后用 Android Studio 导入。\n代码主要包含 3 个部分：\nShared，共享的部分。它是跨端的逻辑代码存放的地方，主要有 androidMain 、commonMain 和 iosMain，最终编译成 Android Library 和 iOS framework 供两端集成。\nComposeApp，是一个完整的 Kotlin 模块，它可以通过 Gradle 直接编译成 Android 应用，它里面也包含了 Shared module，Android 应用编译时可以引用这部分共用的模块。 IosApp，则是一个 Xcode 项目，用于编译成 iOS 应用。 写一个 Shared module（CommonMain） 依赖是写 KMP 应用会遇到的第一个比较麻烦的问题，不过大都能从 这个文档 中找到，可能需要点耐心。\n写到 CommonMain/ 目录里的代码，如果包含了平台专有的 API，IDE 会给 Warning 提醒，交互比较友好。\n把 import 部分改成 kotlin.random.Random 就没报错了（Random 类写法去掉括号）。\n接下去点击图中 Top bar 里的运行按钮就可以跑起来了，它会出现 Android 一虚拟机，在上面运行你的代码。\n自定义 跑通了基础的流程，我们接下去的工作就简单了，创建一个 kt 文件，写好逻辑即可。\n比如我想写一个通用的 HTTP 请求的模块，需要先安装一些依赖，具体可以参考 这里。打开 composeApp/build.gradle.kts，添加下几个依赖：\n依赖分析 1、plugins\n1 2 3 4 5 6 7 8 plugins { alias(libs.plugins.kotlinMultiplatform) alias(libs.plugins.androidApplication) alias(libs.plugins.composeMultiplatform) alias(libs.plugins.composeCompiler) // my plugins kotlin(\u0026#34;plugin.serialization\u0026#34;) version \u0026#34;2.0.0\u0026#34; } 安装完之后，点击 Sync Now，让它安装依赖。\n怎么处理不同环境的差异，可以参考这里：# Manage Project Environment in Kotlin Multiplatform Mobile\nIOS 要跑在 iOS 上还需要一些跨端的配置。\nKotlin 共用模块编译 我们在 composeApp 里面写了不少跨端用的代码，在 iosApp/ 这个目录下是没有相关东西的，需要有一个编译的过程，把这些代码编译成 Xcode 能识别并处理的 iOS 代码（swift）。\n有两种方法来配置编译脚本，具体可以参考这里：Make your Android application work on iOS ，下面简单讲解下：\n1、一是手动\n双击项目名，然后进入 Build Phases Tab，点加号，添加一个 Run Script，添加： 1 2 cd \u0026#34;$SRCROOT/..\u0026#34; ./gradlew :composeApp:embedAndSignAppleFrameworkForXcode 然后把顺序拖到上面这里：\n不过，JDK 11 从 11.0.3 开始商用收费，如果在内部业务使用也要购买许可证：\n所以还是得用 OpenJDK，我试了下，是兼容的。安装可以看这里：[[JDK 怎么安装]]。 另外也要设置下 sandboxing\n2、用插件\n安装完之后，其它就自动帮你设置了一个 Build Script 在上文提到的 Build Phases 里：\n这里选择的那两行是我加的，因为运行时它找不到 JDK，如果你也遇到这个问题也可以这么解决。\n配置好后，可以点击 Xcode 右上角的编译按钮触发一次编译，我第一次试，编译了近 2 分钟：\n使用公共模块 很简单，把 ComposeApp 引入就行，这样里面我们写的方法就都可以用了。\n参考 Share more logic between iOS and Android | Kotlin Multiplatform Development Documentation ","date":"2024-12-27T11:31:09.698+08:00","image":"https://cdn.jsongo.top/banners/24372eee204cc869cbb56c86a09a6b4c.png","permalink":"https://www.jsongo.top/articles/kmp-101/","title":"入门 - 用 Kotlin(KMP) 做跨端原生开发"},{"content":" 这两周都在看吴军的新书《脉络》，从书中我读出他有点凯文凯利的一面。一些比较大的命题，他能举重若轻地用一两句简单的总结，表达出一些一针见血的见解。让人感悟深刻。\n整个社会的视角 也有点经济学的思维\n时不时的去放弃一些东西 只保留生活必需品。\n其实，对大多数人来讲，很多东西并没有太大的存在必要，却对别人很重要。适当的舍弃或捐献或许能提升社会资源的利用率和价值。\n买的东西也不一定要选择退货，也可以把它捐掉，一方面商家可能拿到后也是扔掉，反而是对资源的浪费，自己还蒙受了损失；另一方面，这能反向地约束自己，敦促自己买东西前要三思、想清楚真正需要再下手。\n对我来说，家里有很多书，也有很多很久没用的东西，这些其实占了我满大空间，但如果我把它们捐掉或送给有需要的人，我甚至都不需要那么大的空间来存放，给自己腾出一些地方来。\n人们对社会的贡献，可能是正数、也可能是负数 我们如果以贡献最终值来衡量的话（正 + 负），那些名人的贡献不一定比我们多，因为他们除了做了很多有用的事之外，也做了很多影响很大的坏事，这些使得他们的贡献总量可能为负。\n比如，几年前中国的共享单车在竞争这个市场的时候，完全是在浪费社会资源，如果只有那么一两家在相互竞争、相互促进，不断的强大和发展，为社会众人解决最后 1 公里的交通问题，那是没啥问题的，但是百来家这真的有点浪费社会资源，还搞得到处被自行车堵得乱糟糟的。\n这个世界缺少长期主义者 人类在生理上天生就有一个缺陷，就是喜欢即时反馈和鼓励，不太喜欢等待。\n要解决社会上任何需要时间的问题，靠得住的其实不是某个政治家或领导，而是能够盈利的商业，只有在有利可图时，人们才有动力去做，如果能适当的引导让大家往好的方向去竞争，问题解决的效率会是最高。\n吴军说，正是因为很多人迷信所谓的“历史巨变”、“人生转折”，才把原来非常广阔的道路留给了极少数长期主义者。\n共识 教育的作用 较好的教育，除了简单的在知识上、逻辑上能够有所增进之外，还要学会如何更好的运用知识。\n更重要的是教育能够教会人学习，它搭建起了我们和人类思想之间的桥梁的，我们学会了更多的去思考如何高效地获取更多、更好的知识，以及如何把知识更好的变成生产力，去丰富生活，以及为社会做贡献。\n以前我们会以为离开的学校就解放了，不用再学习了，但其实那只是一个开始。\n在学校只是学到了基础和方法论，上了社会就要不断的完善和充实自己，没法躺平，共同富裕也不是让你躺平，因为人总要挣钱、生活，躺平了就等着饿死。这个社会在飞速的发展，如果没有很好的学习能力，很难在未来活的很好。现在的努力，更多地是在为未来做储备，而不只是去解决现在的问题，要不然就跟有了这顿、没有下顿的古代平民没太大区别。\n有些财富建立在共识之上 比如“房价还会继续涨”，这个共识让房价一直保持着高价。\n在中国，这个观念是几千来农耕/封建历史养成的，形成了人们的“家”的观念，大家共同的信仰。不过这个事也不是完全牢不可破的，万一某一代人因为巨大的压力不敢再持有这种信仰的时候，房价就会慢慢的下滑。\n比特币经常大波动，特别是乱世的时候疯狂地涨或跌，是因为一直有些人持有“无国界”货币的观念，而且人也不少，他们形成了种共识，共同推动着虚拟币的涨跌。而更多参与的人，是在陪玩，他们没有坚定的信念，经常就是眼馋或想着快速致富，跟投资房地产没有本质上的不同。\n回到这本书 脉络这本书前面的章节主要就是在讲过去的历史，很多跟我们认知都不太一样。过去没有我们想象的那么美好，而且我们经常会去美化历史，但实际上过去的盛世真正只占历史的 1/3 都不到，大部分时候都是兵荒马乱。\n最开始的章节也讲到，现代人的生活水平其实大部分都是工业革命之后才飞速发展起来的。那么长的农耕时代，其实并没有对现代生活贡献多少，社会的整体生产力一直没有得到什么发展，而工业革命给整个人类社会带来了非常迅猛的技术和财富的增长。\n之后比较长的篇幅在讲工业革命及之后的一些观点，很有意思。看到上面这些介绍，相信有的人会开始对这本书有所兴趣，总之它让我看到了凯文凯利的影子，这或许也是吴军当时想写出来的效果。\n","date":"2024-12-25T23:25:18.255+08:00","image":"https://cdn.jsongo.top/banners/0b2412e8fae47001461d7b73f3127e2d.jpg","permalink":"https://www.jsongo.top/articles/meditations-w52/","title":"Daily Meditations - W52"},{"content":"概述 一句话总结 Cursor 对于研发来说，是一个非常有用的提效工具。一句话来总结 Cursor 就是：\n提示","date":"2024-12-25T21:16:20.48+08:00","image":"https://cdn.jsongo.top/banners/a7f752e124242dcebca6f80af1173db0.jpeg","permalink":"https://www.jsongo.top/articles/coding-with-cursor/","title":"用 Cursor 开发未知语言代码"},{"content":"基础 发射功率的大概认知 一般家用 Wifi 的发射功率在 13 ~ 20dBm 左右 一般蓝牙设备的发射功率范围一般在 -30dBm ~ 20dBm 之间 常见的蓝牙设备，如蓝牙耳机、蓝牙音箱等，发射功率通常在 0 - 4dBm 左右，蓝牙耳机发射功率可能在 0dBm 左右 长距离传输的蓝牙模块，发射功率可能会接近 20dBm 换算 在中国，无线路由器发射功率一般不超过 100mW（毫瓦）。功率（P）与分贝毫瓦（dBm）的换算公式为：\n对于 100mW 的发射功率，换算后约为 20dBm 分贝 (dB) 估算 混凝土墙 蓝牙，信号强度降低 10 - 20dB 左右 Wifi，2.4GHz 强度可能会降低 10 - 20dB，5GHz 降低 15 - 30dB 左右 1 砖墙 蓝牙，信号强度降低 3 - 10dB 左右 Wifi，单堵普通砖墙会使 2.4GHz 强度降低 5 - 12dB 左右，5GHz 降低 8 - 15dB 左右 木板墙和石膏板墙 蓝牙，强度降低一般在 1 - 3dB 左右 Wifi，2.4GHz 大概降低 1 - 3dB 左右，5GHz 大概降低 2 - 4dB 左右 距离估算 空旷环境下 蓝牙，10 米 Wifi，2.4GHz 一般室内可达 30 - 50 米左右，5GHz 频段的一般 15 - 30 米左右 隔了一堵砖墙后 蓝牙，有效传输距离可能会缩短到 3 - 7 米 Wifi，2.4GHz 频段的 WiFi 信号传输距离可能缩短到 10 - 30 米，5GHz 可能缩短到 5 - 15 米 隔了混凝土墙后 蓝牙，有效传输距离可能进一步缩短到 1 - 5 米 Wifi，2.4GHz 频段有效传输距离一般在 5-15 米左右，而 5GHz 仅为 3-10 米左右。 应用 房间布局比较复杂的情况下，测算 Wifi 的覆盖是比较有用的。\n先画出房间的布局图，标注出哪些是砖墙、混凝土墙，标明各房间大概的长宽等 标出 Wifi 的位置（或可以摆放的地方一个个试），往同样环境的地方画圆（扇形），都是空旷的话就是整个圆，如果被墙隔开则分两部分画，多种墙隔着则再拆分更细来画 没覆盖到的地方、或者只在最后一米的地方，信息肯定很差，这时要再想想哪里能挂个中继器\n另外，蓝牙网关也是一种场景，测算方式差不多。 其它 对于 Wifi 来说，WiFi 协议会根据信号强度和质量自动调整传输速率。例如，在信号良好的情况下，可能达到理论上的高速传输速率，如 802.11ac 标准下的几百 Mbps 甚至更高。但当信号减弱后，传输速率可能会降低到几十 Mbps 甚至更低。\nFootnotes 5GHz 频段的信号波长更短，更容易被障碍物阻挡\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-12-25T01:06:18.666+08:00","image":"https://cdn.jsongo.top/banners/437965e93ce93d3c2ca0ebac98d54619.jpeg","permalink":"https://www.jsongo.top/articles/ble-wifi-decays-through-wall/","title":"蓝牙 \u0026 wifi - 隔墙传播衰减数据"},{"content":"平时工作中，可能会时不时碰到像 0 */5 * * * * 这种 Cronjob 定时任务的配置，特别是运维和服务端的同学，经常会打交道。本文只是最基础的用法，后面有新内容再补充，仅作为自己学习、记录、备忘的文档沉淀下。\n基础语法 Cron 表达式的基本格式和含义 Cron 表达式用于配置定时任务的执行时间。它由 6 ~ 7 个段组成，从左到右依次是：秒（0 - 59）、分（0 - 59）、时（0 - 23）、日（1 - 31）、月（1 - 12）、周（0 - 6，0 表示周日）。 上面提到的表达式 0 */5 * * * * 中，有 6 个字段，一一对号入座就行。 除了直接写 *、*/数字 、数字，这种写法之外，还有用逗号隔开的写法，如第 4 个位置表示一个月中的哪一日，如果它写成 1,3,5 表示每个月的 1 日、3 日和 5 日。 对每个字段的具体分析 ** 秒（0）：表示任务在每分钟的第 0 秒开始执行。 分（*/5）：*/5 是一个特殊的语法。在这里，* 表示 “所有可能的值”，/ 是一个间隔符号。所以 */5 表示 “每隔 5 分钟”。也就是说，任务会在 0 分、5 分、10 分、15 分…… 以此类推，每隔 5 分钟执行一次。 时（*）：* 表示每一个小时，即任务会在一天中的每一个小时都有可能执行，具体的分钟由前面的 */5 决定。 日（*）：* 表示一个月中的每一天，即任务在一个月中的每一天都有可能执行。这是第 4 个位置，它有一些特定的语法，如： L：表示每月的最后一天。 W：用于指定最接近给定日期的工作日（周一到周五），如“15W”，它表示最接近 15 日的工作日。 LW：合起来，用于指定本月的最后一个工作日。 月（*）：* 表示每一个月，即任务在每一个月都有可能执行，具体日期由前面的日、时、分决定。 周（*）：* 表示每一个周，即任务在每一周都有可能执行，这个比较特殊，也可以省略而只需要前面 5 个也行。\n开头说的这个配置，含义是在每分钟的第 0 秒开始，并且每隔 5 分钟执行一次，每天每小时、每月都会按照这个间隔执行。简单说，就是 5 分钟执行一次。 简单好记","date":"2024-12-18T00:55:38.424+08:00","image":"https://cdn.jsongo.top/banners/91668e623e452ebc624daa105d2f82c2.jpg","permalink":"https://www.jsongo.top/articles/cron-syntax/","title":"Cron 表达式"},{"content":"触发器各类 Azure Function 有多种模板，我们在创建 Function 时，一般会用 --template 参数要指定用哪个模板。详细的可以参考官方文档：Triggers and bindings in Azure Functions | Microsoft Learn 或中文版 Azure Functions 中的触发器和绑定 | Microsoft Learn。\n以下是一些常见的：\n基于事件触发的模板 Azure Blob Storage Trigger：当 Azure Blob 存储中的 Blob 被创建、更新或删除时触发函数。例如，可以在有新文件上传到指定 Blob 容器时，自动触发函数进行数据处理或文件转换等操作。 Azure Event Hubs Trigger：用于接收来自 Azure Event Hubs 的事件流消息，可实现对实时数据的处理。例如，在物联网场景中，接收设备发送的大量实时数据进行分析和处理。 Azure Service Bus Trigger：可以响应来自 Azure Service Bus 队列或主题的消息，支持批量接收消息。适用于处理异步消息传递场景，如订单处理、消息通知等。 基于数据存储的模板 Azure Cosmos DB Trigger：使用 Azure Cosmos DB 的变更 feed 来监听分区中的插入和更新操作，当有数据发生变化时触发函数，可用于实时数据同步等场景。 Azure SQL Database Trigger：当 Azure SQL 数据库中的表发生数据插入、更新或删除操作时触发函数，方便进行数据的关联操作和业务逻辑处理。 基于定时任务的模板 除了 Timer Trigger 外，还有一些定时任务相关的模板或扩展，如支持按照特定时间间隔或 cron 表达式来定期执行函数，可用于定时数据备份、报表生成等任务 。\n基于 HTTP 请求的模板 除了常见的 HTTP Trigger 外，还有一些针对特定 HTTP 场景的模板或扩展，如支持接收和处理来自 Webhook 的 HTTP 请求，可用于与第三方系统进行集成，接收外部系统推送的数据或事件。\n其他模板 PowerShell Trigger：允许使用 PowerShell 脚本编写函数逻辑，方便系统管理员或熟悉 PowerShell 的开发人员进行自动化脚本编写和任务调度。 Python Trigger：使用 Python 语言编写函数逻辑，适用于数据科学、机器学习等场景，可方便地调用 Python 库进行数据处理和分析。 实践 Timer Trigger Http trigger 在 azure serverless 中介绍过了。这里再讲一下 Timer Trigger，在做定时任务时非常有用，而且计费也只是按函数的执行时间来计，比较划算。\n详细使用可以参考官方文档：Azure Functions 的计时器触发器 | Microsoft Learn 。\n跟创建普通的 Azure Function 一样，还是用 CLI 的 new 命令：\n1 func new --name xxx --template \u0026#34;timer trigger\u0026#34; --authlevel \u0026#34;function\u0026#34; 它会在你的 function_app.py 里创建一个新的 function：\n1 2 3 4 5 6 7 8 9 10 @app.timer_trigger( schedule=\u0026#34;0 */10 * * * *\u0026#34;, arg_name=\u0026#34;timer\u0026#34;, run_on_startup=False, use_monitor=False, ) def my_polling(timer: func.TimerRequest) -\u0026gt; None: if timer.past_due: logging.info(\u0026#34;The timer is past due!\u0026#34;) logging.info(\u0026#34;Python timer trigger function executed.\u0026#34;) @app.timer_trigger 里的几个参数：\nschedule：语法跟 cronjob 的配置一样，参考：Cron 表达式。 arg_name：表示计时器对象的变量的名称，没啥特别含义，就是随便定个名字能用就行。 run_on_startup：部署完、或重新启用时，它自动触发一次。 use_monitor：是否被 monotor 记录，如果间隔大于 1 分钟，建议设置为 true。\n其中， func.TimerRequest 这个参数，其实就只有 past_due 这个 boolean 类型的属性。\npast_due 用于判断当前定时器触发的任务是否已经逾期： 当定时任务由于某些原因（例如系统负载高、资源暂时不可用等）未能在预定的时间点执行，后面才被触发时，mytimer.past_due 将为 True。 如果定时任务在预定时间内正常执行，那么 mytimer.past_due 将为 False\n现在 my_polling 函数里，我们可以添加一些对其它 Azure Function 的调用，由此来处理其它任务的定时执行。这样由两个触发器配合来完成特定任务。当然把逻辑全与在 Timer Trigger 里也不是不行，只不过解耦开之后，Http Trigger 还能被单独使用。 ","date":"2024-12-18T00:42:33.881+08:00","image":"https://cdn.jsongo.top/banners/54ae9a6d9d56a2e58c20dc50f584fd39.jpg","permalink":"https://www.jsongo.top/articles/azure-function-triggers/","title":"Azure Function Triggers"},{"content":"自从改用 Obsidian 来做笔记后，再也不怕文件丢失了，特别是我有了 git 来管理文件后，不小心删掉一些文件也都能找回来，即使是 100 天前删除的都行，非常方便。\n为什么用 git 管理？同步软件不行吗","date":"2024-12-17T23:34:22.963+08:00","image":"https://cdn.jsongo.top/banners/6424b2c83ab269ea18c2240356db3b9d.jpg","permalink":"https://www.jsongo.top/articles/git-recover-notes/","title":"git 恢复误删笔记or文件"},{"content":" 在 Azure Function 上使用 mysql DB，具体可以参考：Azure Database for MySQL bindings for Functions | Microsoft Learn\nMysql 申请 免费额度 免费用户其实还是有不少额度可以使用：\n详细可以阅读：Try Out With an Azure Free Account - Azure Database for MySQL - Flexible Server | Microsoft Learn\n简单说，可以支持 B1MS 实例一直在线上跑，有 32G 的存储空间。B1MS 有 1~2 个 CPU 微核 添加一个实例 打开：[[https://portal.azure.com/#browse/Microsoft.DBforMySQL%2Fservers]]，点 Quick Create。\n简单填写下信息就行：\n下一步、创建，等几分钟就创建成功了：\n简单使用 手动连接 在本地默认是连接不上的， azure 为了安全，对访问做了限制，可以通过 zero trust 网络来接入，当然也可以简单的设置下网络、放行你的 ip：\n不过其实还有更简单的方式，直接在页面上打开连接：\n连接时，它会弹出一个 terminal，然后自动运行 mysql 命令进行连接。实际上，这个时候还连不上，即使你密码输入正确了也不行，它需要验证证书（也是为了安全）。\n证书可以从这里下载：[[https://learn.microsoft.com/zh-cn/azure/mysql/flexible-server/how-to-connect-tls-ssl#download-the-public-ssl-certificate]] ，或者直接用我下图中的 wget 命令即可。\n1 wget https://dl.cacerts.digicert.com/DigiCertGlobalRootCA.crt.pem 需要注意的是，直接连接 Mysql 进行操作比较危险，可以应急用，不建议当成常规操作。\n操作 刚创建的 MySQL 服务里面是空的，得自己手动创建一个 database：\n1 create database xxx; 然后就可以切到这个 db 上使用了：use xxx。\nMac 上连接 如果是在 mac 上安装 mysql 客户端的话，用 brew install 会非常慢，直接到这个地址上去下载一个客户端：Download MySQL Community Server\n","date":"2024-12-16T13:39:37+08:00","image":"https://cdn.jsongo.top/banners/0dba76ff89c558a40825ce7e7a507005.jpg","permalink":"https://www.jsongo.top/articles/azure-serverless-mysql/","title":"Azure Function + Mysql 入门"},{"content":" 花生壳","date":"2024-12-15T16:03:07+08:00","image":"https://cdn.jsongo.top/banners/f53c5884b5505531f32ad8fa0fc57247.jpg","permalink":"https://www.jsongo.top/articles/build-a-cloudflared-tunnel/","title":"免费的花生壳 - cloudflared"},{"content":"基础工具 Mac 上直接装：\n1 2 3 brew tap azure/functions brew install azure-cli brew install azure-functions-core-tools@4 具体可以参考这里：Develop Azure Functions locally using Core Tools | Microsoft Learn\n另外，这链接里也有怎么用命令行来创建的方法。下文 vscode 插件和 CLI 都会涉及。 Vscode 插件 参考这个：Create a Python function using Visual Studio Code - Azure Functions | Microsoft Learn\n简介 在 vscode 中安装插件：Azure Functions\n切到这个插件去点击添加一个函数，一步步往下都有说明，比较简单。\n我选了 HTTP 触发器的模板，最后给我生成了这个文件：\n调试运行 简单的运行，可以用插件面板上，下半部分中的 Project 展开，里面有个调试相关的操作（它可点击）。\n它会先做一些安装，然后启动 function，IDE 进入 debug 模式。这时主要运行的命令是：func host start，直接在命令行里运行这个命令也可以启动本地调试运行。但如果你想查询代码中打的日志，一定要记得加上 \u0026ndash;verbose 的参数，所以正确的使用姿势是：\n1 func host start --verbose 本地调试时，其实已经默认把 AZURE_FUNCTIONS_ENVIRONMENT 这个变量设置为 Development 了，如果你修改代码，它会触发服务的重启，非常方便。\n它同时生成一个链接可以直接点击，它会触发函数执行：\n创建 用 IDE 插件进行 function 创建上面已经介绍过来了，比较简单，不过读者可能会遇到网络问题而没法往下尝试。这里再介绍下 CLI 的方式来创建。\n先初始化目录：\n1 func init --python 它会生成一些基础的配置文件，包括 [[https://learn.microsoft.com/en-us/azure/azure-functions/functions-develop-local#local-settings-file]] 和 host.json。\n创建一个 api 入口：\n1 func new --name combine_videos --template \u0026#34;HTTP trigger\u0026#34; --authlevel \u0026#34;function\u0026#34; Authlevel 有三个值：\nAnonymous 即任何人都可以访问，不需要带什么认证，相当于公开了。 Function 函数级别的认证，创建的每个函数都得在 URL 上带一个 token 进行认证，参数是 ?code=\u0026lt;token\u0026gt;。 Admin，最高级别的认证，只有具有管理员权限的用户才能访问函数，适用于包含敏感操作或数据的函数，如修改系统关键配置、访问敏感的业务数据等。这种模式依赖于复杂的身份管理系统（如 AAD）。 部署 平台创建应用 先打开 [[https://portal.azure.com/#browse/Microsoft.Web%2Fsites/kind/functionapp]] 这个 portal 地址，创建一个 Function App （或者中文叫“函数应用”）。\nPlugin 正式部署前，肯定是需要先登录的。正常是可以在插件上操作，如下：\n如果不成功，可以用下文 CLI 的方法来登录。\n选择 Deploy to Function App，直接进行部署。\n我在使用的时候，经常遇到网络问题，因为某些你懂的原因，所以挺难的，得给 vscode 设置 Proxy (具体就不介绍了)\nCLI 发布 登录 使用前也一样需要先登录 (上面的说明都是在本地开发)：\n1 az login 运行时，它会打开一个网页进行登录授权\n命令行也会有一堆打印，有如下关键信息就说明已经登录成功了。\n发布操作 当然我们也可以选择用 CLI 来做发布：\n1 func azure functionapp publish \u0026lt;project_name\u0026gt; 具体细节可以参考这里：Create a Python function from the command line - Azure Functions | Microsoft Learn\n这里的 project_name 跟在平台上创建的应用名要保持一致，要不然会找不到这个 App 而发布失败。\n另外还有一点要注意的是，本地的 python 环境需要跟平台上的一致，避免本地跑的好好的、部署上去就缺一些模块：\n部署完会生成一个地址可供访问：\n部署的过程是会比较慢，我们从平台的部署日志中可以看到它部署完后，会等待 1 分钟：\n在线上运行后，可以访问试试。\n线上日志可以在这里看到：\n不过经常连接不稳定，所以其实可以到另一个地方查看 ：\n重要插件 Azurite 安装另一个三方的 server 运行插件 Azurite，为开发人员提供了一个免费的本地环境，用于测试 Azure Blob、队列存储和表存储应用程序。常用的主要是 MySQL 操作，本地连不上线上 MySQL，它帮你开了一个代理，可以直接把本地调试时写的数据同步到线上。\n如果没有它，本地如果运行定时任务就是出异常：\n修改下 local.settings.json 的配置，把 AzureWebJobsStorage 设置成 \u0026quot;UseDevelopmentStorage=true\u0026quot;。\n打开命令面板，运行 Azurite start 来启动服务\n这时它们的启动非常快，一闪而过，没关系，它已经在跑了。\n比较烦的时，运行时，会在当前目录下生成一些文件：\nblobstorage 和 queuestorage 作用： 这些文件夹通常用于存储本地开发时的 Azure Blob 存储和 Azure Queue 存储的模拟数据。当你在本地运行和测试 Azure Functions 时，这些文件夹可以帮助模拟真实的 Azure 存储环境。 例如，如果你有一个 Azure Function，它从 Blob 存储中读取数据或者向 Queue 存储中写入数据，在本地开发环境中，这些文件夹会存储相关的数据，以便函数能够正常运行和测试。 使用场景： 在没有连接到真实 Azure 存储账户的情况下，本地开发和调试函数时需要用到。如果删除这些文件夹，可能会导致本地运行的函数在涉及到 Blob 或 Queue 操作时出现错误，因为它们找不到模拟的存储数据。 以 azurite_db 开头的.json 文件 作用： 这些文件是 Azurite 数据库文件。Azurite 是一个本地的 Azure 存储模拟器，用于在本地模拟 Azure Blob、Queue 和 Table 存储服务。这些.json 文件存储了 Azurite 模拟存储服务的数据结构和数据内容。 例如，azurite_db_blob.json 文件用于存储模拟的 Blob 存储数据结构和数据，azurite_db_queue.json 文件用于存储模拟的 Queue 存储数据等。 ","date":"2024-12-14T01:33:06+08:00","image":"https://cdn.jsongo.top/banners/9f2713cc4890d8cf0449df9f4877fa26.jpg","permalink":"https://www.jsongo.top/articles/azure-serverless/","title":"azure serverless 使用"},{"content":" 这是这几天在看的一本很有趣的书，有感而发这篇读书笔记\n概述 买这本书主要是冲着古典老师去的，之前对他的《跃迁》印象深刻，受益匪浅。刚看到书名我就想起了《世界尽头的咖啡馆》前两年还出了续集，我都看了。后来在读本书的时候，感觉就是在看国产的《世界尽头的咖啡馆》，叙述方式很像，内容上也是讲职场和生活，所以阅读起来我有种熟悉的感觉。\n这几年经济不好，大家都在职场和创业的路上挣扎，都过得很不容易。随着越来越多人“毕业”，讲人生规划类的书籍或课程必定会大受欢迎。因为大量的城市精英突然就遇到了 10 几年一个周期的经济萧条，上一轮大概率没经历过，这么一来就有点措手不及，人生突然陷入迷茫。\n有缘看到这篇文章的人，如果正好自在这个阶段，可以读读上面提到的这 3 本书（《世界尽头的咖啡馆》有两本），相信会有不错的启发。\n本文主要摘录我在阅读过程中受到触动，结合自己思考写下来的一些笔记，希望能引发读者一些思考。\n思考清楚自己的赛道 下班后才是一个打工人最清醒的时刻 全书多次提到这句话，故事中的那个咖啡馆也只有在晚上 9 点后才开门，因为打工人下班了。古典在书中说的这句话，主要想表达，在上班的时候，人容易迷失自己，沉浸在为做好工作而对其它事情浑然不觉的状态中，更不会抽时间去思考自己的现在、做事方式、未来的发展等，一心在做好当下的事。\n不过在下班后，就有更多的时间回去“做自己”，这时就换了一个完全不一样的思维，可以思考更多的可能性，而不是工作干不好整个世界就完了的状态。\n换赛道 如果打算换赛道，尽可能地一步步切换，就像攀岩，不要一步就跳过去，容易失去抓手、然后掉下去。\n即使是“毕业”，离开岗位时，也要留住人脉和技能，然后在这些基础上慢慢探索、切入适合自己的赛道。\n书中古典老师化身的胖子，是一个耐心的人生导师。他针对职场，提出了一个公式：\n定位=行业 x 企业 x 职位\n可以尝试先切换其中的一个变量。比如现在是在互联网行业，这个大前提可以不用换。之前一直在走“职位”这条路，一路往上爬。实际上还有其它思路，只是我们平时很少思路，一心盯着职位职级。公式中没有讲的很具体，没提职位怎么切，但这个变量给了我们一个思考的起点，即可以挪挪屁股，换一个部门或团队，如果一个产品 (业务) 自己不喜欢、不适合、或识别出不是自己未来发展方向的话，及时果断地换。比如想往 AI 技术方向发展，可以切换到 AI 相关的团队中去，找到一个让自己有更多学习的机会的环境中去。\n大概的步骤可能是这样：\n先认真收尾手头的事，边观察机会、切换赛道； 然后在新赛道中认真的学习、快速积累，不计得失，努力去做成一些事，有一些自己的创造或产出； 在上一条的持续迭代中，不断地精进到某个高度，同时积累更多的技术和人脉； 如果条件成熟，可以再考虑切换企业，继续创造，验证这套模式可行性，并不断完善相应框架，同时继续积累更多的技术经验和人脉； 最后如果还有激情和条件，可以再切换到创业的赛道，有一份真正属于自己的事业。 职场 职业的本质是什么？ 通过帮别人解决问题来获利。\n该给你多少钱，不是看你有多厉害，而是看别人的问题有多大。\n我们一直以为只有把专业技能练到炉火纯青的地步才能赚大钱，其实不太对。赚钱的是那些，找对了痛点和问题、然后培养自己能力，最终能解决这类问题的人。\n简单说，是需求决定价格，而不是供给决定价格。\n同样是销售，卖房子的就是比卖汽水的赚钱。虽然他们的本质都是跟人打交道，找到别人的痛点，把自己的东西包装下卖给别人。最关键的点，在于找对行业。怎么把一瓶水卖出天价，也许能做到这个的人你会觉得他很厉害，不过很可能他只是把水运到了沙漠中去卖而已。\n当然这点可能不只一个人发现，那么随着加入的人越来越多，就成了红海。时机很重要，但如果已经晚了的话呢？这时我们只能去发现更多的新机会。新机会往往出现在新行业，这有点像废话，不过更多时候，我们只是看着新行业到来，也没什么行动。\n宁当鸡头，不做凤尾 在一个不怎么重要的部门当尾部，还不如去一个新部门（缺人才的部门）承担非常重要的岗位，给自己更多的历练，最重要的是成长和突破过去的自我，往未来趋势的方向不断的前进，这才是最有意义的。\n很多人一直盯着职级、地位看，干嘛要一直去跟别人做比较呢？要知道职级就是公司设置的游戏规则，把人牢牢地套在规则里面、认真的奉献，不过很多人即使知道这一点，还是会很执著地追求这些。可能是因为不甘心，也可能是因为自尊心太重…… 但不是正确的方向还要坚持，就很难过得好。\n提升自我 打磨优势 没有人是完美的，要充分亮出自己的优势，像一把沙子中只有一点点金子，经常容易被埋没，如果你经常去擦亮你找到的金子，它就会在沙子中闪闪发光。\n重要的是把优势放大，同时规避劣势。\n找优势可以用排除法，看看失去什么会让我活不下去。每个人都有优势，只是说怎么在沙子中找到金子，以及怎么让别人看到。\n风口没了，猪会不会摔死？\n你进入了风口之后，要不断地学习、站稳，让自己长出翅膀来，趁着红利在这个领域站稳脚跟。翅膀就是这个培养出来的优势，如果没及时长出来、亮出来，风口过后就会摔得很惨。\n多关注自己、跟过去比 不用总盯着别人的优势、跟别人比，要多跟现在自己比，只要让自己过得更舒适、更充实就行。\n不一定要超越别人才算成功，大家的起点或运气不一样，世界本就不公，抱怨改变不了一切，接受现实往往是很难的，总会有不满。但我们注意力不应该在这，而应该放在怎么不断地去突破自我，要比之前的自己活得更好、变得更强。以前觉得自己不太行的地方，突然自己变得非常行了，这就是最有意义的事。\n只要坚持着慢慢地跑，就能赢过很多人 人生就像一场马拉松。这点感受很深，平时我也经常去跑步，坚持很累，特别是突破之前跑过的距离，很多人都会在途中停下休息，如果能一直坚持，就能赢过大部分人。\n人生更像是在操场上跑圈，时不时有人加入，不用羡慕刚加入的人的体力，他们刚下场体力就是好，开始时就是跑得快，也可能是基因好、祖上都是运动员。但你一直坚持下来了，总能超过大部分人，毕竟有先天优势的只是非常少数，干嘛一定要跟他们比呢。\n读书的方法 读书就是以自己为中心，以问题为导向，以改变为终点。\n想不是办法，干才有答案 路是走出来的，不是设计出来的。\n人们总是喜欢提前规划路线，其实路不是想出来的，而是走出来的。没真走到那路口，也不一定了解那边的路况，只是听人说、或看地图知道的。这些都不一定准确，或者偏离的很多。\n初心 “如果当时……” 是人生最大的谎言。\n或许当时的选择，已经是那会能找到了最好的选项之一。不用去想走了另一条路会怎么样，因为我们经常会去美化那些得不到的东西，这样它就变得不真实，而且会很后悔、搞坏了尽情…… 没必要，这些都是自己在找罪受。\n认识到这一点后，怎么正确地去看待这些选择呢？重点还是“初心”，了解自己来自哪、有什么目标或使命要去完成。这样再去做选择的时候，至少知道方向。\n每个苦苦坚持的不得不，都藏着巨大的初心。\n我们可能都有一些比较初期的出发点，或许我们已经忘了，但它带来的动力和惯性，让我们一直往前走，只不过后来我们以最近的幻想来衡量自己的行为和成果，忘了这个初心。\n或许当时的初心只是不想在小城市一眼看到头，而是想探索更多的可能性，想不断地超越儿时玩伴或亲戚朋友，只不过慢慢地，买了房，有了房贷，想自由，想赚钱，然后迷失了最初的初心，变得浮躁，一切心赚钱为目标，但又碰到各种障碍，终日郁郁寡欢。\n当一个人知道最初的“为何”，就能承受一切“如何”。\n我们不是害怕苦难，而是怕苦得没有意义，白白花费了很多精力、最终没得到任何收获。\n管理 项目管理中的 1-10-100 定律 解决一个问题：\n事前计划，只需要 1 的成本。 事中改进，就需要 10 的成本。 事后修正，那需要 100 的成本。\n所以为什么要做重要但不紧急的事。因为这是最省成本的方法，如果每天都在做紧急的事，那基本都要付出 10 或 100 的成本。\n如果大部分能预期的事，都提前做好事前的计划，并及时地执行，那你完成它们的成本就只有 1 x N，而不是 100xN。这时你就可以比别人省出更多的时间。 做团队管理的两个重要的事 1 是帮别人拿成果，要为他争取机会，且争取时间，及时、适当地推他一把。 2 是保护大家，一方面不让一些杂事、不重要的投诉分心，另一方面 pk 掉不合适的需求直接找到他们，不要当一个传话筒或需求传送带。 成为专家之路的几个阶段 求助者，这是最开始的时候，什么都不太懂，开始入门 探索家，有了兴趣或任务，不断地深挖、学习更多这方面的知识 建筑师，把自己在这里面学到的一些有一定难度的东西沉淀下来，形成框架 助人者，在平时帮助别人解决问题的过程中，不断的完善自己的框架，补齐知识点 专家，最终自己的框架已经比大多数人认知更深了，在别人眼里就是半个专家了。\n其实不一定要到了助人者或专家再开始发声，从探索时就可以开始，动手去慢慢打磨、创造一个产品，然后跟着它一起成长。同时也把这个成长的过程分享出来，让初学者都能从中受益。\n这个世界其实初学者（求助者）远远多于其它阶段的人。这就是一个金字塔，越塔尖的人越专业、而大部分人都是在中等以下。所以市场及需求最大的往往都是上面说的“探索家”和“求助者”。 ","date":"2024-12-13T17:29:08+08:00","image":"https://cdn.jsongo.top/banners/058b101b8325853cf16210d89529ed82.jpg","permalink":"https://www.jsongo.top/articles/no-work-cafe/","title":"读《不上班咖啡馆》的收获"},{"content":"最近被 aws 算计了好多钱，之前一直没在意。后来才知道，是当时开了一个 cloud9。 EC2 一个月扣我 10 刀，Virtual Private Cloud 应该是 cloud9 启动后，内部建立的容器集群。Tax 这个就不用说了，10%的税 刚开始进入控制面板首页时，看不到什么异常，点 EC2 也没看到什么不对的地方：\n这个页面：https://us-east-1.console.aws.amazon.com/console/home?region=us-east-1 看起来很正常，也没有实例在跑 后来点了 global view 才知道，原来其它区域还有，aws 它是分区域隔离的，我一直在用 us-east 的，所以一直没发现。 这里找 global 使用中的实例 ","date":"2024-12-13T15:59:05+08:00","image":"https://cdn.jsongo.top/banners/1f46848857f50464c097c5ea752ee538.jpg","permalink":"https://www.jsongo.top/articles/avoid-aws-charges/","title":"踩坑：如何避免被 aws 悄悄地收费"},{"content":"职业的本质是什么？ 通过帮别人解决问题来获利。\n该给你多少钱，不是你有多厉害，而是别人的问题有多大。\n我们一直以为只有把专业技能，练到炉火纯青的地步才能赚大钱，其实不一定对。不排除这种可能性，那些真正赚钱的是找对了目标问题，然后培养自己能力，最终能越来越好地解决这类问题的人。\n简单说，是需求决定价格，而不是供给决定价格。\n例子 同样是销售，卖房子的就是比卖汽水的赚钱。他们的本质都是跟人打交道，找到别人的痛点，把自己的东西包装下卖给别人。\n关键在于找对行业。怎么把一瓶水卖出天价，或许能做到这个的人，你会觉得很厉害，不过可能，他只是把水运到了沙漠中去卖而已，会的技能可能就是开车运货，以及经过探索学会了低成本把水运到沙漠、并全身而退的经验。\n这或许不只一个人发现了，可能加入的人越来越多，就成了红海。我们需要去发现更多的新机会。新机会往往出现在新行业。这有点像废话，但更多时候，我们只是看着新行业、新机遇到来，却没什么行动，原来的地方太舒服了，不想动，也或者是因为觉得自己根本玩不来。\n工作中真正有价值的东西 真正有价值的东西，是你离开现在的工作环境后，你还剩什么，还有多少人认可你。你现在的职级、带多少人、老板多看重你，这些都没有价值，它或许能短期能帮助你过得更好，但不是你长期可以保有的东西。某天公司不行了，或者你被迫离开公司后，这些都不再是你的。\n职级，在你离开后，只是一个饭后谈资，也可能在下一份职业中帮你得到了一个更好的定位，但前提是真有公司需要，说白了还是得看其它公司的脸色（需求）。 带多少人，这更没意义了，离开公司，谁记得你曾经带过多少人？ 老板多看重你，这只是他个人的主观看法，离开这个老板（转岗）就没意义了，可能他地位比较高，能在一些事情上帮你一把，但你真离开公司了，他又能为你做啥呢？况且你的离开可能本身就是对他的伤害。 只要不是老板，你平时的工作更多的是在为别人实现“梦想”。\n这里说的“老板”，是指你有不少股权，或从中能得到不错的声誉等，把你跟公司的兴衰绑定在了一起。\n“价值”这个事，其实是变化的。\n刚毕业时，主要的时间都是在学习，边学习还能边赚钱养活自己，这样就够了。 等积累多了，成了这方面的资源员工、或团队负责人、或专家，这时你就是在不断运营自己的影响力，让自己被更多人认可，能得到更多的好处。 之后离开公司了，你留下来的技能、人脉，这些才是你自己的东西，是真正有价值的。 ","date":"2024-12-09T13:34:29+08:00","image":"https://cdn.jsongo.top/banners/99b74ba8e0135b5536a125e3596d5212.jpg","permalink":"https://www.jsongo.top/articles/meditations-w50/","title":"Daily Meditations - W50"},{"content":"介绍 借助 Office Add-ins 可以在 word 里使用大模型与用户输入的内容做交互。甚至可以尝试接入 RTC 让用户用嘴写作，动口不动手。\nOffice Add-ins，中文 “加载项”。\n下文中，讲到 Add-ins 主要是指这个技术，提到具体应用时，会用“加载项”概念，主要是指 Office 应用中、下图所示的功能。\n概念 Office Add-ins 可以理解为是一种可以扩展 Microsoft Office 应用程序（如 Word、Excel、PowerPoint 等）功能的小程序，能增强 Office 应用程序的能力，能与 Office 文档中的内容进行交互。\n从技术栈来说，它是基于 Web 技术（如 HTML、CSS 和 JavaScript）构建的，可以利用熟悉的 Web 技术栈来创建它们。\nLLM 这两年来的火热，结合强大的内容生产工具套件——Office，其实可以给很多专业的内容工作者带来很大的帮助。\n工作原理 加载机制：用户在 Office 应用程序（如 Excel）中通过特定的界面（如 “插入” 选项卡中的 “我的加载项”）来加载和运行 Office Add-ins。当用户启动时，Office 应用程序会创建一个运行环境，加载相关的 Web 资源（HTML、CSS、JavaScript），并为 Add-ins 提供访问 Office 文档和应用程序功能的接口。 交互方式：Add-ins 使用 JavaScript 调用 Office JavaScript API，来跟 Office 应用程序进行交互。这个 API 提供了许多对象和方法，允许 Add-ins 读取和写入文档内容、操作 UI 元素（如自定义任务窗格、功能区按钮）等。比如，一个 Word Add-ins 可以使用 API 获取当前文档中的段落数量，或者在文档的特定位置插入文本，或者获取内容然后与 LLM 对话。 应用场景 数据可视化：可以将复杂的数据以直观的图表或图形形式展示在 Office 文档中。例如，在 Excel 中创建一个加载项，能够根据工作表中的数据自动生成精美的数据可视化图表，而且这些图表可以根据数据的更新而实时变化。 协作工具：增强 Office 应用程序的协作功能。比如在 Word 文档中添加一个加载项，实现多人同时在线编辑文档时的实时评论和沟通功能，类似于在文档旁边开启一个小型的即时通讯窗口，方便团队成员交流想法。 内容生成与自动化：帮助用户自动生成文档内容或进行格式设置。以 PowerPoint 为例，一个加载项可以根据用户输入的主题和要点自动生成一套完整的幻灯片，包括添加合适的图表、图片和布局等 Why Add-ins 官网给了一张图：\n可以跨端，不同端上都有 Office，你写的功能在不同平台上都可以跑起来 中心化的分发，不用你自己到处去做上线（如 app Store） 很容易下载安装 开发的技术栈也都比较友好（Web） 市场（AppSource） 业务应用 - Microsoft AppSource\n可以看到已经有很多 AI 应用了，这个截图还只是首页的前几个应用。有不少官方也都上线了 Office Add-ins 应用，比如 Grammarly、Draw.io、Adobe、Wekipedia、Mermaid 等。生态已经比较成熟了。\n过滤了下 Microsoft 365 相关的（如 Excel/Word/OneNote/Outlook/PPT 等）就有 7000+ 个。\n交互形态 目前看到的主要交互形态有：\n1、Excel 等里作为一个嵌入内容显示在表格中。\n2、Excel/Word/PPT 中作为侧边窗格可以单独进行交互。\n这种交互其中有两个操作点，一个是顶部，它也可以触发一个事件；另一个是侧边，本质上它是在侧边开一个类似 Webview 的容器，里面跑 Web 页面。\n开发 工具安装 基础开发环境 1 pnpm install -g yo generator-office 如果没成功可能是依赖 mem-fs，直接安装下就可以：\n1 pnpm install -g mem-fs 生成代码 1 yo office 生成后它默认用 npm 来 install，觉得慢的话直接把进程杀掉，然后重新跑 pnpm install。\n后面就是熟悉的 npm run start 了，写真正的代码逻辑了。\n辅助开发工具 Office Addin 项目创建和基架工具是 Office 加载项的 Yeoman 生成器，简称为 yo：GitHub - yeoman/yo: CLI tool for running Yeoman generators。\nVs code/cursor 开发插件 可以安装下这个：Microsoft Office Add-ins Development Kit\n当然也可以用 npm start，不过运行前一定要记得先运行 npm run dev-server，要不然只是 start 个客户端、背后没服务是跑不起来的。如果一直失败，那直接把所有在 run 的都关掉，word 也退出，运行几次 npm stop （因为我也遇到了，当时运行了好几次 start，它起了多个背后的进程）。所以其实用插件还是比较方便些，命令行可能会遇到一些想不通的问题。\n用命令行如果遇到问题，可以参考这里：Build your first Word task pane add-in - Office Add-ins | Microsoft Learn\nScript Lab Script Lab 是一种用于快速创建调用 Office JavaScript 库 API 的“原型代码”。\nScript Lab is a tool for quickly prototyping code that calls the Office JavaScript Library APIs.\n安装时，公司账号可能会用不了，可能跟公司的安全策略有关。最好切换个人账号。\n可以到 这里 或 这里 来直接下载安装，需要登录，这里如果用公司的账号可能会失败，可以尝试下个人的账号。如果是走的公司内部的采购，有个小技巧：公司内部申请下来之后，用它激活，然后退出登录自己的账号，我这么测试了下，用自己账号依然保持着激活状态，看来它激活的是软件本身，跟账号没关系。\n第一次登录 AppSource 的话，会有一堆流程，一会儿要认证，一会儿要补充信息……\n装完之后，打开 word 就可以看到了：\n运行 运行起来后，如图所示：\nWord 是自己弹出来的，vscode 插件背后是起了一个 server （默认在 3000 端口），为侧边这个“页面”提供调试服务。\n限制 从生成的代码中可以看出，微软对 Add-ins 其实做了一些环境限制：\n只有 IE 和 Edge 浏览器内核才能跑，当然 Office 版本也有限制，这个倒还好。\n相关资源 Word add-in tutorial - Office Add-ins | Microsoft Learn ","date":"2024-12-06T13:08:16+08:00","image":"https://cdn.jsongo.top/banners/8c1ce5c3e62a16997b7cf83e5164726c.jpg","permalink":"https://www.jsongo.top/articles/office-add-ins-1/","title":"开发 Office Add-ins 应用（一）：在 word 里使用大模型"},{"content":"概念 MCP 即 Model Context Protocol，模型上下文协议，它能通过借助外部或历史信息，来更高效地构建信息更全面的上下文信息。\n这是一个非常重要的协议，刚发布的时候，x 上大家都乐开了花，一个比较典型的说法是“村里通网了 - Claude MCP 开启数据连接和操作的新宇宙”。我一直认为，LLM 要能跟外界真正的能交互起来才能有更大的想像空间。之前见过一些有趣的如操作电脑的辅助 LLM 的工作，还有一些辅助浏览器操作的插件，这次是从协议上就定出一个标准，大家只要按照标准来，都可以相互打通。\n功能 介绍 参考：Claude秒变Cursor！MCP让AI直接编辑本地文件 | Anthropic MCP实测\n官方文档：Introducing the Model Context Protocol - Anthropic 使用 安装（以 Mac 来讲） 1 brew install uv git sqlite3 然后下载 Claude 桌面端， 开启 如何启用具体可以参考：[[https://modelcontextprotocol.io/quickstart#installing-prerequisites-macos]] 简单说，这个功能桌面端才有，Mac 上可以打开 ~/Library/Application Support/Claude/claude_desktop_config.json 编辑下这个 JSON 文件，然后重启下 Claude 客户端就自动启用了。往 JSON 文件里写内容： 1 2 3 4 5 6 7 8 { \u0026#34;mcpServers\u0026#34;: { \u0026#34;sqlite\u0026#34;: { \u0026#34;command\u0026#34;: \u0026#34;uvx\u0026#34;, \u0026#34;args\u0026#34;: [\u0026#34;mcp-server-sqlite\u0026#34;, \u0026#34;--db-path\u0026#34;, \u0026#34;/Users/\u0026lt;my-user-name\u0026gt;/claude.db\u0026#34;] } } } 示例 官方给的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # Create a new SQLite database sqlite3 ~/claude.db \u0026lt;\u0026lt;EOF CREATE TABLE products ( id INTEGER PRIMARY KEY, name TEXT, price REAL ); INSERT INTO products (name, price) VALUES (\u0026#39;Widget\u0026#39;, 19.99), (\u0026#39;Gadget\u0026#39;, 29.99), (\u0026#39;Gizmo\u0026#39;, 39.99), (\u0026#39;Smart Watch\u0026#39;, 199.99), (\u0026#39;Wireless Earbuds\u0026#39;, 89.99), (\u0026#39;Portable Charger\u0026#39;, 24.99), (\u0026#39;Bluetooth Speaker\u0026#39;, 79.99), (\u0026#39;Phone Stand\u0026#39;, 15.99), (\u0026#39;Laptop Sleeve\u0026#39;, 34.99), (\u0026#39;Mini Drone\u0026#39;, 299.99), (\u0026#39;LED Desk Lamp\u0026#39;, 45.99), (\u0026#39;Keyboard\u0026#39;, 129.99), (\u0026#39;Mouse Pad\u0026#39;, 12.99), (\u0026#39;USB Hub\u0026#39;, 49.99), (\u0026#39;Webcam\u0026#39;, 69.99), (\u0026#39;Screen Protector\u0026#39;, 9.99), (\u0026#39;Travel Adapter\u0026#39;, 27.99), (\u0026#39;Gaming Headset\u0026#39;, 159.99), (\u0026#39;Fitness Tracker\u0026#39;, 119.99), (\u0026#39;Portable SSD\u0026#39;, 179.99); EOF 创建一个表，然后往里面写一些数据。\n运行 1 uvx mcp-server-sqlite 它会用 uvx 来运行 mcp 服务。\nPrompt Demo:\nCan you connect to my SQLite database and tell me what products are available, and their prices?\n原理 其实就是加了一个 MCP server 作为本地代理，架构如下：\nMCP 是一个开放协议：\n首先会建立与外部数据源的连接。它使用预定义的接口和数据格式来识别和访问这些外部源。例如，当需要从一个关系型数据库获取信息来为语言模型（LLM）提供上下文时，MCP 会通过数据库驱动程序按照数据库的协议（如 SQL）进行通信，检索数据。 另一方面 MCP 也类似 Prompt 模板一样，提供了动态上下文构建的能力： MCP 能够留空的方式，动态地构建上下文。 例如，在聊天界面应用中，当用户询问一个关于特定产品的问题时，MCP 可以快速从产品数据库中获取产品的规格、用户评价等相关信息，并将这些信息组合成一个有意义的上下文提供给 LLM。 还可以根据用户的交互历史来调整上下文。\n它本身会不断更新和优化提供给 LLM 的上下文，确保 LLM 能够跟上用户的思路，通过这些方式，MCP 能提高 LLM 的工作效率和回答质量。 ","date":"2024-12-06T00:56:02+08:00","image":"https://cdn.jsongo.top/banners/b87a43aef0ebf4a4d13f45ad57e9b5d2.jpeg","permalink":"https://www.jsongo.top/articles/claude-mcp-101/","title":"Claude MCP 体验"},{"content":" 几种方案 IP-Adapter 原理：IP-Adapter 的核心是其 “解耦交叉注意力机制”，它将文本特征和图像特征的处理分开，为每种输入类型创建了不同的路径，从而能够更好地将视觉提示信息整合到模型中，同时不影响模型对文本指令的理解和执行能力。通过这种机制，IP-Adapter 可以识别参考图的艺术风格、内容以及特定的角色形象等信息，并生成与之相似的作品。 使用方式：以 Stable Diffusion 为例，需先下载对应版本的 IP-Adapter 预处理器和模型，如 sd1.5 版本的 “ip-adapter_clip_sd15” 预处理器及相关模型。在使用时，将打斗场景图作为输入图像，将角色形象图作为参考图，通过调整相关参数和权重，IP-Adapter 就能根据角色形象图的特征对打斗场景图中的角色进行适配和修改，生成符合预期的新图像。 DreamBooth 原理：DreamBooth 是一种基于扩散模型的微调技术，它允许用户使用少量的特定主题图像（如你的角色形象图）对预训练的文本到图像生成模型进行微调，使模型能够学习到与该主题相关的特定特征和细节，从而在生成图像时能够更准确地生成符合该主题的内容。 使用方式：首先收集包含角色形象的高质量图像数据集，然后选择一个预训练的基础模型，如 Stable Diffusion 等。使用 DreamBooth 技术对基础模型进行微调，将角色形象与特定的唯一标识符绑定，让模型学习到角色的特征。最后，将微调后的模型应用于打斗场景图，通过输入相关的文本提示，模型会根据学习到的角色特征对场景图中的角色进行适配和生成。 LoRA (Low-Rank Adaptation of Large Language Models) 原理：LoRA 的基本思想是通过在大型语言模型的基础上，添加少量的可训练参数来实现对模型的微调，从而在保持模型原有性能的基础上，快速适应特定的任务或领域。对于图像生成任务，同样可以利用类似的原理，通过对预训练的图像生成模型添加 LoRA 模块，使其能够根据特定的角色形象图进行微调，学习到角色的特征表示，进而在生成图像时能够更好地适配这些角色形象。 使用方式：先确定预训练的图像生成模型，然后针对你的角色形象图准备相应的数据集。接着，设计并训练适合该模型的 LoRA 模块，使其能够捕捉到角色形象的关键特征。在实际应用中，将训练好的 LoRA 模块与预训练模型结合，输入包含打斗场景和角色相关的文本提示，模型就会根据 LoRA 模块中学习到的角色特征，对场景图中的角色进行相应的适配和生成。 ControlNet 原理：ControlNet 是一种用于控制图像生成过程的神经网络架构，它可以通过添加额外的条件控制信息来引导图像生成模型生成符合特定要求的图像。在你的需求中，可以将角色形象图作为 ControlNet 的输入条件，通过网络中的特定模块对生成过程进行约束和引导，使生成的打斗场景图中的角色能够更好地适配给定的角色形象. 使用方式：选择合适的 ControlNet 预训练模型，并将其与基础的图像生成模型结合，如 Stable Diffusion。将打斗场景图作为基础图像输入，同时将角色形象图作为 ControlNet 的条件输入，通过调整 ControlNet 中的各种参数和权重，如控制线条、色彩、形状等方面的参数，来精确控制生成的图像中角色的外观和姿态，使其与给定的角色形象相匹配。 成本分析 IP-Adapter：IP-Adapter 无需进行模型训练，主要成本在于寻找符合预期的参考图，其成本相对较低，能在几分钟内看到结果，大大节省了时间。 DreamBooth：训练成本相对较高，需要至少 20 张不同角度的人物图像，并且对硬件要求较高，至少需要 24GB 的显存以及性能较好的 GPU，若使用云服务训练则还需额外产生费用。 LoRA：LoRA 可以冻结预训练模型的全部参数权重，然后只在新增的网络层去做训练，训练数据量可根据具体需求而定，因此成本相对较低。 ControlNet：ControlNet 的训练成本相对较高。例如，其 canny edge detector 模型的训练需要 300 万张边缘 - 图像 - 标注对的语料，在 A100 80g 的环境下要花费 600 个 gpu 小时；human pose 模型则需 8 万张姿态 - 图像 - 标注对的语料及 400 个 gpu 时。 思路 LoRA 过拟合问题 需要准备多张形象比较一致的图片，要不然只有一张图会有过拟合问题，以及特征不全面的问题。简单说，仅靠一张图片，LoRA 可能无法学习到角色的完整特征，导致在生成场景图中角色的其他角度或状态时出现不匹配的情况。例如，角色在训练图片中是正面微笑的形象，在生成侧面打斗场景时，可能会出现面部结构变形或者表情不自然的问题。\n这个方法可以作为后续优化的方向，当可以生成多张形象一致的图片时，再来试试这个思路。\n猫箱类软件 这些软件会让使用者先上传几张自己的图片，之后它其实会拿这些去做 LoRA 训练（也可能是其它方式的微调， 如 DreamBooth），之后再用这个用户专属的模型去生成他后续的各场景图。这类软件使用方式上，稍微有些麻烦，因为上传图片用户得好好挑挑，都上传同一时间或穿着、光线下的图片时，其实效果也一般也容易过拟合。不过训练完后，就可以非常自由的生成非常丰富、多样的场景下的个人图片，弄得好的话非常逼真，真假难辨。\nControlNet 硬件要求 ControlNet 需要一定的硬件支持来运行，由于它在原始扩散模型基础上增加了控制模块，对 GPU 等硬件资源的需求相对较高，特别是在处理复杂的控制条件和高分辨率图像生成时，可能需要更强大的 GPU 来保证生成速度和质量。\n时间成本 训练 ControlNet 所需的时间较长，从数据收集、标注到模型训练完成，整个过程可能需要数天甚至数周，这取决于训练数据的规模和硬件设备的性能。\n总体看，成本上不一定划得来。相比之下，IP-Adapter 不需要训练模型，只需找到符合预期的参考图即可开始生成，大大节省了时间和资源，能够在几分钟内看到结果，其模型参数只有 22m，存储占用小，对硬件资源的要求相对较低，下面展开讲下\nIP-Adapter IP-Adapter 确实有其独特的优势，使其成为一种很有吸引力的图像生成辅助方法，以下是对其优点的详细介绍。\n无需训练模型 与需要收集大量数据并进行长时间训练的 LoRA 等方法不同，IP-Adapter 不需要训练模型，大大节省了时间和资源，仅需找到符合预期的参考图即可开始生成，能在几分钟内看到结果，效率极高。\n单图即可实现风格迁移 只需一张图片就能实现风格迁移，将该图片的风格特征融入到生成的图像中。例如，如果有一张具有独特画风的角色图片，IP-Adapter 可以把这种画风应用到新生成的打斗场景图中，让场景图中的角色呈现出与参考图一致的风格，为生成特定风格的图像提供了极大的便利。\n支持多图多特征提取 可以同时读取多张参考图，并提取它们的特征，从而使生成的结果拥有更丰富的多样性和随机性。比如，你有几张同一角色在不同状态下的图片，IP-Adapter 能够综合这些图片的特征，生成更全面、更具变化的角色形象，使其在打斗场景中的表现更加自然和丰富。\n与 Prompt 配合度高 对 Prompt 有强注意力，能使 Prompt 中的信息更直观地反映在生成结果中。用户可以通过替换 Prompt 里的关键词，在继承参考图风格的同时，指向不同的结果，形成 Prompt 的组合矩阵，进一步拓展生成结果的多样性。例如，在生成打斗场景图时，通过修改 Prompt 中的关键词，如 “激烈打斗”“轻松打斗” 等，可以生成不同氛围和情节的场景图，且都带有参考图的风格特征。\n兼容性强 适配多种基础模型：IP-Adapter 基于预训练的文本到图像扩散模型开发，具有很强的通用性和兼容性，可以适配 Stable Diffusion 等多种基础模型，而无需针对不同的基础模型进行重新训练或调整. 可与 ControlNet 等结合：能够与 ControlNet 等其他可控生成工具结合使用，实现更强大的图像生成控制能力。比如，通过 ControlNet 可以对生成图像的线条、边缘等细节进行控制，再结合 IP-Adapter 的风格迁移和内容引导，能够生成更加精细、准确且符合风格要求的图像。 模型参数小 IP-Adapter 本身的模型参数只有 22M，存储占用小，对硬件资源的要求相对较低，在普通的硬件设备上也能够较为流畅地运行，降低了使用门槛，更便于广泛应用和推广。\n方案选择 最终还是决定先用 IP-Adapter 来推进。\n","date":"2024-12-01T11:29:47+08:00","image":"https://cdn.jsongo.top/banners/3c463375cc35ddc5e78d71b95ddcbd51.jpeg","permalink":"https://www.jsongo.top/articles/ipadapter-lora-controlnet/","title":"图像生成：角色场景形象适配"},{"content":"Flux 基础 Flux 是多模态和并行扩散 Transformer 块的混合架构，拥有 120 亿参数，是目前最大的开源文本到图像模型之一，能够生成高质量、细节丰富且风格多样的图像。\n性能和效果可以与 Midjourney V6 媲美。\nFlux 一般通过 ComfyUI 来调用。\n黑森林实验室与团队背景 核心成员：黑森林实验室由 Stable Diffusion 的核心开发者 Robin Rombach 领衔创立，团队成员大多来自 Stability AI，如 Andreas Blattmann、Axel Sauer 等多位原 Stable Diffusion 项目的关键人物，他们在生成式模型开发领域经验丰富，为 Flux 的诞生奠定了坚实基础。大家可能听说过 Stability AI 团队内部不和，各种破事把公司折腾得够呛，所以由原班核心人马出来创业做的 Flux 受到很大的关注。 融资情况：这个实验室已获得 3200 万美元的种子轮融资，由著名风投机构 Andreessen Horowitz (a16z) 领投，多位业内知名人士参与投资，充足的资金支持使其能够大力推进模型的研发与优化等工作。主要还是因为它的背景实在太好了。 Flux 模型特点 架构与参数：Flux 基于多模态和并行扩散 Transformer 块的混合架构，拥有 120 亿参数，是目前最大的开源文本到图像模型之一。这种架构和庞大的参数规模使其能够学习到更丰富的图像特征和语义信息，从而生成高质量的图像。 性能优势： 图像质量：在视觉质量、图像细节和输出多样性等方面达到了新高度，生成的图像更加逼真、细腻，细节丰富度高，风格多样，能与闭源的 Midjourney v6.1 模型不相上下，甚至在一些方面表现更优，如复杂场景生成、人物细节处理等。 提示词遵循能力：对提示词的理解和遵循能力很强，能够准确地根据输入的文本描述生成符合要求的图像，包括对复杂指令、长文本描述以及特定场景和细节要求的准确呈现，减少了因提示词理解不准确而导致的图像与预期不符的问题。 文字生成能力：在图像中生成文字的效果出色，可以处理重复字母等棘手情况，生成的文字内容准确、排版合理，这在一些需要在图像中呈现文字信息的场景中具有很大优势，如生成带有文字标识的产品图片、包含文字说明的场景图片等。 手部细节处理：相较于之前的一些模型，Flux 在手部细节生成上有了显著改进，减少了手指等部位的畸形或错误，使生成的人物图像更加自然、真实。 不同版本特点：\n有 3 个核心版本，Pro/dev/schnell FLUX (pro)：闭源模型，自家压箱底的货。具备最佳性能，包括最先进的提示跟随能力、视觉质量、图像细节和输出多样性，适用于专业用户和对图像质量要求极高的场景，可通过注册官方 API 申请访问权限，同时支持企业定制。 FLUX (dev)：开源模型，不可商用，直接从 FLUX (pro) 蒸馏而来，具备相似的图像质量和提示词遵循能力，但更高效，适合开发者进行研究和实验等非商业用途的使用。 FLUX (schnell)：开源模型，可商用，专门为本地开发和个人使用量身定制，生成速度最快，内存占用最小，是个人用户体验和进行简单开发测试的不错选择。 ","date":"2024-11-24T23:31:34+08:00","image":"https://cdn.jsongo.top/banners/2679aa8e01ac3a9721f4b6f4e919a651.jpg","permalink":"https://www.jsongo.top/articles/flux-101/","title":"Flux 图像生成模型"},{"content":"Diffusion（扩散模型）是一类生成式模型，在机器学习和人工智能领域应用广泛，特别是在图像生成、语音合成等领域发挥了重要作用。\nModel \u0026amp; Checkpoint 开源模型发布出来的文件一般都很大，里面包含了很多模型参数、快照等。Model 和 checkpoint 在开源这个层面上，两个概念可以认为大体上是等价的，只不过我们一般不叫 checkpoint，而是说某个 model 开源了。\nModel 是一个比较抽象的概念，它包括模型的架构（例如神经网络中的层数、每层神经元数量、连接方式等）和训练目标（例如是进行分类任务、生成任务还是回归任务） Checkpoint 是在模型训练过程中定期保存的模型参数快照，与 Model 密切相关。Checkpoint 包含了 Model 的架构定义、参数值、优化器状态以及训练过程的元数据等，是对 Model 在特定训练阶段状态的完整记录。 CLIP 概念 CLIP 模型：CLIP 是 Contrastive Language-Image Pre-training 的缩写，由 OpenAI 在 2021 年 1 月 5 日发布，是一种将计算机视觉与自然语言处理相结合的神经网络模型。 它通过对 400,000,000 组（图像，文本）对数据进行预训练，从而能够在给定图像的情况下，根据自然语言指令预测出最相关的文本片段，展现出了类似 GPT-2 和 GPT-3 的 zero-shot 学习能力，即模型可以在未针对特定任务进行直接优化训练的情况下，对未曾见过的数据类别进行较好地预测 CLIP Vision：CLIP Vision 主要负责处理视觉信息，也就是对输入的图像数据进行特征提取和编码等操作，将图像转化为模型能够理解和处理的向量表示，以便与文本信息进行对比学习和关联。1 例如，在图像生成领域，CLIP Vision 可以帮助模型理解图像的内容和特征，从而生成更符合语义描述的图像。 CLIP Text：我们常看到的这个 CLIP Text 概念，主要是指作为参考文本来对图像进行调整的文本描述。 应用 图像生成：如在 Paints-Undo 项目中，CLIP Vision 作为模型架构的一部分，与其他组件共同作用，通过对输入图像的处理和分析，为生成模拟人类绘画过程的动画提供视觉信息基础，帮助模型理解图像的内容和结构，从而更准确地生成绘画过程中的各个中间状态。 图像分类与标注：可以根据图像的视觉特征，结合预训练时学习到的图像与文本的关联，对未见过的图像进行分类或自动生成相应的文本标注，例如判断一张图片是风景照、人物照还是动物照，并给出相应的文字描述。 图像检索：基于 CLIP Vision 对图像特征的提取和与文本的关联能力，可以实现根据文本描述来检索相关的图像，或者根据图像来查找与之语义相关的文本信息，提高图像检索的准确性和效率。 视觉问答系统：帮助系统理解图像中的视觉内容，结合对自然语言问题的理解，生成准确的文本答案，例如回答关于图像中物体的位置、颜色、数量等问题 。 VAE VAE 主要用于将图像数据压缩到一个潜在空间，然后再从这个潜在空间中生成新的图像，侧重于图像的生成和重建。\nLatent Image 经过某种变换或编码后隐藏在数据中的图像信息。例如，在使用变分自编码器（VAE）进行图像生成或处理时，图像数据会被压缩到一个潜在空间（latent space），这个潜在空间中的向量可以被看作是潜像的一种表示形式。这些潜像向量包含了图像的关键特征，如形状、颜色、纹理等信息，通过解码器可以将这些潜像向量转换回可见的图像。\nLora LoRA 是一种用于微调预训练模型的技术，通过在原始模型的基础上添加少量可训练的参数来实现对模型的微调。\nFootnotes 简单说就是，主要用于处理和理解图像信息，能够提取图像的特征表示，进而与文本特征进行对比和匹配等操作，以实现如根据文本描述生成相应图像、图像分类、图像检索等多种与图像和文本相关的任务\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-11-24T11:26:10+08:00","image":"https://cdn.jsongo.top/banners/96539755245eb88510f037ed2d24f60d.jpeg","permalink":"https://www.jsongo.top/articles/diffusion-101/","title":"初识 Diffusion（概念）"},{"content":"一个很普通的程序员，喜欢折腾，喜欢看书和思考。\n","date":"2024-11-22T00:48:28+08:00","image":"https://cdn.jsongo.top/2024/11/57bb06afa963ce540f0629c84f866978.png","permalink":"https://www.jsongo.top/about/","title":"About me"},{"content":"概述 背景 Stable Diffusion 最初是由德国慕尼黑大学的 CompVis 研究小组、纽约的 RunwayML 公司等组成的国际研究团队开发的，后来 Stability AI 参与其中并推动了其发展。\nStable Diffusion 的发展历程如下：\n技术简介 Stable Diffusion 在模型架构中采用了 Transformer 架构的一些特性，基于扩散模型架构来生成图片。\n它的原理用白话说，比较简单：加噪和去噪（专业术语叫前向扩散和反向扩散）。加噪后的图片主要用于训练或作为初始输入（latent），然后训练一个模型去实现某些图像生成目标（去噪过程）。\n前向扩散：在前向阶段，通过向原始图像数据（如真实的照片或绘画）添加噪声，逐步将图像转换为纯噪声。这个过程是在多个时间步（time - steps）中完成的，每一步都按照一定的规则（通常是基于高斯分布）添加噪声，使得图像信息逐渐被噪声掩盖。例如，开始时图像可能还比较清晰，随着时间步的增加，图像越来越模糊，最终变成完全的噪声。 反向扩散：这是生成图像的关键阶段。从纯噪声开始，模型通过学习到的去噪过程，逐步恢复图像信息。模型会预测每个时间步中需要去除的噪声，经过多个时间步的迭代，最终生成一张类似于训练数据分布的图像。这个过程类似于从无序的噪声中逐渐 “雕刻” 出有意义的图像。 生图过程 模型 （Checkpoint）跟采样的关系 Checkpoint 包含了模型在特定训练阶段的所有权重、偏置以及优化器的状态等信息，而采样模型的参数是由 Checkpoint 所确定的，采样模型使用该 Checkpoint 中存储的权重和其他参数进行计算。不同的 Checkpoint 会导致采样模型在生成图像时表现出不同的性能和风格。例如，某些 Checkpoint 可能侧重于生成高分辨率的图像，而另一些可能更擅长生成具有特定艺术风格的图像。这是因为在训练过程中，不同的 Checkpoint 所对应的训练数据和训练目标可能有所不同，从而影响了采样模型的行为。\nCLIP Text Encode 属于 Condition 节点，它用 CLIP 模型对文本 Prompt 进行编码，对模型生成的结果进行方向上的引导，其实可能理解为文本模型中的 embedding。\n采样 生图其实就是一个反向扩散的过程，从一个完全是噪声的图像开始，通过模型逐步去除噪声来生成图像。这个过程通过一个采样函数来实现，它基于模型预测的噪声来更新噪声图像。\nSteps，迭代生图，每次更新噪声图像，需要经过多个 Step 的迭代。随着 Step 反复执行，图像中的噪声逐渐减少，最终生成一个近似原始图像分布的图像。不过生成的图像质量可能会受到多种因素的影响，如模型的性能、采样方法、时间步数等。在实际应用中，可能需要对生成的图像进行后处理（如调整颜色、对比度等）来提高图像质量。 seed，种子值，用于初始化随机数生成器。相同的种子值在相同的模型和参数设置下会生成相同的图像，这有助于复现结果。 control_after_generate：这个参数可能与生成后的控制操作有关，例如对生成的图像进行随机化处理 steps：指生成过程中的迭代步数。步数越多，生成的图像通常会越精细，但也会增加计算时间。 cfg（Classifier-Free Guidance）：无分类器引导的强度，它是一种在生成式模型（如 Stable Diffusion）中用于引导图像生成方向的技术，决定了模型在生成图像时对正向提示（你希望在图像中出现的内容）的遵循程度。较高的 CFG 值会使生成的图像更紧密地遵循正向 Prompt，但也有可能导致图像过度拟合。 取值范围： CFG 的值通常在 1 到 20 之间，理论上可以取更高的值，但在实际应用中，过高的值往往会导致图像质量下降。 较低值（1 - 4）： 当 CFG 值较低时，生成的图像会更具随机性和创造性。模型对正向提示的遵循程度较弱，因此可能会生成一些与提示不太相关但具有独特创意的图像。这种情况下，图像可能会包含一些意外的元素或风格。 中等值（4 - 10）： 在这个范围内，是比较常用的取值。模型会在遵循正向提示和保持一定的创造性之间取得较好的平衡。能够生成与提示较为符合的图像，同时也不会显得过于刻板。 较高值（10 - 20）： 当 CFG 值较高时，生成的图像会非常紧密地遵循正向提示。这可能会导致图像过于 “完美” 地符合提示，但也可能会出现一些问题，比如图像的细节可能会显得不自然，色彩可能会过于饱和，或者图像可能会失去一些自然的随机性和美感 sampler_name：这是指采样器的名称。不同的采样器（如 Euler、Langevin 等）有不同的特性，会影响图像生成的速度和质量。 scheduler：调度器，用于控制生成过程中的步长和其他参数。不同的调度器会影响生成的效率和结果。 denoise：去噪参数控制生成过程中对噪声的去除程度。较低的去噪值会使生成的图像更具随机性，而较高的值会使图像更平滑和可预测。 VAE Decoder（变分自解码器） 图像数据往往是高维的，包含大量的像素信息，所以一般训练和计算时，往往要压缩到低维来处理，用更紧凑的方式表示图像的关键特征，就像文本模型中的 Embedding 处理，变成稠密的数据，在图像处理领域叫潜在空间（Latent Space）。而解码器则是将潜在空间中的表示再转换回图像数据空间，尽可能地重建原始图像。\n生成新图的过程，由于潜在空间是连续的，稍微改变潜在空间中的向量值，就可以生成与原始图像在某些特征上有所变化的新图像。例如，在生成人脸图像的 VAE 模型中，在潜在空间中沿着某个方向移动向量可能会改变人脸的表情、发型或者年龄等特征。\nLatent Image 一般在整个 ComfyUI 流程中，会插入一张空的（Empty） Lantent Image，它提供了一个初始的 “画布”，让模型在这个基础上进行生成或转换操作。\n当然如果是对已有的图片进行调整、修复或优化，则可以把空的图换成一张现成的图片，这时就要把它加载并转换为合适的潜在表示形式后，可以作为生成过程的起点。在 ComfyUI 中，可能涉及到将图片通过适当的预处理步骤，如调整大小、归一化等操作后，然后将其编码为潜在空间中的表示，这样就可以基于已有的图像内容进行修改、风格转换或者其他生成操作。\nStability AI 官方 Stable Diffusion 的官方可用的模型，可以从 API 文档中看到： Stability AI - Developer Platform。最新的是 SD 3.5（2024 年 11 月）。\n1 credit = $0.01 这么算，生成一张 SD 3.5 的图片，medium 要 $0.035，差不多 0.25 元，4 张 1 块。\n体验 Free AI Image Generator - Turn Text to Image Online | Stable Diffusion Online\n字节的 Lighting 模型 ByteDance/SDXL-Lightning at main 字节的这个模型生成效果相当不错。\n它同时提供了 Full UNet 和 LoRA 版本，都是相对比较小的蒸馏模型（虽然 UNet 也有几个 G）。\nWe provide both full UNet and LoRA checkpoints. The full UNet models have the best quality while the LoRA models can be applied to other base models.\n小科普（可跳过） 概念 UNet 是卷积神经网络（CNN）的一种特殊架构，在生成对抗网络 (GANs) 和扩散模型中广泛使用。它是一种完整的网络架构，专门用于图像分割任务，从输入图像到输出分割结果，有自己独立的结构和训练流程。 LoRA 不是一种独立的网络架构，而是一种模型微调策略，可以应用于各种现有的预训练模型（包括但不限于基于 UNet 架构的模型），用于在不大量修改原始模型结构的情况下进行任务适配。 从参数规模与训练成本来看 UNet：在训练过程中，需要对整个网络的参数进行学习和更新，尤其是在处理高分辨率图像或复杂任务时，可能需要大量的训练数据和计算资源。 LoRA：通过低秩分解减少了需要训练的参数数量，在对大型预训练模型进行微调时，训练成本显著降低，对数据量的要求也相对较少。\nUNet 的模型一般都比较大：\nLoRA 则小很多\n使用 它们都有 2-Step, 4-Step, 8-Step，其中 1-step 只是实验性的、效果不好、质量不稳定，一般建议用折中的 4-step，如果资源充足可以选质量最好的 8-step。\nComfyUI 中的使用非常简单：\n如果只是想玩玩，可以直接在 huggingface 上试试：SDXL-Lightning spaces ，效果还是不错的：\n","date":"2024-11-19T16:36:27+08:00","image":"https://cdn.jsongo.top/banners/772c64fbb07e3cd46573602f922a7829.jpg","permalink":"https://www.jsongo.top/articles/stable-diffusion-gen-image-1/","title":"Stable Diffusion 生图技术（一）"},{"content":"成本思维 大多数看起来有所利益的事情，肯定有成本，而且有风险。风险本质上也是一种成本。\n用成本 + 风险的思维来看问题，不要只想着好处。成本和风险往往是在巨大的利益面前，特别容易被忽视的东西。\n塔勒布在《非对称风险》中表达了一个观点，他反复提到在真实的世界里，一定要风险共担，如果有人不愿意承担风险，却要享受好处，这样的人是有问题的。\n企业最大的成本，是老大的决策成本 如果动不动就来个调整，发现不对，马上再折腾几回，这损耗的是非常大的。决策成功率越低，企业就会被越来越快消磨掉。我们说大公司病，其实有一层逻辑是：公司小的时候，10 个决策中，有一两个正确的决策可能就能把营收和规模做上来；但当公司越来越大的时候，10 个决策中如果有一两个决策做错了，那都是在损耗。所以大公司病往往不是因为决策人变笨了，而是企业到了那个阶段，决策的成本变高了。\n看过一篇文章《只有10%的产品值得用AI再做一遍》，标题就直接表明了作者的观点。文中提到了 AI 时代，各大厂争先恐后地攻城略地，但后来发现，做了很多产品功能都是徒劳，浪费了很多资源。比如：\n支小宝虽有创意但操作路径复杂且多数功能未发挥 AI 能力； 如果我用支小宝坐公交，我需要把 APP 打开，点开对话，再输入指令“我要坐公交”，等待 2-3s 加载出来，这个过程至少需要 5s 以上。\n实际上，用手机的 NFC 直接刷码上车，不需要打开任何 App 就完成了这个操作。\n淘宝问问、京东京言等电商 AI 助手功能空泛、多轮对话理解能力差且 AI 划重点功能无实际价值； 饿了么的 AI 评价总结功能上线又下线，因为既无价值还浪费费用； 携程问道生成的内容干巴巴且缺乏实用性。\n这些都表明很多产品为跟上 AI 潮流而做 AI，未解决用户痛点，在未成熟阶段盲目投入，造成大师的资源浪费。\n当然也不能说探索就是浪费，只是想表达决策是需要成本的，而且经常是最大的企业成本。 制度本身也要成本 坏的制度增加企业成本，而好的制度是降低企业成本的。\n制度虽然有时让人诟病，但它们能带来一些确定性。一个集体如果制度有问题，一方面在遇到事时，经常会有模棱两可的疑惑，直到有个人做了表率，其它人慢慢地也跟上了。到后来，大家苦于不合理制度的约束，他们可能会不断地试探，直到看到不好的信号或良心觉得不妥，从而确定了一个心里底线，形成了自己的“制度”。\n刘润讲到一个案例：一家文化教育的企业，老板从来不管教学质量，这家公司里的老师能偷懒就偷懒，因为没有制度去管理他们，慢慢的好老师就都走了，留下的越来越烂，这是会传染的。\n问题制度带来的成本，就是人才流失，导致最后没有优秀的人来高效的做事，成本急剧增加。\n题外话，刘润在书中提到，对公司的管理的三种手段：\n鼓励白，即激励一些对的事； 压缩灰，即用文化作为共同的价值观，给大家一个底层的判断标准，从而遇到模棱两可的事时能有一个基础的良知判断； 禁止黑，即什么事一定不能做，这是一个更强硬的制度，防止公司烂掉。 团队的规模也有成本 我在之前的其它文章里提到了亚马逊的 Two Pizza team 原则：\n把整个系统拆分成微服务或独立模块，不同的 team 各负责一个单位的事情。Two Pizza team 是指用两块 pizza 就能吃饱的团队规模，一个业务的团队超过了这个规模，信息传递的成本就很高，沟通协作就变得困难。\n小团队沟通高效，目标也容易对齐。团队大了经常要各种对齐，很多时间花在开会上。很多会都是用来同步信息的，没有它们反而可以跑的更快。所以团队规模越来，沟通协作的成本越高，这些都是决策时要考虑的成本问题。\n机会成本 那些看似免费或便宜的东西、或能直接带来利益的事情，往往也是有机会成本的。你可能要花挺多时间在上面，研究它到底对你有没有用，是忽悠人还是可能有少许好处可以捞。\n总之不管什么样的情况，你总需要付出时间，要拿机会成本来换，而且很多并不划算，你完全可以拿这些时间来做更有价值的事情。\n忘了哪本书里提到：\n你得到的越多，选择放弃的机会成本就越大，就越不敢往前走，就越需要勇气和智慧。\n另外还有社交，也是要成本。放弃无效社交，它们会占用你原本可用于提升自己的时间。\n总之，如果尝试用成本思维去思考下，你很可能会得出不一定的决策。\n阅读 这周还在阅读子皮的《价值生长》。再分享一个有趣的观点：人一辈子抓住几次机会就够了，不用怕有什么好机会在眼前错过了。\n永远把质量排在第一位，弱水三千，只取一瓢。在自己擅长的领域，找到绝对信任的人、靠谱的事，哪怕只搭上一趟火箭就够了。\n买股票也一样，不要怕错过什么妖股、潜力股，那太多了。全都要的话，你的钱根本不够用，也不用天天去刷 K 线、抢先看新闻、生怕错过，找到一些真正有价值的，投入并在一段时间内看好它、坚定持有，长期看是会给你带来回报的。\n不过不管怎么样，保住本金还是第一要务，不要乱投，耐心地蹲守、观察，找准时机再动手。\n投资的第一条原则 ，永远不要失去本金；第二条原则，牢牢记住第一条。—— 巴菲特\n","date":"2024-11-03T13:35:12+08:00","image":"https://cdn.jsongo.top/2024/11/053cc313b6d764b5ee7d6b645fdca2bc.jpg","permalink":"https://www.jsongo.top/articles/thoughts/cost-thinking/","title":"成本思维"},{"content":"一、如何阅读 避免做题式的阅读，那到底要怎么读，怎么用这个方法来改变我的阅读习惯？ 避免备考式的阅读 之前看书，大都是从头看到尾，没意识地想去把整本书的结构都理清楚，最后还会把所有的重点都整理出来、形成一个比较大的笔记。\n最近在阅读《打开心智》，里面提到的不太好的阅读习惯，貌似每条都在说我。想想确实很有道理，不过主要还是习惯、观念和心态的问题。观念是可以改变的，但就是比较顽固；习惯则可以通过培养和践行新习惯来覆盖；而心态可能就是一个需要比较漫长的磨练，才能去改变的。\n书里主要提倡“以我为主，为我所用”的阅读习惯。书中内容的结构、甚至作者的看法都不重要，我自己的看法才重要，也就是它对我的思维造成了什么影响，给我带来了什么帮助。\n书中提到一个“计数器陷阱”，讲的是太过追求数量，设置错了目标（即使也是按 smart 原则来制订的）。“为我所用”才是真正的上的。\n不要去追求看完、看几本，这些数量并不是我的目的，但我之前常把它们当目的。\n也不用追求把一本书里的知识全掌握，这不是在备考，可能我们都没太注意到，中学时留下的一些习惯一直跟着大多数人。除非看那种比较体系的教材去体系化的学习。大部分书，挑对自己有用、自己感兴趣的部分去阅读就好，或者每个阶段都有自己感兴趣的主题，可能后面还会翻到这本书。\n主动式地学习：经验 -\u0026gt;提炼 -\u0026gt;看书完善 -\u0026gt;强化方法论 作者在书中给了一个模型：\n![[assets/local_image_plus/7854b0e4882ba4957ecba9e5d142f1fd_MD5.jpg]]\n从实践运用中去获取一些经验，提炼出思维模型或行为模型，然后通过阅读去完善这些模型，甚至去完全纠正。不过也没关系，有了实践，再去思考，肯定会比光思考深刻很多，理解的更透。\n带着问题去阅读，是主动式学习的最好方式。开始看一本书的时候，先通过目录去思考有哪些内容跟我现阶段感兴趣的事情相关，我想通过阅读它来弄懂什么问题，就比如现在的这个过程，就是在回答一个问题。最终我要能得到一个答案，可能是一个观点，也可能是改变我习惯的方法，也可能是一种新的思维，也或者是打开了一个新领域的知识，让我产生了新的兴趣，开始系统地去学习，等等，这些都是收获。\n作者的例子 他发现自己的知识不成体系，怎么整理好像都没用。于是通过实践思考总结出了需要让知识流动起来才有用，于是去学习了 GTD 的方法（通过阅读等），把里面的思想和理念跟自己的想法结合，总结出了一个知识管理模型。后面的阅读、思考过程中，都在完善他的这个模型，得出自己实用的方法。\n想法 或许可以把我收藏的书的目录，收集起来，然后喂给大模型，未来想看某些主题的时候就让大模型去帮我找出合适的章节。可以在 coze 上去实现这个功能。 用 python 写，去抓微信读书上的内容 展示的时候，让大模型做下格式化 我把相关的书发给它，它给我返回列表，我选择相关的书籍查看目录结构，然后能导入我的知识库，直接做向量化，后面用于做检索 检索也在 coze 上面实现，可能得想想怎么打通到知识库，动态补充 如何通过边阅读边思考来记忆知识点，而不是读过就忘了，另外怎么把这些知识点形成体系结构 关于记忆 3 种阅读方式：照抄、看结构回忆，以及完全自由的回想。\n第一种，基本都没怎么经过思考，也是我之前做读书笔记的方式，一直想去梳理出书的结构、以及作者的写作思路。但这些真的重要吗，我去了解书的结构干嘛，要理完整个结构那就是要通读整本书。但真没太多必要，理完也没怎么思考，就是整理出了一个文档，平时需要的时候可以查看，把纸书电子化了，也自己结构化了一遍。 第二种 ，看结构（脑图、目录等）去回忆，这里面也是有一点想把整个知识点都消化掉的思路。刻意去回忆，确实能加深记忆，不定时地去看，根据记忆遗忘曲线是可以记住更多的内容。不过想想，这不就是备考的思路吗，为啥要去背知识点呢？背不是目的。 第三种，自由回想，一方面把一些记忆深刻的点 recall 出来，另一方面自由地随想，可能会创建一些意外的关联。还有一点更重要的是，想到一些点，就要去结合自身的行为、习惯、思维方式去思考，要有一些收获，或者改变，可能是行为习惯上的、也可能是思维方式上的，能有一些不一样的收获就好。 知识结构 读不同的知识点，可以逐步地完善自己的知识结构。这个词我的认知一直是构建一个脑图，把不同的知识点、结构分支等整理上去，形成一个树状或网状的结构。后者没法用脑图表示。\n那有什么软件或工具能更好的描绘出我的知识结构呢？\n理下目前知道的工具主要有：\n飞书画脑图工具、processon 的脑图，这两个可以画回路； 标签体系，如 flomo，可惜它没有可视化，只能通过点标签目录去大概看出网状，而且是得用标签查询去找线索；\n![[assets/local_image_plus/65355c728f54c7468e9b262411f74a72_MD5.jpg]]\n←像这种标签树，看起来也是一种可视化，但它有两个问题，一是只是一个图，没法链接；另一方面是它没法通过两个标签来定位一个知识点，即没法网状地找东西。 flowUs 的脑图，每个节点都是一个 block，这个很创新，可以建立很多链接，我觉得是一个不错的建立知识库的工具，不过可能要实践探索一下，目前还没有比较系统的思路。 心态 没必要去记住或用上书里提到的每一个知识点，这不是要去考试； 书不要看完，培养自己能释怀的心态，不要老追求从头到尾读完每一本书，这中间会浪费很多时间，虽然这样经常会有一些额外的收获，但就像刘润讲的，从沙子里挑出较大的金子，其它较细的金沙没必要去慢慢抠，读书是淘金，而且密度很高，但粒度不同，书有很多，没必要每次都要把金子收集干净； 正确的使用知识 获得核心的知识点，与自己结合，给自己带来收获或改变 数据和细节等，记到一个笔记里就行，后面通过 AI 来对接，让 AI 帮你 retrieve，不用去记 大知识点形成结构，笔记里画脑图记下来，链接起来，不求多，这主要是为了形成更深刻的知识结构，时不时看，在脑子里刻下来 弄个工具去查找未接触的知识或内容，如书籍，向量化并通过 AI 来查找\n之前看书，大都是从头看到尾，没意识地想去把整本书的结构都理清楚，最后还会把所有的重点都整理出来、形成一个比较大的笔记。\n最近在阅读《打开心智》，里面提到的不太好的阅读习惯，貌似每条都在说我。想想确实很有道理，不过主要还是习惯、观念和心态的问题。观念是可以改变的，但就是比较顽固；习惯则可以通过培养和践行新习惯来覆盖；而心态可能就是一个需要比较漫长的磨练，才能去改变的。\n书里主要提倡“以我为主，为我所用”的阅读习惯。书中内容的结构、甚至作者的看法都不重要，我自己的看法才重要，也就是它对我的思维造成了什么影响，给我带来了什么帮助。\n书中提到一个“计数器陷阱”，讲的是太过追求数量，设置错了目标（即使也是按 smart 原则来制订的）。“为我所用”才是真正的上的。\n不要去追求看完、看几本，这些数量并不是我的目的，但我之前常把它们当目的。\n也不用追求把一本书里的知识全掌握，这不是在备考，可能我们都没太注意到，中学时留下的一些习惯一直跟着大多数人。除非看那种比较体系的教材去体系化的学习。大部分书，挑对自己有用、自己感兴趣的部分去阅读就好，或者每个阶段都有自己感兴趣的主题，可能后面还会翻到这本书。 二、构建知识体系 怎么构建自己的知识体系 － INKP 作者提出了 INKP 理论，我再结合最近在使用的 flowUs 软件，做一些梳理和结合，给一些实践和方法。\nInbox 阅读时，有一些好的点子或想法，都可以快速放到 inbox 里，一条一条记 可以创建一个页面，也可以用 flomo 来写。这里涉及到一个观念：创建页面感觉比用 flomo 快速在输入框里写一条记录更重些。为什么会有这种感觉，我想主要还是因为页面里，整个区域都是输入区，给人比较大的压力，觉得要写很多才不会浪费；而 flomo 像聊天窗口一样，只有底部有一个输入框，看起来压力很小，就是记录一张小卡片。另外 notion 类软件也是要删除两次才能彻底删除，简单的删除，它的链接什么的都还在，还可以打开这个文档，而且“最近打开”的列表里还有它，总感觉它还在占着空间。 平时突然有一些好想法，也可以写到这个 Inbox 里 Note 主要就是记录一些概念，最重要的是，得经常去整理 inbox 的内容，把相关的概念弄清楚，然后打上一些标签之类的 所以是不是 inbox 和 note 都用 flomo 来记，然后整理好的、比较确定的概念都落到 notion 类的笔记软件里，这些概念后面可能会被引用 Knowledge 实际上就是一个主题，比如“克服拖延”、“情绪”、“专注力”，它也是一个独立的页面，所有跟这个主题相关的，如果比较小，可以直接写进去，如果内容比较多，则可以链接进去。 这个 knowledge 页面，就是这个主题的根据地，所有跟它相关的都要可以在这里找到 这页面也要抽时间去做些结构上的整理，比如可以弄个脑图，或者整理下目录结构。flowUs 的脑图是一个非常好的工具，它每个节点是一个 block，可以做一些链接，让知识形成树状，同时链接也能把各个地方的知识连到一起，形成网状。知识树、链接网。 如果一个概念，是跟这个主题相关，但又不太好归类或嵌入到架构合适的地方，那可以在页面底部加一个相关知识点，把这些整理进去。这样至少能保证相关的内容，都可以在这里找到的。 用主题的方式，而不是标签的方式来关联，好处是它会被整理成一个整体，标签拉出来的笔记列表，它没法调顺序和结构，只能是一堆知识堆积，所以卡片笔记也是有弱点的。缺点就是得花时间去整理。 主题页面，需不需要整理的很正式、甚至可以拿去发表的呢？其实有两种情况，一种是主题本身就比较简单，整理出来的东西，如果时间充足，就可以优化下表达、整个就是一篇可发表的小论文；另一种情况是，这个主题很复杂，还要添加很多知识才能看起来是完整的，要不读起来感觉东缺一块、西漏一些，整篇内容就显得不严谨。后面这种情况，结构整理起来也会比较复杂，可能会经常调整，随时都可能有变化。 所以如果要发表的话，直接用笔记是最合适的，flowUs 是可以，不过有个小问题是，所有的改动马上就直接发出去了，缺少一个发布的动作；notion 也有这个问题，语雀和印象笔记可能好一些，但印象的性能/体验实在不太行。 Project 由多个主题汇总而成， 当然这些主题也需要有关联，而且要能形成一个更大的知识体系。 比如原则 2（应对变化中的世界秩序），把政治秩序、经济周期结合起来，通过对周期规律的分析来预测当下的环境、以及未来的发展趋势。经济周期里，包含了货币、信贷和经济活动等，每个都是一个大主题；而政治秩序双分为了内部秩序（内部的政权迭代）、外部的政治环境等等，每个也是一个主题。这么多主题最终形成了一个大周期的理论，它们之间的关系不是平铺的，而是有点树状的结构 实践 INKP 基本操作流程 平时有什么不错的输入，或好的想法，先记录到 inbox 笔记中，比如我的“随手记”目录中。快速写下当时触动我的点，简单些，也可以只写关键字。重要的是后面能明白是什么，以及不要打断太久当前的阅读。重在快速和写对点。\n接着，晚上的时候，在书桌前打开电脑后，就先一个个的过 inbox，扩写下，补充查询些资料，升级成理论或概念，抽象出核心观点短语作为标题，从 inbox 移出，放到具体的分类目录里。如果跟某个主题相关，那么可以整个进去，看是在主题结构的哪个位置，整理整理。但如果是一个新主题，可能就要新建一个主题页面。\n如果是比较大、比较复杂的概念，则可以在标题上加个待处理的标识，等周末或工作日有空时统一处理。\n建立关联很重要，一方面是上文提到的归入某个主题，另一方面也有可能只是跟某个概念有关，那就找到相关的那个概念笔记，链接进去，notion 类产品会在底部显示本文档被那些地方引用，所以其实可以在目标概念文档、或主题文档中，通过行内链接的形式把文档关联进去。\n周末抽半小时到一小时整理这周的待处理，查资料、问 AI，或者找视频资料等，学习并整合进去。如果发现某个主题比较完善，可以把它发表出来，如写入 thinking 或整理成一个主题分享，用费曼学习法反推自己更深入、更及时地学习下这个主题，沉淀下来，分享出去。\n作者还有一个方法，为了避免笔记太多、内容太重复、知识层级太深或叶子结点过多，他每整理完一个概念笔记，或某些主题笔记，不再直接用它时，就把笔记归档。我理解这个归档其实可以平铺放入一个 archived 目录下，里面的东西不是没用，而是不会再直接去打开它，只会通过知识框架链接进去找他。这个方法很重要，要不然知识架构，跟目录就完全脱节，得另外维护一个脑图等，同步是个问题，不过也可能是更好的办法，这个得通过实践去看看哪种更适合自己。\n可以把某个主题的笔记的复习任务，安排到某周的待办事项里，挤时间去整理它。要认真去经营自己的知识结构，回顾或复习，也不能漫无目的、随机的复习，平时整理笔记的时候，总会想到哪个主题最近得再复习整理下。\n最后，项目是解决一个问题，比如提高自己的工作效率，涉及几个主题，去专注力、咖啡的研究、某个技能 等。\n一个项目，可以有一些基础的配置：计划、方案或思路等，都可以链接到这个主页里。\n当我在进行一个项目时，其实可以把 inbox 分个专业的类别，在 inbox 目录里，以项目或主题来全名。这样收集到的信息都会收敛到里面，晚上在整理的时候也能在 inbox 里看到他们。\n主题和项目有什么明显的区别，怎么区分呢 综合下，上面其实陆陆续续提到了一些。\n主题一般是一个比较小的话题，可能就是一个点，里面可以有多个概念 (note)，它们聚合起来充分地解释了这个主题的各个方面。 例子先说 note，即概念，如精神内耗，这是个什么概念，有什么危害，我有没这方面的问题，要怎么避免 然后就是主题，上面这个概念，可能涉及到生活质量、拖延、情绪调控等主题，如生活质量这是一个我追求的主题，里面肯定会涉及到“精神内耗”相关的东西，所以在生活质量的主题下，就会把精神内耗链接进去（行内链接）。 项目，则是一个动作或一个很大的主题。 例子：品质生活，涉及精神层面的提升生活质量，也涉及改善生活条件（居住环境、财务情况等），这个项目就要多个方面去推进。 我其实还有一个领域的概念，它是某个方面的东西聚焦，比如家族、生活、读书笔记等，它们不是主题、也不是项目，不太好归类到里面去。它们往往是一个较大的同一类型的内容集合，跟项目可能就是平行的关系，并不是包含关系。\n作者给的另一个比较形象的例子：看到一篇讲“会员积分体系”的文章，开一个 note 记录下，然后里面没讲清楚的地方，还可以继续查更多的资料（最后加一个参考资料的部分）。然后整理的时候，想到会员积分体系，其实是一种“激励”，也是一种“游戏化”、“增长黑客”等主题里的知识点，于是链接进去。后来，作者想起一个项目，做一个“内容社区”，这时这相关的主题也都可以引用到，基于相关的主题可以做些什么方面的规划和设计。\n另一个例子，比较简单，即睡眠 (K) 这个主题，下面包含了“晨型和夜型”、“睡眠周期”、“睡眠对记忆的作用”、“睡眠与情绪”、“为什么我们需要睡眠”等这些概念 (N)。\n主题构成了我们知识体系的主干，而概念则是比较零散的知识点小枝叶，没有主干来组织，就是散落一地的枝条叶片。而项目则是做一张桌子，它可以从这棵树上切一条枝干做桌腿，从另一个更粗的树干中切出一片桌面，最后组装成一张桌子（当然这个例子不一定恰当，因为并不是真的“切”，而是一种可以无限复制的副本，切掉还在的情况，因为内容不会消失。领域呢，则是一个平行的东西，它研究的是苹果树、柳树、白桦树等，跟前面讲的不是一个位面的，但也可以有相互的包含，比如白桦树干比较坚挺，更适合做出什么样的成品等。\n另外，主题、项目 一般也需要用脑图来组织。主题好理解，其实就是把树画出来（脑图跟树很像），而项目，则主要是用脑图来做一些整理，结构可能（前几层级）大体相同。这些画出来的脑图其实就是比较图形化的知识结构，好记，都是我的知识结构，打开一看就知道大体有哪些东西。 自上而下、还是自下而上 平时的记录，肯定是散乱的，这时应该是先有内容，自下而上。但其实一直是这么被动的整理，一方面知识体系不一定完整，另一方面也漫无目的、不知道什么时候是个头。所以作者给的建议是，先积累一波概念（素材），然后找个周末的时间建立主题结构，可以通过 AI 辅助、也可以请教别人，把结构画出来之后，再针对性地去研究每一个还没有涉及到的概念知识点。\n这是一种先建立框架，再填充框架的思路。把自下而上和自上而下结合起来。\n这里说的“上”是指主题 (K)，“下”是指概念或知识点 (N)。\n总结 简单一句话概括：主题是小话题，项目是一次研究或改变，领域是一个学科、或一个方面的专业知识。不一定要区分的很清楚，大概判断下就行。\n其实要建设好自己的知识体系，最最核心的还是要经常去整理，上面讨论了那么多，主要还是在讲整理的方法，如果压根就没时间腾出来去做整理，上面讲再多也是白搭。\n三、创造 作者关于创造的观点和方法是什么样的 你创造的东西定义了别人眼中你是一个什么样的人，而不是你拥有的东西定义的，拥有的只能定义出你是富人还是穷人，有什么样的品味和爱好。\n时间管理的目的，是减少要做的事情，而不是增加。把很多价值不怎么大的事情规划出去，留下能创造价值的事，然后找到效率高的时间去更好的实现它。\n创造是一种快乐，甚至是一在充实人生的意义。打个简单的比方，你去一个地方旅游，自己拍拍照，朋友圈晒一晒，这是消费的快乐，一下子就过去了。但如果你做了一个攻略，整理得自己都很满意，发布出去，别人看了之后也能得到帮助，经常有人评论或点赞，那就是创造之乐，它会持续地带来惊喜。而且这是你的一个“标志”，别人通过这个标志产生对你的第一印象。\n找到自己喜欢的事情是什么 去体验不同的事情，去接触不同的人，认识不同行业、不同思维方式的人，从他们身上找到能给你带来较持久激情、让你兴奋的事。当看到它的那一刻，你可能就知道这就是你的“公理”。所谓的“公理”是借用的数学领域的概念，公理是你不需要去证明的，它就是你的终极意义，确定下来就不用再去怀疑，遇到的事情对你来说有没有意义，反而要用这个公理去验证。\n很多人活在自己的空间里，很少走出去，接触的也不多，陷入循环里，越是没什么兴趣，就越想去娱乐自己，天天刷抖音、头条、玩游戏等，打发时间，这样接触和体验就越少、越局限于一些无意义的小领域。\n如果还没找到你的“公理”，遇到很多事尽量不要拒绝，去尝试，不要退缩。而且很多机会也是这么来的，一直待在自己舒适圈里，碰到的机会肯定不会多。\n另外，体验或接触新领域，也意味着要行动，而不是碰到就了解下，这不叫体验，顶多叫看到。\n怎么找到自己的兴趣 其实兴趣本质是一种快乐，你去尝试了、解决了一个个的小问题，然后解决了更大的问题，得到了回报，内部的满足感和外部的金钱等激励，然后兴趣就上来了。\n因为体验而发现擅长，因为擅长而产生兴趣，因为获得的激励而增强了动力。\n接着反复地做了之后，积累了更多的经验和能力，然后学起相关的知识也比别人快且稳固，觉得自己就是做这块事情的料，兴趣越长久。\n方法论：找“公理”的步骤 1、每天抽点时间出来，去回想哪些方面或许可以接触到更多的新鲜事，接触到可能感兴趣的事。\n2、每周抽时间去体验\n3、沉浸到里面，并及时回想、复盘这些事，找更多资料去了解更多，然后再体验、尝试\n4、找到其中最有可能是你人生意义的事，扩大范围去增加自己的影响力，用更多的时间和精力去尝试，看是否有可能性。\n作者认为的更高层级的快乐是怎么样 快乐分两类，一种是消费的快乐，另一种是创造的快乐。消费比如你拍照总是讲究用什么高端镜头，结果可能后面就陷入堆装备、跟圈子里的人攀比的快乐去了，买一个高端镜头就快乐一下，明天起来可能就消退了。但如果你花心思去钻研怎么用手机拍出更精致的照片，那注意力就聚焦在技巧上，大部分精力都在思考如果创造出更好的东西，拍出来的照片还能分享到更多的范围被人赞赏等，这种快乐就不一样。\n读书其实也是，有些人停留在消费的快乐，听说某本书很流行，立马买了一本，放到书架里，而且整个书架很大、里面放了很多非常受欢迎的书，书架拍下来看都很漂亮，他也会经常站在书架前欣赏这些书。这是把它们当艺术品玩了。另一种快乐，不求多，也不追求读过的数量，而是从一些非常高价值的书里学到很有价值的知识或认知，去改变自己的生活，提升生活品质和职业技能，然后把相关的思想也沉淀下来，分享给别人、影响更多的人，让更多人受益。这于人于己都有重大意义，是你从已有的价值（书）里创造出来的新价值。\n避开消费主义陷阱 很简单，就问一个问题：\n如果全世界除了我之外，没有人知道我拥有它，我还会想要它吗？如果答案是否定的，或者你犹豫了，那你很可能就落入陷阱了。\n创造者视角 玩一个游戏，不要沉迷到里面，而是站在创造者的角度思考他设计的这游戏规则，他想要我们怎么通关，我们自己能从中锻炼什么技能（手指灵活度？快速反应能力？）。\n进一步地，学了编程，玩游戏的时候，就会想创造者是怎么实现这个效果的。\n更进一步，学了心理学，玩的时候则想这游戏背后 作者想怎么吸引大家来玩，有什么心理学上的设计等。\n这些都是创造者视角，培养这种视角，会让自己习惯性地抽离出来，去看到全局而不是陷入别人的设计里。做同一个事，关注的角度不一样，会有不同的乐趣和收获。\n创造者视角，其实是一种让我们脱离低级的消费快乐的方法，对自己来说是一种创造，如果把相关的思考也沉淀下来，分享出去，对别人来说，也是一种创造。\n四、时间\u0026amp;精力管理 作者是怎么安排好每天工作的？ 化零为整 化零为整，一切安排都要先去想办法挤出整段的时间用于创造。创造是困难的，肯定是需要大段时间去思考和整理，零散的时间见缝插针地做出来的东西，大概率是草率的。腾出整块的时间，然后专注去创造（工作），集中攻克。\n作者专注的方法：\n把任务拆解，然后每个小任务安排一个倒计时做完 不强求自己一定要专注，任其自然，走神了再拉回来，从发现到拉回的时间，越来越短之后，专注的时间就越来越长 任务切换，一段时间后从一个事中抽离出来，安排另一个事，保持思考 避免时间黑洞 把琐事合并起来，集中到一个时间段去做完。\n主动休息，如工作半小时就听一会儿音乐，看会儿小说等，不过要给这个放松提前设置个时间，如 15min，时间一到就立马停止。\n弄一些小“仪式”再开始，比如开始前先深呼吸然后数到 10。\n做符合长远目标的事 每个周期之后，安排一次复盘，很简单，只要把这段时间做的事都列出来，然后一个个打分，看下离自己的长远目标有多远，越符合分越高。如果发现自己花了很多时间在偏离的方向上，那后续对这个事就要更加警惕。其实我们很多时候都在惯性地做事，当时并不会去思考那个事是否真有意义，只是习惯性地就做了。如果经常复盘，发现了这些问题，后面对它们就会更加警惕。\n作者怎么让自己每天效率爆表 大脑的关联效应 大脑喜欢不自觉地建立联系，所以你在不同的场景里会有不同的想法。比如你一坐到沙发上就想看电视，一坐到书桌前可能就想打电脑。因此也可以创造一些场景，比如阳台上的一把小沙发椅，坐上去就想看书。\n还有一个点，就是工作桌子不用经常整理，乔布斯的就挺乱的，乱不是问题，每个东西各摆一个地方，甚至堆叠起来，这其实就是一种大脑能记忆的工作场景，你收拾了可能反而会打破场景。\n不只是地点，习惯的触发也是一种大脑能自动建立的联系，比如你遇到复杂的事情就会习惯地打开脑图来整理思路，那每次有问题，就打开了脑图，思路自然地就涌出来了，这是大脑的一种场景关联。\n所以状态是可以创造出来的，而不是等出来的，虽然是会有一定的影响，但进入状态更多的取决于大脑的关联。\n少量多次冲刺 不用追求要专注多长时间，可以把更多地训练自己的快速进入专注状态的能力。\n休息的时候，换换脑子，可以整理整理资料，回复下消息，通讯软件可以根据专注的时段来关闭和打开，减少对专注的干扰。\n不过有个问题，一旦休息时，大脑的上下文就清空了，所以得让自己能暂存现场，办法就是记录当时做到哪，思路是怎么样的，下一步要干嘛等。等回头来继续工作的时候，很快就可以找到状态，再加上场景的关联，多训练训练，快速进入专注的能力就越来越强了。这实际上可以节省大把的时间，因为分段冲刺后，就多出了很多上下文切换的成本。\n作者是怎么休息来保持精力的 首选肯定是睡眠，作者建议每天睡 7.5h，5 个睡眠周期。\n其它是一些方法或观念：\n1、动脑休息\n不要觉得工作这么累了，去刷刷手机放松，其实这只会让自己兴奋，提高了大脑的阈值和期望，不刷了之后会感到无聊，反而影响精力。\n我们应该选择继续思考，意志力这东西，你认为是无限的，就可以是无限的，主要还是得通过主动选择去做一些有意义的事，取得成就，让大家保持一定兴奋度和自信。\n2、交替工作\n掌握好节奏，大概 1 小时休息个 10~15min。番茄工作法有一定的道理，不过不用这么死板，给自己设定个最长时间段，如果超过了就去做点其它事。比如可以拿出问题清单，去思考一些问题有什么解法，这类事情主要是让思维发散，不会像专注时那么耗精力，同时想出一些点子、把事情往前推进几步，也是一种成就，让大脑充满干劲，继续回到原来的工作中、精力充沛的战斗。当然中间去思考问题的那段时间也不能太短，要不然没弄出点什么就切走，大脑反而会一直思考原来的事，甚至会受到打击。\n3、放松空间\n放松空间，并不是就放空时间、随便度过。\n每天早上 1 小时的读书时间，就是我的放松空间。这段时间可以不用管其它事，沉浸到书籍里，去学习、感悟、思考，其它烦恼也不会干扰到我（当然偶尔会因为一些事变得不专心）。\n其实晚上也可以借助这个思路，给自己设定一个放松空间，一回家就赶紧把其它必做的事弄完（洗澡、哄娃、其它家务等），然后一闲下来就开始进入这个放松空间。半小时左右的整理、复盘、回顾思考等。\n如果还有时间，那再来半小时学习。白天的精力一直波动在较好的水平，到晚上其实并不是就直接下来了，用好这个时间，主动去学习，创造出自己的放松空间。\n这是个很虚的概念，说了好像等于没说，但其实是在脑子里创造了一个概念，默默地告诉自己，这个时间段就是固定用来做什么的，习惯了之后，未来就变成了一种“关联”，进入场景后就自然关联起那时该有的状态。比如早上我坐到咖啡厅，一个人，掏出书，大脑自动就关联起来，调出了看书的状态。\n4、设定界限\n得知道自己这周有哪些非常重要的事，必须要完成，得用多少时间，这些时间是被“锁住”的，然后这周还剩多少时间，心里得有这个大概的度量。\n之后有个什么事过来，如果剩下的时间不太够了，那就可能要想办法拒绝、或转手，有这个界限就会让自己有个衡量的标准，而不会一直是迷茫的状态，不清楚做了这个事还有没有时间做其它事。这些事先就要先估好。\n事情永远做不完，也不盘的很细，每天要什么事，做完才能回家。算到这么精细反而挺浪费时间和精力，还不如直接就用事先估好的这个“度”去评估每天是否该下班，是否有些事做不完了、得事先去沟通或安排。\n","date":"2024-10-29T00:08:41+08:00","image":"https://cdn.jsongo.top/2024/11/82c4155b2681df9665519ffb08d4e346.jpeg","permalink":"https://www.jsongo.top/articles/unlock-the-mind/","title":"打开心智 - 读书笔记"}]