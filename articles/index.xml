<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Articles on Ethan 的思考札记</title><link>https://www.jsongo.top/articles/</link><description>Recent content in Articles on Ethan 的思考札记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 05 Jan 2025 11:25:49 +0800</lastBuildDate><atom:link href="https://www.jsongo.top/articles/index.xml" rel="self" type="application/rss+xml"/><item><title>azure Function 自定义镜像</title><link>https://www.jsongo.top/articles/azure-function-custom-containers/</link><pubDate>Sun, 05 Jan 2025 11:25:49 +0800</pubDate><guid>https://www.jsongo.top/articles/azure-function-custom-containers/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/772c64fbb07e3cd46573602f922a7829.jpg" alt="Featured image of post azure Function 自定义镜像" />&lt;p>Azure Function 默认是跑在它官方的 &lt;a class="link" href="https://hub.docker.com/r/microsoft/azure-functions-base" target="_blank" rel="noopener"
>microsoft/azure-functions-base&lt;/a> 这个镜像上。当然你可以定义自己的镜像，Azure 开放了这个能力。本文主要介绍如何操作。&lt;/p>
&lt;h1 id="创建自己的镜像">创建自己的镜像
&lt;/h1>&lt;h2 id="创建-dockerfile">创建 Dockerfile
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">func init --docker
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它会初始化一个 Dockerfile 等文件，如果你只需要 Dockerfile 可以把参数改成 &lt;code>--docker-only&lt;/code>。&lt;br>
生成的 Dockerfile 里面有如下基础的配置：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># To enable ssh &amp;amp; remote debugging on app service change the base image to the one below&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># FROM mcr.microsoft.com/azure-functions/python:4-python3.12-appservice&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="s"> mcr.microsoft.com/azure-functions/python:4-python3.12&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">AzureWebJobsScriptRoot&lt;/span>&lt;span class="o">=&lt;/span>/home/site/wwwroot &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nv">AzureFunctionsJobHost__Logging__Console__IsEnabled&lt;/span>&lt;span class="o">=&lt;/span>true&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> requirements.txt /&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip install -r /requirements.txt&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . /home/site/wwwroot&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这些不要改动。不过可以在上面添加你自己的东西，比如我在做视频相关的处理，所以我需要一个 ffmpeg 库安装上去，所以我添加了如下的代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># 安装 ffmpeg&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> apt-get update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> apt-get install -y ffmpeg &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> apt-get clean &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> rm -rf /var/lib/apt/lists/*&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="注册">注册
&lt;/h2>&lt;p>在 &lt;a class="link" href="https://portal.azure.com/#browse/Microsoft.ContainerRegistry%2Fregistries" target="_blank" rel="noopener"
>Azure Container Registry&lt;/a>（容器注册表）这里注册一个你自己的命令空间。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/463f2950bea861c9729cb23cdc5a6478.webp"
width="675"
loading="lazy"
alt="|675"
>&lt;br>
创建完你就有一个自己的专属 Azure 镜像的域，如我这里的是 &lt;code>jsongo.azurecr.io&lt;/code>。&lt;br>
在 CLI 中登录：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">az acr login --name jsongo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果你的 &lt;code>az&lt;/code> 命令之前登录过，这里直接就成功了。接下去你就可以构建镜像，并把它推到你的这个域上了。&lt;/p>
&lt;h2 id="构建">构建
&lt;/h2>&lt;p>首先你本地得有一个 Docker 软件安装并运行起来，可以到 Docker 官网上去下载，这个比较简单。当然如果你有一个线上的虚拟机，那就直接在上面处理也行，只不过还得在上面安装 azure 的 CLI。上一篇已经介绍过了、不再赘述。&lt;br>
接下去在本地构建上面创建的镜像。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker build --tag jsongo/azure-video:0.1.0 .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如下示例。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/a28f11024d5a8fe4f5c8ad0337479ee7.webp"
width="750"
loading="lazy"
alt="|750"
>&lt;br>
比如我这个镜像，由于加了 ffmpeg 之后，构建完成时整个镜像很大，一下子撑到了 2G。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/4f71b5b5f343bcc4b0db975f24bfce60.webp"
width="700"
loading="lazy"
alt="|700"
>&lt;br>
构建完，试着把它运行起来看看：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker run --rm -e &lt;span class="nv">WEBSITES_INCLUDE_CLOUD_CERTS&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb">true&lt;/span> -p 8080:80 --name test-azure-video -it jsongo.azurecr.io/azure-video
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然你的 auth level 要设置成 anonymous authorization 才可以直接访问，如果没问题它能正常跑起来。接下去在本地 curl 一下 8080 端口就可以看到有没有正确返回。&lt;/p>
&lt;h2 id="用-azure-cli-更新镜像">用 azure CLI 更新镜像
&lt;/h2>&lt;p>Azure 也提供了相应的指令用于更新你的镜像。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">az acr build --registry jsongo --image jsongo.azurecr.io/azure-video:0.2.0 .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里我们构建一个 0.2.0 版本，它同时会把新构建完的镜像 push 到 Registry 里。
&lt;img src="https://www.jsongo.top/fd448e8706225766a6d6f778f9f4a967.webp"
width="750"
loading="lazy"
alt="|750"
>&lt;/p>
&lt;h2 id="推到-azure-平台上">推到 Azure 平台上
&lt;/h2>&lt;p>先打个 tag，刚构建时，默认是用的 dockerhub 的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker tag jsongo/azure-video:0.1.0 jsongo.azurecr.io/azure-video:0.1.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中 &lt;code>jsongo.azurecr.io&lt;/code> 就是我们上面创建的域，它标识了一个 Docker Registry 的地址（默认是 &lt;code>docker.io&lt;/code>）。&lt;br>
接下去运行 docker push 的时候，就可以找到 azure 的 Registry。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker push jsongo.azurecr.io/azure-video:0.1.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后就是等了。我这个镜像 2G+，着实是要等好一会儿。&lt;br>
Push 完，打开你的 &lt;a class="link" href="https://portal.azure.com/#view/HubsExtension/BrowseResource/resourceType/Microsoft.ContainerRegistry%2Fregistries" target="_blank" rel="noopener"
>容器注册表页面&lt;/a>，在这里就可以看到你刚推送上去的镜像了。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/fb1175d6eaf44464ccf31a4c1a79046b.webp"
width="750"
loading="lazy"
alt="|750"
>&lt;/p>
&lt;h1 id="使用镜像">使用镜像
&lt;/h1>&lt;h2 id="创建函数应用">创建函数应用
&lt;/h2>&lt;p>创建一个 Function，但要选高级计划或应用服务才行。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/97e0c4a5f43cd4dcb940b3b125e1fbbf.webp"
width="825"
loading="lazy"
alt="|825"
>&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/61ccd18ce92bbd84fe47a4bdf732ff55.webp"
width="600"
loading="lazy"
alt="|600"
>&lt;br>
一步步往下直到创建完成。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/db86acc839e4545ce6e255d56a6bc911.webp"
loading="lazy"
>&lt;br>
接下去就可以打开 azure 函数首页，去看刚部署的函数。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/6efc5b6d235cc4e37d11ef1a7b0c52de.webp"
width="750"
loading="lazy"
alt="|750"
>&lt;br>
至于哪些计划可以支持自定义容器部署可以参考这里：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-scale" target="_blank" rel="noopener"
>Azure Functions scale and hosting | Microsoft Learn&lt;/a>。&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/3ef8be06d615efb0daf5495e872d716e.webp"
width="750"
loading="lazy"
alt="|750"
>&lt;/p>
&lt;h2 id="关于-premium-plan-和-dedicated-plan">关于 Premium Plan 和 Dedicated Plan
&lt;/h2>&lt;p>这些 Plan 其实都涉及到了多种服务和资源，根据不同情况来选择。&lt;/p>
&lt;h3 id="premium-plan">Premium Plan
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>计算资源&lt;/strong>：通常指高性能的虚拟机或计算实例等。以虚拟机为例，不同规格的虚拟机收费不同，一般每小时的费用在 0.5 美元到几美元不等，如 DS 系列虚拟机可能比普通系列的虚拟机费用要高，高性能的虚拟机每小时费用可能要 0.834 美元甚至更高。&lt;/li>
&lt;li>&lt;strong>存储资源&lt;/strong>：如果是 Premium Storage，收费标准通常按磁盘的最大容量阶梯收费，而不是用多少算多少，且其读写操作也可能会有额外的收费，如每 10 万个存储事务为 3 元，不过每月一般会提供 100 亿次免费的事务 13。&lt;/li>
&lt;li>&lt;strong>网络资源&lt;/strong>：对于使用流量较大的公网 IP，每月费用可能在 1.2 美元及以上，负载均衡器每小时也会有一定的费用，如标准负载均衡器每小时的费用是 0.016 美元左右。&lt;/li>
&lt;/ul>
&lt;h3 id="dedicated-plan">Dedicated Plan
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>计算资源&lt;/strong>：如 Dedicated Host，一般会根据主机的配置和租用时长收费，一台配置中等的 Dedicated Host 每月费用可能在 1000 美元到 3000 美元左右。&lt;/li>
&lt;li>&lt;strong>存储资源&lt;/strong>：若使用专用的存储设备或特定的存储方案，收费也会因存储容量、性能要求等因素而异，通常专用存储的费用相对较高，每 GB 每月的费用可能在 0.2 美元到 0.5 美元之间，具体取决于存储类型和性能等级。&lt;/li>
&lt;li>&lt;strong>网络资源&lt;/strong>：如果需要专用的网络设备或带宽保证，费用也会相应增加，专用网络带宽每 Mbps 每月的费用可能在 10 美元到 50 美元左右。&lt;/li>
&lt;/ul>
&lt;h3 id="选择">选择
&lt;/h3>&lt;p>可以根据需求来选择：&lt;/p>
&lt;ul>
&lt;li>如果对计算性能要求极高，但对资源的独占性要求不是特别高，Premium plan 可能更合适，因为它可以提供高性能的计算资源，同时成本相对较低。&lt;/li>
&lt;li>如果对安全性、合规性以及资源的独占性有严格要求，需要完全隔离的计算和存储环境，那么 Dedicated plan 可能是更好的选择，尽管费用相对较高，但能满足特定的业务需求。&lt;br>
实在不好选择，直接就选 Premium plan，比较经济些，一般也用不到比较太高级的配置。它目前有以下三个配置可以选：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/c0f3dcf1e6ca0c79664d2697b121675b.webp"
width="450"
loading="lazy"
alt="|450"
>&lt;br>
不过价格上… 是有点高些，具体可以看这里：&lt;a class="link" href="https://azure.microsoft.com/zh-cn/pricing/details/functions/" target="_blank" rel="noopener"
>定价 - Functions | Microsoft Azure&lt;/a>。&lt;br>
小时视角：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/bcac629924bd882bed230aa3781131f6.webp"
width="850"
loading="lazy"
alt="|850"
>&lt;br>
月视角：&lt;br>
&lt;img src="https://cdn.jsongo.top/2025/01/cc859d4f93fc2c606083a65c5d005ff7.webp"
width="800"
loading="lazy"
alt="|800"
>
补：后来在函数的设置里，看到了比较实际的价格。
&lt;img src="https://cdn.jsongo.top/2025/01/cfd8d327d4b15dd049054f2fcf6223d7.webp"
width="800"
loading="lazy"
alt="|800"
>
这个看起来比较切合实际，1 小时不到 2 块。&lt;/li>
&lt;/ul>
&lt;h1 id="参考">参考
&lt;/h1>&lt;ul>
&lt;li>&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-custom-container?tabs=core-tools,acr,azure-cli2,azure-cli&amp;amp;pivots=container-apps#creating-containerized-function-apps" target="_blank" rel="noopener"
>Working with Azure Functions in containers | Microsoft Learn&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-create-container-registry?tabs=acr,bash&amp;amp;pivots=programming-language-python#build-the-container-image-and-verify-locally" target="_blank" rel="noopener"
>Create Azure Functions in a local Linux container | Microsoft Learn&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/container-registry/container-registry-roles?tabs=azure-cli" target="_blank" rel="noopener"
>Azure Container Registry roles and permissions - Azure Container Registry | Microsoft Learn&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://zone.huoxian.cn/d/2594-azure-functions" target="_blank" rel="noopener"
>使用自定义云容器在 Azure Functions 中增强云安全性&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Daily Meditations - W52</title><link>https://www.jsongo.top/articles/meditations-w52/</link><pubDate>Wed, 25 Dec 2024 23:25:18 +0800</pubDate><guid>https://www.jsongo.top/articles/meditations-w52/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/0b2412e8fae47001461d7b73f3127e2d.jpg" alt="Featured image of post Daily Meditations - W52" />&lt;blockquote>
&lt;p>这两周都在看吴军的新书《脉络》，从书中我读出他有点凯文凯利的一面。一些比较大的命题，他能举重若轻地用一两句简单的总结，表达出一些一针见血的见解。让人感悟深刻。&lt;/p>
&lt;/blockquote>
&lt;h1 id="整个社会的视角">整个社会的视角
&lt;/h1>&lt;blockquote>
&lt;p>也有点经济学的思维&lt;/p>
&lt;/blockquote>
&lt;h2 id="时不时的去放弃一些东西">时不时的去放弃一些东西
&lt;/h2>&lt;p>只保留生活必需品。&lt;br>
其实，对大多数人来讲，很多东西并没有太大的存在必要，却对别人很重要。适当的舍弃或捐献或许能提升社会资源的利用率和价值。&lt;br>
买的东西也不一定要选择退货，也可以把它捐掉，一方面商家可能拿到后也是扔掉，反而是对资源的浪费，自己还蒙受了损失；另一方面，这能反向地约束自己，敦促自己买东西前要三思、想清楚真正需要再下手。&lt;br>
对我来说，家里有很多书，也有很多很久没用的东西，这些其实占了我满大空间，但如果我把它们捐掉或送给有需要的人，我甚至都不需要那么大的空间来存放，给自己腾出一些地方来。&lt;/p>
&lt;h2 id="人们对社会的贡献可能是正数也可能是负数">人们对社会的贡献，可能是正数、也可能是负数
&lt;/h2>&lt;p>我们如果以贡献最终值来衡量的话（正 + 负），那些名人的贡献不一定比我们多，因为他们除了做了很多有用的事之外，也做了很多影响很大的坏事，这些使得他们的贡献总量可能为负。&lt;br>
比如，几年前中国的共享单车在竞争这个市场的时候，完全是在浪费社会资源，如果只有那么一两家在相互竞争、相互促进，不断的强大和发展，为社会众人解决最后 1 公里的交通问题，那是没啥问题的，但是百来家这真的有点浪费社会资源，还搞得到处被自行车堵得乱糟糟的。&lt;/p>
&lt;h2 id="这个世界缺少长期主义者">这个世界缺少长期主义者
&lt;/h2>&lt;p>人类在生理上天生就有一个缺陷，就是喜欢即时反馈和鼓励，不太喜欢等待。&lt;br>
要解决社会上任何需要时间的问题，靠得住的其实不是某个政治家或领导，而是能够盈利的商业，只有在有利可图时，人们才有动力去做，如果能适当的引导让大家往好的方向去竞争，问题解决的效率会是最高。&lt;br>
吴军说，正是因为很多人迷信所谓的“历史巨变”、“人生转折”，才把原来非常广阔的道路留给了极少数长期主义者。&lt;/p>
&lt;h1 id="共识">共识
&lt;/h1>&lt;h2 id="教育的作用">教育的作用
&lt;/h2>&lt;p>较好的教育，除了简单的在知识上、逻辑上能够有所增进之外，还要学会如何更好的运用知识。&lt;br>
更重要的是教育能够教会人学习，它搭建起了我们和人类思想之间的桥梁的，我们学会了更多的去思考如何高效地获取更多、更好的知识，以及如何把知识更好的变成生产力，去丰富生活，以及为社会做贡献。&lt;br>
以前我们会以为离开的学校就解放了，不用再学习了，但其实那只是一个开始。&lt;br>
在学校只是学到了基础和方法论，上了社会就要不断的完善和充实自己，没法躺平，共同富裕也不是让你躺平，因为人总要挣钱、生活，躺平了就等着饿死。这个社会在飞速的发展，如果没有很好的学习能力，很难在未来活的很好。现在的努力，更多地是在为未来做储备，而不只是去解决现在的问题，要不然就跟有了这顿、没有下顿的古代平民没太大区别。&lt;/p>
&lt;h2 id="有些财富建立在共识之上">有些财富建立在共识之上
&lt;/h2>&lt;p>比如“房价还会继续涨”，这个共识让房价一直保持着高价。&lt;br>
在中国，这个观念是几千来农耕/封建历史养成的，形成了人们的“家”的观念，大家共同的信仰。不过这个事也不是完全牢不可破的，万一某一代人因为巨大的压力不敢再持有这种信仰的时候，房价就会慢慢的下滑。&lt;br>
比特币经常大波动，特别是乱世的时候疯狂地涨或跌，是因为一直有些人持有“无国界”货币的观念，而且人也不少，他们形成了种共识，共同推动着虚拟币的涨跌。而更多参与的人，是在陪玩，他们没有坚定的信念，经常就是眼馋或想着快速致富，跟投资房地产没有本质上的不同。&lt;/p>
&lt;h1 id="回到这本书">回到这本书
&lt;/h1>&lt;p>脉络这本书前面的章节主要就是在讲过去的历史，很多跟我们认知都不太一样。过去没有我们想象的那么美好，而且我们经常会去美化历史，但实际上过去的盛世真正只占历史的 1/3 都不到，大部分时候都是兵荒马乱。&lt;br>
最开始的章节也讲到，现代人的生活水平其实大部分都是工业革命之后才飞速发展起来的。那么长的农耕时代，其实并没有对现代生活贡献多少，社会的整体生产力一直没有得到什么发展，而工业革命给整个人类社会带来了非常迅猛的技术和财富的增长。&lt;br>
之后比较长的篇幅在讲工业革命及之后的一些观点，很有意思。看到上面这些介绍，相信有的人会开始对这本书有所兴趣，总之它让我看到了凯文凯利的影子，这或许也是吴军当时想写出来的效果。&lt;/p></description></item><item><title>蓝牙 &amp; wifi - 隔墙传播衰减数据</title><link>https://www.jsongo.top/articles/ble-wifi-decays-through-wall/</link><pubDate>Wed, 25 Dec 2024 01:06:18 +0800</pubDate><guid>https://www.jsongo.top/articles/ble-wifi-decays-through-wall/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/437965e93ce93d3c2ca0ebac98d54619.jpeg" alt="Featured image of post 蓝牙 &amp; wifi - 隔墙传播衰减数据" />&lt;h1 id="基础">基础
&lt;/h1>&lt;h2 id="发射功率的大概认知">发射功率的大概认知
&lt;/h2>&lt;ul>
&lt;li>一般家用 &lt;strong>Wifi&lt;/strong> 的发射功率在 13 ~ 20dBm 左右&lt;/li>
&lt;li>一般&lt;strong>蓝牙&lt;/strong>设备的发射功率范围一般在 -30dBm ~ 20dBm 之间
&lt;ul>
&lt;li>常见的蓝牙设备，如蓝牙耳机、蓝牙音箱等，发射功率通常在 0 - 4dBm 左右，蓝牙耳机发射功率可能在 0dBm 左右&lt;/li>
&lt;li>长距离传输的蓝牙模块，发射功率可能会接近 20dBm&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="换算">换算
&lt;/h2>&lt;ul>
&lt;li>在中国，无线路由器发射功率一般不超过 100mW（毫瓦）。功率（P）与分贝毫瓦（dBm）的换算公式为：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/b4371d0440c37ebc53e0c2329eb832b0.webp"
width="400"
loading="lazy"
alt="|400"
>&lt;/li>
&lt;li>对于 100mW 的发射功率，换算后约为 20dBm&lt;/li>
&lt;/ul>
&lt;h1 id="分贝-db-估算">分贝 (dB) 估算
&lt;/h1>&lt;ul>
&lt;li>&lt;strong>混凝土墙&lt;/strong>
&lt;ul>
&lt;li>蓝牙，信号强度降低 10 - 20dB 左右&lt;/li>
&lt;li>Wifi，2.4GHz 强度可能会降低 10 - 20dB，5GHz 降低 15 - 30dB 左右 &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>砖墙&lt;/strong>
&lt;ul>
&lt;li>蓝牙，信号强度降低 3 - 10dB 左右&lt;/li>
&lt;li>Wifi，单堵普通砖墙会使 2.4GHz 强度降低 5 - 12dB 左右，5GHz 降低 8 - 15dB 左右&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>木板墙和石膏板墙&lt;/strong>
&lt;ul>
&lt;li>蓝牙，强度降低一般在 1 - 3dB 左右&lt;/li>
&lt;li>Wifi，2.4GHz 大概降低 1 - 3dB 左右，5GHz 大概降低 2 - 4dB 左右&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="距离估算">距离估算
&lt;/h1>&lt;ul>
&lt;li>空旷环境下
&lt;ul>
&lt;li>蓝牙，10 米&lt;/li>
&lt;li>Wifi，2.4GHz 一般室内可达 30 - 50 米左右，5GHz 频段的一般 15 - 30 米左右&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>隔了一堵&lt;strong>砖墙&lt;/strong>后
&lt;ul>
&lt;li>蓝牙，有效传输距离可能会缩短到 3 - 7 米&lt;/li>
&lt;li>Wifi，2.4GHz 频段的 WiFi 信号传输距离可能缩短到 10 - 30 米，5GHz 可能缩短到 5 - 15 米&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>隔了&lt;strong>混凝土墙&lt;/strong>后
&lt;ul>
&lt;li>蓝牙，有效传输距离可能进一步缩短到 1 - 5 米&lt;/li>
&lt;li>Wifi，2.4GHz 频段有效传输距离一般在 5-15 米左右，而 5GHz 仅为 3-10 米左右。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="应用">应用
&lt;/h1>&lt;p>房间布局比较复杂的情况下，测算 Wifi 的覆盖是比较有用的。&lt;/p>
&lt;ul>
&lt;li>先画出房间的布局图，标注出哪些是砖墙、混凝土墙，标明各房间大概的长宽等&lt;/li>
&lt;li>标出 Wifi 的位置（或可以摆放的地方一个个试），往同样环境的地方画圆（扇形），都是空旷的话就是整个圆，如果被墙隔开则分两部分画，多种墙隔着则再拆分更细来画&lt;/li>
&lt;li>没覆盖到的地方、或者只在最后一米的地方，信息肯定很差，这时要再想想哪里能挂个中继器&lt;br>
另外，蓝牙网关也是一种场景，测算方式差不多。&lt;/li>
&lt;/ul>
&lt;h1 id="其它">其它
&lt;/h1>&lt;p>对于 Wifi 来说，WiFi 协议会根据信号强度和质量自动调整传输速率。例如，在信号良好的情况下，可能达到理论上的高速传输速率，如 802.11ac 标准下的几百 Mbps 甚至更高。但当信号减弱后，传输速率可能会降低到几十 Mbps 甚至更低。&lt;/p>
&lt;hr>
&lt;h1 id="footnotes">Footnotes
&lt;/h1>&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>5GHz 频段的信号波长更短，更容易被障碍物阻挡&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Cron 表达式</title><link>https://www.jsongo.top/articles/cron-syntax/</link><pubDate>Wed, 18 Dec 2024 00:55:38 +0800</pubDate><guid>https://www.jsongo.top/articles/cron-syntax/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/91668e623e452ebc624daa105d2f82c2.jpg" alt="Featured image of post Cron 表达式" />&lt;p>平时工作中，可能会时不时碰到像 &lt;code>0 */5 * * * *&lt;/code> 这种 Cronjob 定时任务的配置，特别是运维和服务端的同学，经常会打交道。本文只是最基础的用法，后面有新内容再补充，仅作为自己学习、记录、备忘的文档沉淀下。&lt;/p>
&lt;h1 id="基础语法">基础语法
&lt;/h1>&lt;h2 id="cron-表达式的基本格式和含义">Cron 表达式的基本格式和含义
&lt;/h2>&lt;ul>
&lt;li>Cron 表达式用于配置定时任务的执行时间。它由 6 ~ 7 个段组成，从左到右依次是：秒（0 - 59）、分（0 - 59）、时（0 - 23）、日（1 - 31）、月（1 - 12）、周（0 - 6，0 表示周日）。&lt;/li>
&lt;li>上面提到的表达式 &lt;code>0 */5 * * * *&lt;/code> 中，有 6 个字段，一一对号入座就行。&lt;/li>
&lt;li>除了直接写 &lt;code>*&lt;/code>、&lt;code>*/数字&lt;/code> 、&lt;code>数字&lt;/code>，这种写法之外，还有用逗号隔开的写法，如第 4 个位置表示一个月中的哪一日，如果它写成 &lt;code>1,3,5&lt;/code> 表示每个月的 1 日、3 日和 5 日。&lt;/li>
&lt;/ul>
&lt;h2 id="对每个字段的具体分析-">对每个字段的具体分析 **
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>秒（0）&lt;/strong>：表示任务在每分钟的第 0 秒开始执行。&lt;/li>
&lt;li>&lt;strong>分（*/5）&lt;/strong>：&lt;code>*/5&lt;/code> 是一个特殊的语法。在这里，&lt;code>*&lt;/code> 表示 “所有可能的值”，&lt;code>/&lt;/code> 是一个间隔符号。所以 &lt;code>*/5&lt;/code> 表示 “每隔 5 分钟”。也就是说，任务会在 0 分、5 分、10 分、15 分…… 以此类推，每隔 5 分钟执行一次。&lt;/li>
&lt;li>&lt;strong>时（*）&lt;/strong>：&lt;code>*&lt;/code> 表示每一个小时，即任务会在一天中的每一个小时都有可能执行，具体的分钟由前面的 &lt;code>*/5&lt;/code> 决定。&lt;/li>
&lt;li>&lt;strong>日（*）&lt;/strong>：&lt;code>*&lt;/code> 表示一个月中的每一天，即任务在一个月中的每一天都有可能执行。这是第 4 个位置，它有一些特定的语法，如：
&lt;ul>
&lt;li>&lt;code>L&lt;/code>：表示每月的最后一天。&lt;/li>
&lt;li>&lt;code>W&lt;/code>：用于指定最接近给定日期的工作日（周一到周五），如“15W”，它表示最接近 15 日的工作日。&lt;/li>
&lt;li>&lt;code>LW&lt;/code>：合起来，用于指定本月的最后一个工作日。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>月（*）&lt;/strong>：&lt;code>*&lt;/code> 表示每一个月，即任务在每一个月都有可能执行，具体日期由前面的日、时、分决定。&lt;/li>
&lt;li>&lt;strong>周（*）&lt;/strong>：&lt;code>*&lt;/code> 表示每一个周，即任务在每一周都有可能执行，这个比较特殊，也可以省略而只需要前面 5 个也行。&lt;br>
开头说的这个配置，含义是在每分钟的第 0 秒开始，并且每隔 5 分钟执行一次，每天每小时、每月都会按照这个间隔执行。简单说，就是 &lt;strong>5 分钟执行一次&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;div class="admonition summary">
&lt;div class="details-summary admonition-title">
&lt;i class='icon fas fa-pencil-alt fa-fw'>&lt;/i>
简单好记&lt;br
&lt;/div>&lt;/div>
&lt;div class="details-content">
&lt;div class="admonition-content">
&lt;p>一个比较简单的方法来记，就是把 &lt;code>*&lt;/code> 翻译成“&lt;strong>每&lt;/strong>”，把 &lt;code>/&lt;/code> 翻译成“&lt;strong>每隔&lt;/strong>”，非 &lt;code>*&lt;/code> 的则对应地加上时间表达即可。&lt;br>
另一个方法是，从后往前倒着看，比如只看前三个，它就是时间的表达，像 1:00:00&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>&lt;h1 id="使用">使用
&lt;/h1>&lt;p>下面举一些例子，尽量全地覆盖可能用到的场景：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>每 5 秒执行一次&lt;/strong>
&lt;ul>
&lt;li>表达式：&lt;code>*/10 * * * * *&lt;/code>&lt;/li>
&lt;li>解释：在秒的位置上 &lt;code>*/10&lt;/code> 表示每隔 10 秒。上面介绍过这类基础的用法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>每小时的第 10 分钟执行&lt;/strong>
&lt;ul>
&lt;li>表达式：&lt;code>0 10 * * * *&lt;/code>&lt;/li>
&lt;li>解释：分的位置是 10，秒是 0，表示每小时的第 10 分钟开始时执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>每天凌晨 2 点执行&lt;/strong>
&lt;ul>
&lt;li>表达式：&lt;code>0 0 2 * * *&lt;/code>&lt;/li>
&lt;li>解释：时为 2，分和秒为 0，表示每天凌晨 2 点整执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>每隔 2 小时执行一次&lt;/strong>
&lt;ul>
&lt;li>表达式：&lt;code>0 0 */2 * * *&lt;/code>&lt;/li>
&lt;li>解释：时的位置 &lt;code>*/2&lt;/code> 表示每隔 2 小时执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>每月 1 号凌晨 0 点执行&lt;/strong>
&lt;ul>
&lt;li>表达式：&lt;code>0 0 0 1 * *&lt;/code>&lt;/li>
&lt;li>解释：日为 1，时、分、秒为 0，表示每月 1 号凌晨 0 点执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>每周一早上 9 点执行&lt;/strong>
&lt;ul>
&lt;li>表达式：&lt;code>0 0 9 * * 1&lt;/code>&lt;/li>
&lt;li>解释：时为 9，分和秒为 0，周为 1（周一），即每周一早上 9 点执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>每月最后一天晚上 11 点 59 分 59 秒执行&lt;/strong>
&lt;ul>
&lt;li>表达式：&lt;code>59 59 23 L * *&lt;/code>&lt;/li>
&lt;li>解释：秒为 59，分是 59，时是 23，日的位置 &lt;code>L&lt;/code> 表示每月最后一天。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>每年 1 月 1 日凌晨 0 点执行&lt;/strong>
&lt;ul>
&lt;li>表达式：&lt;code>0 0 0 1 1 *&lt;/code>&lt;/li>
&lt;li>解释：日为 1，月为 1，时、分、秒为 0，表示每年 1 月 1 日凌晨 0 点执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>工作日（周一到周五）早上 8 点执行&lt;/strong>
&lt;ul>
&lt;li>表达式：&lt;code>0 0 8 * * 1-5&lt;/code>&lt;/li>
&lt;li>解释：时为 8，分和秒为 0，周为 1-5，表示周一到周五早上 8 点执行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Azure Function Triggers</title><link>https://www.jsongo.top/articles/azure-function-triggers/</link><pubDate>Wed, 18 Dec 2024 00:42:33 +0800</pubDate><guid>https://www.jsongo.top/articles/azure-function-triggers/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/54ae9a6d9d56a2e58c20dc50f584fd39.jpg" alt="Featured image of post Azure Function Triggers" />&lt;h1 id="触发器各类">触发器各类
&lt;/h1>&lt;p>Azure Function 有多种模板，我们在创建 Function 时，一般会用 &lt;code>--template&lt;/code> 参数要指定用哪个模板。详细的可以参考官方文档：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings" target="_blank" rel="noopener"
>Triggers and bindings in Azure Functions | Microsoft Learn&lt;/a> 或中文版 &lt;a class="link" href="https://learn.microsoft.com/zh-cn/azure/azure-functions/functions-triggers-bindings?tabs=isolated-process,node-v4,python-v2&amp;amp;pivots=programming-language-csharp" target="_blank" rel="noopener"
>Azure Functions 中的触发器和绑定 | Microsoft Learn&lt;/a>。&lt;br>
以下是一些常见的：&lt;/p>
&lt;h2 id="基于事件触发的模板">基于事件触发的模板
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>Azure Blob Storage Trigger&lt;/strong>：当 Azure Blob 存储中的 Blob 被创建、更新或删除时触发函数。例如，可以在有新文件上传到指定 Blob 容器时，自动触发函数进行数据处理或文件转换等操作。&lt;/li>
&lt;li>&lt;strong>Azure Event Hubs Trigger&lt;/strong>：用于接收来自 Azure Event Hubs 的事件流消息，可实现对实时数据的处理。例如，在物联网场景中，接收设备发送的大量实时数据进行分析和处理。&lt;/li>
&lt;li>&lt;strong>Azure Service Bus Trigger&lt;/strong>：可以响应来自 Azure Service Bus 队列或主题的消息，支持批量接收消息。适用于处理异步消息传递场景，如订单处理、消息通知等。&lt;/li>
&lt;/ul>
&lt;h2 id="基于数据存储的模板">基于数据存储的模板
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>Azure Cosmos DB Trigger&lt;/strong>：使用 Azure Cosmos DB 的变更 feed 来监听分区中的插入和更新操作，当有数据发生变化时触发函数，可用于实时数据同步等场景。&lt;/li>
&lt;li>&lt;strong>Azure SQL Database Trigger&lt;/strong>：当 Azure SQL 数据库中的表发生数据插入、更新或删除操作时触发函数，方便进行数据的关联操作和业务逻辑处理。&lt;/li>
&lt;/ul>
&lt;h2 id="基于定时任务的模板">基于定时任务的模板
&lt;/h2>&lt;p>除了 Timer Trigger 外，还有一些定时任务相关的模板或扩展，如支持按照特定时间间隔或 cron 表达式来定期执行函数，可用于定时数据备份、报表生成等任务 。&lt;/p>
&lt;h2 id="基于-http-请求的模板">基于 HTTP 请求的模板
&lt;/h2>&lt;p>除了常见的 HTTP Trigger 外，还有一些针对特定 HTTP 场景的模板或扩展，如支持接收和处理来自 Webhook 的 HTTP 请求，可用于与第三方系统进行集成，接收外部系统推送的数据或事件。&lt;/p>
&lt;h2 id="其他模板">其他模板
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>PowerShell Trigger&lt;/strong>：允许使用 PowerShell 脚本编写函数逻辑，方便系统管理员或熟悉 PowerShell 的开发人员进行自动化脚本编写和任务调度。&lt;/li>
&lt;li>&lt;strong>Python Trigger&lt;/strong>：使用 Python 语言编写函数逻辑，适用于数据科学、机器学习等场景，可方便地调用 Python 库进行数据处理和分析。&lt;/li>
&lt;/ul>
&lt;h1 id="实践">实践
&lt;/h1>&lt;h2 id="timer-trigger">Timer Trigger
&lt;/h2>&lt;p>Http trigger 在 &lt;a class="link" href="azure%20serverless.md" >azure serverless&lt;/a> 中介绍过了。这里再讲一下 Timer Trigger，在做定时任务时非常有用，而且计费也只是按函数的执行时间来计，比较划算。&lt;br>
详细使用可以参考官方文档：&lt;a class="link" href="https://learn.microsoft.com/zh-cn/azure/azure-functions/functions-bindings-timer?tabs=python-v2,isolated-process,nodejs-v4&amp;amp;pivots=programming-language-python" target="_blank" rel="noopener"
>Azure Functions 的计时器触发器 | Microsoft Learn&lt;/a> 。&lt;br>
跟创建普通的 Azure Function 一样，还是用 CLI 的 new 命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">func new --name xxx --template &lt;span class="s2">&amp;#34;timer trigger&amp;#34;&lt;/span> --authlevel &lt;span class="s2">&amp;#34;function&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它会在你的 &lt;code>function_app.py&lt;/code> 里创建一个新的 function：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@app.timer_trigger&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">schedule&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;0 */10 * * * *&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">arg_name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;timer&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">run_on_startup&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">use_monitor&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">my_polling&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">timer&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">TimerRequest&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="kc">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">timer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">past_due&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">logging&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;The timer is past due!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">logging&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Python timer trigger function executed.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>@app.timer_trigger 里的几个参数：&lt;/p>
&lt;ul>
&lt;li>schedule：语法跟 cronjob 的配置一样，参考：&lt;a class="link" href="https://www.jsongo.top/articles/cron-syntax/" target="_blank" rel="noopener"
>Cron 表达式&lt;/a>。&lt;/li>
&lt;li>arg_name：表示计时器对象的变量的名称，没啥特别含义，就是随便定个名字能用就行。&lt;/li>
&lt;li>run_on_startup：部署完、或重新启用时，它自动触发一次。&lt;/li>
&lt;li>use_monitor：是否被 monotor 记录，如果间隔大于 1 分钟，建议设置为 true。&lt;br>
其中， &lt;code>func.TimerRequest&lt;/code> 这个参数，其实就只有 &lt;code>past_due&lt;/code> 这个 boolean 类型的属性。&lt;br>
&lt;code>past_due&lt;/code> 用于判断当前定时器触发的任务是否已经逾期：&lt;/li>
&lt;li>当定时任务由于某些原因（例如系统负载高、资源暂时不可用等）未能在预定的时间点执行，后面才被触发时，&lt;code>mytimer.past_due&lt;/code> 将为 &lt;code>True&lt;/code>。&lt;/li>
&lt;li>如果定时任务在预定时间内正常执行，那么 &lt;code>mytimer.past_due&lt;/code> 将为 &lt;code>False&lt;/code>&lt;br>
现在 &lt;code>my_polling&lt;/code> 函数里，我们可以添加一些对其它 Azure Function 的调用，由此来处理其它任务的定时执行。这样由两个触发器配合来完成特定任务。当然把逻辑全与在 Timer Trigger 里也不是不行，只不过解耦开之后，Http Trigger 还能被单独使用。&lt;/li>
&lt;/ul></description></item><item><title>git 恢复误删笔记or文件</title><link>https://www.jsongo.top/articles/git-recover-notes/</link><pubDate>Tue, 17 Dec 2024 23:34:22 +0800</pubDate><guid>https://www.jsongo.top/articles/git-recover-notes/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/6424b2c83ab269ea18c2240356db3b9d.jpg" alt="Featured image of post git 恢复误删笔记or文件" />&lt;p>自从改用 Obsidian 来做笔记后，再也不怕文件丢失了，特别是我有了 git 来管理文件后，不小心删掉一些文件也都能找回来，即使是 100 天前删除的都行，非常方便。&lt;/p>
&lt;div class="admonition tip">
&lt;div class="details-summary admonition-title">
&lt;i class='icon fas fa-lightbulb fa-fw'>&lt;/i>
为什么用 git 管理？同步软件不行吗&lt;br
&lt;/div>&lt;/div>
&lt;div class="details-content">
&lt;div class="admonition-content">
&lt;p>我试过用 Obsidian 官方的，但我的笔记增长太快了（最近一直在迁移以前的笔记），一个月就增长 1G，所以买官方的服务太贵了，而且还有一个更重要的原因：文件经常会莫名其妙地被覆盖，而我完全没办法，可以看到一些历史，但很麻烦，得一个个点开找，可以说不太可用。&lt;br>
其实 git 是最完美的版本管理工具，非常丰富的命令可以实现各种操作、满足各类诉求。下面讲讲我是怎么找回我的文件&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>&lt;h1 id="主要方法">主要方法
&lt;/h1>&lt;p>文件不小心删掉了要找回来是比较常见的，比如我装的 &lt;code>clear unused images&lt;/code> 插件，经常有些不知名的原因删我的图片。开始我还一个一个 commit 找，效率实在太低了，其实 git 是支持从 log 里找的，命令也不难。比如我今天不小心删掉了某个文件，现在我想恢复，我明确知道是今天删的（因为昨天还没有这个图片贴的那个文档），所以我就从今天开始搜索，很快：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git log --since&lt;span class="o">=&lt;/span>midnight -- 74a006c91c5150f0d9d9dd25d5c5ab34.webp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>找到有哪些 commit 操作了这个文件，然后再用 git show 命令来看当时做了哪些操作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git show 5b12e80a540539b0da2ac75cf4d5e7221f2b7342 -- 74a006c91c5150f0d9d9dd25d5c5ab34.webp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>结果：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/95c7302d5fa881834bb45c88c8115cb2.webp"
width="725"
loading="lazy"
alt="|725"
>&lt;br>
可以看到，当时把这个文件给删掉了。再往上看，可以找到第一条 commit，这就是它创建的那个提交，还能看到是什么时候提交的：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/861fa74e3155d6e84b9e6ffba287e05e.webp"
width="725"
loading="lazy"
alt="|725"
>&lt;br>
最后就是恢复文件，直接用 &lt;code>git checkout&lt;/code> 命令就行：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git co c171a4c169470455fa8ac62fd8d4164ea677c8ec -- 2c579673c6b2f0793f2e423523cc6fe3.webp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="扩展">扩展
&lt;/h1>&lt;h2 id="时间范围">时间范围
&lt;/h2>&lt;p>上文讲 git log，它其实有很多指定时间范围的参数，刚刚用了 since midnight (非常语义化、好理解)，也可以指定要几天前。另外还有一个 &lt;code>--util&lt;/code> 参数，用法跟 since 一样，这两个参数可以办公室一个范围，比如大前天的文件变更情况，可以用：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git log --since&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;3 days ago&amp;#34;&lt;/span> --until&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;2 days ago&amp;#34;&lt;/span> -- &amp;lt;filename&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此外还有两个类似的参数：after（=since）、before（=until），记住一组就行。&lt;/p>
&lt;h2 id="时间写法">时间写法
&lt;/h2>&lt;p>上文涉及到：&lt;code>midnight&lt;/code>、&lt;code>3 days ago&lt;/code> 这两种，都是直接用英文表达的。做个汇总：&lt;/p>
&lt;ul>
&lt;li>相对日期：&lt;code>--since=&amp;quot;3 days ago&amp;quot;&lt;/code>&lt;/li>
&lt;li>绝对日期：&lt;code>--since=&amp;quot;2024-10-01&amp;quot;&lt;/code> 或具体到时间，如 &lt;code>2024-10-01 12:00&lt;/code>&lt;/li>
&lt;li>时间戳（秒）：&lt;code>--since=1633046400&lt;/code>&lt;/li>
&lt;li>自然语言时间，主要有：
&lt;ul>
&lt;li>&lt;code>yesterday&lt;/code>&lt;/li>
&lt;li>&lt;code>today&lt;/code>&lt;/li>
&lt;li>&lt;code>midnight&lt;/code>：今天的午夜&lt;/li>
&lt;li>&lt;code>noon&lt;/code>：今天的中午&lt;/li>
&lt;li>&lt;code>teatime&lt;/code>：今天的下午 4 点&lt;/li>
&lt;li>&lt;code>last week&lt;/code>&lt;/li>
&lt;li>&lt;code>last month&lt;/code>&lt;/li>
&lt;li>&lt;code>last year&lt;/code>&lt;/li>
&lt;li>&lt;code>last christmas&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>组件表达，非常强大，举几个例子：
&lt;ul>
&lt;li>&lt;code>3 days ago 14:00&lt;/code>&lt;/li>
&lt;li>&lt;code>2 weeks ago midnight&lt;/code>&lt;/li>
&lt;li>&lt;code>last friday&lt;/code>&lt;/li>
&lt;li>&lt;code>last year december 31 23:59&lt;/code>&lt;/li>
&lt;li>&lt;code>new year's eve 2022&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Azure Function + Mysql 入门</title><link>https://www.jsongo.top/articles/azure-serverless-mysql/</link><pubDate>Mon, 16 Dec 2024 13:39:37 +0800</pubDate><guid>https://www.jsongo.top/articles/azure-serverless-mysql/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/0dba76ff89c558a40825ce7e7a507005.jpg" alt="Featured image of post Azure Function + Mysql 入门" />&lt;blockquote>
&lt;p>在 Azure Function 上使用 mysql DB，具体可以参考：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-azure-mysql?tabs=isolated-process&amp;amp;pivots=programming-language-python" target="_blank" rel="noopener"
>Azure Database for MySQL bindings for Functions | Microsoft Learn&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="mysql-申请">Mysql 申请
&lt;/h1>&lt;h2 id="免费额度">免费额度
&lt;/h2>&lt;p>免费用户其实还是有不少额度可以使用：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/31a8630222aa9b38aa0c6bedb54fb61e.webp"
width="650"
loading="lazy"
alt="|650"
>&lt;br>
详细可以阅读：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/mysql/flexible-server/how-to-deploy-on-azure-free-account" target="_blank" rel="noopener"
>Try Out With an Azure Free Account - Azure Database for MySQL - Flexible Server | Microsoft Learn&lt;/a>&lt;/p>
&lt;ul>
&lt;li>简单说，可以支持 B1MS 实例一直在线上跑，有 32G 的存储空间。B1MS 有 1~2 个 CPU 微核&lt;/li>
&lt;/ul>
&lt;h2 id="添加一个实例">添加一个实例
&lt;/h2>&lt;ul>
&lt;li>打开：[[https://portal.azure.com/#browse/Microsoft.DBforMySQL%2Fservers]]，点 &lt;code>Quick Create&lt;/code>。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/a1e23752568d6a93c878dcf2864d5a30.webp"
loading="lazy"
>&lt;/li>
&lt;li>简单填写下信息就行：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/4fee17d9e7f06b0c894723a5a2cc1c18.webp"
loading="lazy"
>&lt;/li>
&lt;li>下一步、创建，等几分钟就创建成功了：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/aab8b78c940e753bc5de50a461d49053.webp"
loading="lazy"
>&lt;/li>
&lt;/ul>
&lt;h1 id="简单使用">简单使用
&lt;/h1>&lt;h2 id="手动连接">手动连接
&lt;/h2>&lt;p>在本地默认是连接不上的， azure 为了安全，对访问做了限制，可以通过 zero trust 网络来接入，当然也可以简单的设置下网络、放行你的 ip：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/da949ffb37dbb360bb9e563577f2adf8.webp"
loading="lazy"
>&lt;br>
不过其实还有更简单的方式，直接在页面上打开连接：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/34cdbaccec72321f854ea1da97fac0b4.webp"
loading="lazy"
>&lt;br>
连接时，它会弹出一个 terminal，然后自动运行 mysql 命令进行连接。实际上，这个时候还连不上，即使你密码输入正确了也不行，它需要验证证书（也是为了安全）。&lt;br>
证书可以从这里下载：[[https://learn.microsoft.com/zh-cn/azure/mysql/flexible-server/how-to-connect-tls-ssl#download-the-public-ssl-certificate]] ，或者直接用我下图中的 wget 命令即可。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/de4826c732a4f7e2e09f0280c58246a3.webp"
width="725"
loading="lazy"
alt="|725"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">wget https://dl.cacerts.digicert.com/DigiCertGlobalRootCA.crt.pem
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>需要注意的是，直接连接 Mysql 进行操作比较危险，可以应急用，不建议当成常规操作。&lt;/p>
&lt;h2 id="操作">操作
&lt;/h2>&lt;p>刚创建的 MySQL 服务里面是空的，得自己手动创建一个 database：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">create&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">database&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">xxx&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后就可以切到这个 db 上使用了：&lt;code>use xxx&lt;/code>。&lt;/p>
&lt;h2 id="mac-上连接">Mac 上连接
&lt;/h2>&lt;p>如果是在 mac 上安装 mysql 客户端的话，用 brew install 会非常慢，直接到这个地址上去下载一个客户端：&lt;a class="link" href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener"
>Download MySQL Community Server&lt;/a>&lt;/p></description></item><item><title>免费的花生壳 - cloudflared</title><link>https://www.jsongo.top/articles/build-a-cloudflared-tunnel/</link><pubDate>Sun, 15 Dec 2024 16:03:07 +0800</pubDate><guid>https://www.jsongo.top/articles/build-a-cloudflared-tunnel/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/f53c5884b5505531f32ad8fa0fc57247.jpg" alt="Featured image of post 免费的花生壳 - cloudflared" />&lt;div class="admonition note">
&lt;div class="details-summary admonition-title">
&lt;i class='icon fas fa-pencil-alt fa-fw'>&lt;/i>
花生壳&lt;br
&lt;/div>&lt;/div>
&lt;div class="details-content">
&lt;div class="admonition-content">
&lt;p>一般我们习惯用花生壳来实现内网穿透，不过花生壳本身是要收钱的，它的域名也要收钱，流量也收一次钱，而且给了钱之后它的流量带宽也受到限制，正常是 1M 带宽下载速度只有 100 多 k，用起来很难受，加点带宽就要加不少钱。而且每个月还有总流量限制，经常用了半个月就不行了，非常痛苦。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>&lt;p>其实 cloudflare 本身就提供了一个免费的 cloudflared 的 tunnel 工具，直接下载运行就行。如果用 Docker 的话可以用这个镜像：&lt;a class="link" href="https://hub.docker.com/r/cloudflare/cloudflared" target="_blank" rel="noopener"
>hub.docker.com/r/cloudflare/cloudflared&lt;/a> 里面也有一些简单的指引。&lt;/p>
&lt;h1 id="简单使用">简单使用
&lt;/h1>&lt;p>一条命令就可以搞定：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cloudflared tunnel --no-autoupdate --hello-world
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不过这么跑，比较依赖于不需要 Cloudflare 帐户的公共 trycloudflare.com，很不稳定，我之前试用过，经常断，网速也不稳定。要实际上线使用的话，还是得自己注册一个 cloudflare 账号，下面介绍。&lt;/p>
&lt;h1 id="搭建个人-tunnel-网络">搭建个人 Tunnel 网络
&lt;/h1>&lt;h2 id="注册一个-tunnel">注册一个 Tunnel
&lt;/h2>&lt;p>到 &lt;a class="link" href="https://dash.teams.cloudflare.com/%e2%81%a0" target="_blank" rel="noopener"
>Cloudflare One&lt;/a> 上注册一个 Cloudflare Zero Trust 域名，选 Free 就可以了&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/420352862a7523747b97d596ff767b81.webp"
width="675"
loading="lazy"
alt="|675"
>&lt;br>
接下去它会让你绑定一个支付卡，即使选的是免费的。这是海外各类服务的常见操作，因为收费计划可能会变，而且你使用时也可能会超额，所以先让你把扣费的方式留好，以备后面需要的时候能扣到钱。&lt;br>
注册完后，下面我们来一步步创建一个 tunnel，其实过程也很简单。&lt;/p>
&lt;blockquote>
&lt;p>这些是一步步摸索出来的，没有参考其它外部的指引，所以可能会有更好的办法。希望有读者找到更好的方法时，能给我留个评论，感激不尽。&lt;/p>
&lt;/blockquote>
&lt;h2 id="创建-tunnel">创建 Tunnel
&lt;/h2>&lt;p>在下图中的菜单里找到创建的地方，选 Cloudflared。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/5b690dff91048eeaeb5663f168c837a2.webp"
width="875"
loading="lazy"
alt="|875"
>&lt;br>
自己取一个名字（不跟别人重复就行）&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/8652218a31d2d78c56aa4f0a43edcf8d.webp"
width="900"
loading="lazy"
alt="|900"
>&lt;br>
下一步，取得 token：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/29b1a001c14459ba21b349c12cb4288d.webp"
width="925"
loading="lazy"
alt="|925"
>&lt;br>
如上图，划线处就是你的 token，先记下来，下面用。&lt;/p>
&lt;h2 id="启动接入">启动、接入
&lt;/h2>&lt;p>创建完之后，在本地运行 cloudflared 的命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cloudflare tunnel --no-autoupdate run --token xxx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果使用 docker 的话，可以用这个 compose yml&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;3.8&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">cloudflared&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cloudflare/cloudflared:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">container_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cloudflared&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tunnel --no-autoupdate run --token xxxx&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">restart&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">unless-stopped&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">network_mode&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">host&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">dns&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">1.1.1.1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中，xxx 换成你自己的 token。&lt;br>
如果你家里有个服务器或 NAS，其实 docker 是比较合适的，它可以一直在线跑。&lt;br>
创建完之后，在同一个界面里可以看到已经有一个设备连接上来了：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/3c23fd4e318bb3198e69dd369ed24c29.webp"
width="725"
loading="lazy"
alt="|725"
>&lt;br>
再下一步，public hostnames 里添加一个你转到 cloudflare 来解析的域名，加一个子域名。同时 Service 填写你内网的某个服务的地址，如你的 nginx 网关等。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/0e9d6a0c0afadbd8100b681aab58a962.webp"
width="875"
loading="lazy"
alt="|875"
>&lt;br>
再下一步就回到了列表页，可以看到你的 tunnel 已经在跑了：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/f39e1282f64410a6862142f136b7108b.webp"
width="850"
loading="lazy"
alt="|850"
>&lt;br>
回到你的 cloudflare DNS 配置页面，可以看到它帮你添加了一个 CNAME，说明已经成功了&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/292affb6bfeac40389684bb915b7bce0.webp"
width="875"
loading="lazy"
alt="|875"
>&lt;br>
&lt;a class="link" href="https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/routing-to-tunnel/dns/" target="_blank" rel="noopener"
>DNS records · Cloudflare Zero Trust docs&lt;/a> 这条 CNAME 的规则是：&lt;code>&amp;lt;Tunnel ID&amp;gt;.cfargotunnel.com&lt;/code> ，这个 Tunnel ID 可以在上方的截图中找到。所以手动配置也行。&lt;/p>
&lt;p>现在你可以用刚配置的域名来访问你的内网服务了。网速很快。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/7063c449ce57a9dfa970e2e9c6916d9e.webp"
width="750"
loading="lazy"
alt="|750"
>&lt;/p>
&lt;h2 id="优化网络连接">优化网络连接
&lt;/h2>&lt;p>如果你的服务需要耗时比较久，比如 git 服务，有时你拉内容的时候都要好几分钟，那就需要设置连接和超时时长了。&lt;br>
在上面我们配置 publish hostname 时，下方其实还有高级配置，如下图位置：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/321e5240cb520e8f255d0afad7893609.webp"
width="725"
loading="lazy"
alt="|725"
>&lt;br>
调整下 timeout 的时长（默认 30s），超过 30 秒就自动关闭链接了，所以这个地方可以适当调大一些。&lt;/p></description></item><item><title>azure serverless 使用</title><link>https://www.jsongo.top/articles/azure-serverless/</link><pubDate>Sat, 14 Dec 2024 01:33:06 +0800</pubDate><guid>https://www.jsongo.top/articles/azure-serverless/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/9f2713cc4890d8cf0449df9f4877fa26.jpg" alt="Featured image of post azure serverless 使用" />&lt;h1 id="基础工具">基础工具
&lt;/h1>&lt;p>Mac 上直接装：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">brew tap azure/functions
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">brew install azure-cli
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">brew install azure-functions-core-tools@4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>具体可以参考这里：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=macos,isolated-process,node-v4,python-v2,http-trigger,container-apps&amp;amp;pivots=programming-language-csharp" target="_blank" rel="noopener"
>Develop Azure Functions locally using Core Tools | Microsoft Learn&lt;/a>&lt;/p>
&lt;ul>
&lt;li>另外，这链接里也有怎么用命令行来创建的方法。下文 vscode 插件和 CLI 都会涉及。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="vscode-插件">Vscode 插件
&lt;/h1>&lt;p>参考这个：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-python?toc=/azure/developer/python/toc.json&amp;amp;bc=/azure/developer/python/breadcrumb/toc.json" target="_blank" rel="noopener"
>Create a Python function using Visual Studio Code - Azure Functions | Microsoft Learn&lt;/a>&lt;/p>
&lt;h2 id="简介">简介
&lt;/h2>&lt;p>在 vscode 中安装插件：Azure Functions&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/fb2e0acc105d63d085c40bdd1920f6a2.webp"
width="425"
loading="lazy"
alt="|425"
>&lt;br>
切到这个插件去点击添加一个函数，一步步往下都有说明，比较简单。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/ea7349816d01aa7f064eebb26475e767.webp"
width="300"
loading="lazy"
alt="|300"
>&lt;br>
我选了 HTTP 触发器的模板，最后给我生成了这个文件：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/92942fa30fb661c19c1901c6df0f73ee.webp"
width="500"
loading="lazy"
alt="|500"
>&lt;/p>
&lt;h2 id="调试运行">调试运行
&lt;/h2>&lt;p>简单的运行，可以用插件面板上，下半部分中的 Project 展开，里面有个调试相关的操作（它可点击）。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/b1f01eb135df433a4a2f8b9e91904dbb.webp"
width="850"
loading="lazy"
alt="|850"
>&lt;br>
它会先做一些安装，然后启动 function，IDE 进入 debug 模式。这时主要运行的命令是：&lt;code>func host start&lt;/code>，直接在命令行里运行这个命令也可以启动本地调试运行。但如果你想查询代码中打的日志，一定要记得加上 &amp;ndash;verbose 的参数，所以正确的使用姿势是：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">func host start --verbose
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>本地调试时，其实已经默认把 AZURE_FUNCTIONS_ENVIRONMENT 这个变量设置为 &lt;code>Development&lt;/code> 了，如果你修改代码，它会触发服务的重启，非常方便。&lt;br>
它同时生成一个链接可以直接点击，它会触发函数执行：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/fe3b5f734dbe003a59b09c561687bf88.webp"
width="650"
loading="lazy"
alt="|650"
>&lt;/p>
&lt;h1 id="创建">创建
&lt;/h1>&lt;p>用 IDE 插件进行 function 创建上面已经介绍过来了，比较简单，不过读者可能会遇到网络问题而没法往下尝试。这里再介绍下 CLI 的方式来创建。&lt;br>
先初始化目录：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">func init --python
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它会生成一些基础的配置文件，包括 [[https://learn.microsoft.com/en-us/azure/azure-functions/functions-develop-local#local-settings-file]] 和 &lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-host-json" target="_blank" rel="noopener"
>&lt;em>host.json&lt;/em>&lt;/a>。&lt;br>
创建一个 api 入口：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="k">func&lt;/span> &lt;span class="n">new&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="n">combine_videos&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">template&lt;/span> &lt;span class="s2">&amp;#34;HTTP trigger&amp;#34;&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="n">authlevel&lt;/span> &lt;span class="s2">&amp;#34;function&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Authlevel 有三个值：&lt;/p>
&lt;ul>
&lt;li>Anonymous 即任何人都可以访问，不需要带什么认证，相当于公开了。&lt;/li>
&lt;li>Function 函数级别的认证，创建的每个函数都得在 URL 上带一个 token 进行认证，参数是 &lt;code>?code=&amp;lt;token&amp;gt;&lt;/code>。&lt;/li>
&lt;li>Admin，最高级别的认证，只有具有管理员权限的用户才能访问函数，适用于包含敏感操作或数据的函数，如修改系统关键配置、访问敏感的业务数据等。这种模式依赖于复杂的身份管理系统（如 AAD）。&lt;/li>
&lt;/ul>
&lt;h1 id="部署">部署
&lt;/h1>&lt;h2 id="平台创建应用">平台创建应用
&lt;/h2>&lt;p>先打开 [[https://portal.azure.com/#browse/Microsoft.Web%2Fsites/kind/functionapp]] 这个 portal 地址，创建一个 &lt;code>Function App&lt;/code> （或者中文叫“函数应用”）。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/8c7facddd451e9fca9cba01e0b045eac.webp"
width="575"
loading="lazy"
alt="|575"
>&lt;/p>
&lt;h2 id="plugin">Plugin
&lt;/h2>&lt;p>正式部署前，肯定是需要先登录的。正常是可以在插件上操作，如下：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/91ce1f913a33cb8ab6d9d64480929b25.webp"
width="500"
loading="lazy"
alt="|500"
>&lt;br>
如果不成功，可以用下文 CLI 的方法来登录。&lt;br>
选择 Deploy to Function App，直接进行部署。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/bda580eaff46be66e6353ae23f839da6.webp"
width="700"
loading="lazy"
alt="|700"
>&lt;br>
我在使用的时候，经常遇到网络问题，因为某些你懂的原因，所以挺难的，得给 vscode 设置 Proxy (具体就不介绍了)&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/628fc45d846b96aa8dd84a59bc7f7ff7.webp"
width="700"
loading="lazy"
alt="|700"
>&lt;/p>
&lt;h2 id="cli-发布">CLI 发布
&lt;/h2>&lt;h3 id="登录">登录
&lt;/h3>&lt;p>使用前也一样需要先登录 (上面的说明都是在本地开发)：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">az login
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>运行时，它会打开一个网页进行登录授权&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/e473747eb42ae1af27de1a51d5d59e94.webp"
width="750"
loading="lazy"
alt="|750"
>&lt;br>
命令行也会有一堆打印，有如下关键信息就说明已经登录成功了。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/6d649277ba0edb949dfeb3bb2f736a94.webp"
width="900"
loading="lazy"
alt="|900"
>&lt;/p>
&lt;h3 id="发布操作">发布操作
&lt;/h3>&lt;p>当然我们也可以选择用 CLI 来做发布：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">func azure functionapp publish &amp;lt;project_name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>具体细节可以参考这里：&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/azure-functions/create-first-function-cli-python?toc=/azure/developer/python/toc.json&amp;amp;bc=/azure/developer/python/breadcrumb/toc.json&amp;amp;tabs=macos,bash,azure-cli,browser" target="_blank" rel="noopener"
>Create a Python function from the command line - Azure Functions | Microsoft Learn&lt;/a>&lt;br>
这里的 &lt;code>project_name&lt;/code> 跟在平台上创建的应用名要保持一致，要不然会找不到这个 App 而发布失败。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/8ae08faed3138aeebf5aab5a595ebe9e.webp"
width="775"
loading="lazy"
alt="|775"
>&lt;br>
另外还有一点要注意的是，本地的 python 环境需要跟平台上的一致，避免本地跑的好好的、部署上去就缺一些模块：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/d4c8cfd171f834123918d1a99265533f.webp"
width="675"
loading="lazy"
alt="|675"
>&lt;br>
部署完会生成一个地址可供访问：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/3ac8969d54d4b231a0dad35cec82b39c.webp"
width="800"
loading="lazy"
alt="|800"
>&lt;br>
部署的过程是会比较慢，我们从平台的部署日志中可以看到它部署完后，会等待 1 分钟：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/a945e829b9eace8c1a74fb3afdcc9396.webp"
width="750"
loading="lazy"
alt="|750"
>&lt;br>
在线上运行后，可以访问试试。&lt;br>
线上日志可以在这里看到：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/4ca6c0c355611de0c1b3f2c29ca5f0e7.webp"
width="725"
loading="lazy"
alt="|725"
>&lt;br>
不过经常连接不稳定，所以其实可以到另一个地方查看 ：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/be1071dc6f42f0523efb4fcb176d311a.webp"
width="775"
loading="lazy"
alt="|775"
>&lt;/p>
&lt;h1 id="重要插件-azurite">重要插件 Azurite
&lt;/h1>&lt;p>安装另一个三方的 server 运行插件 Azurite，为开发人员提供了一个免费的本地环境，用于测试 Azure Blob、队列存储和表存储应用程序。常用的主要是 MySQL 操作，本地连不上线上 MySQL，它帮你开了一个代理，可以直接把本地调试时写的数据同步到线上。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/02f0caabaf55d3b7cd7d1ae156e1deb3.webp"
width="550"
loading="lazy"
alt="|550"
>&lt;br>
如果没有它，本地如果运行定时任务就是出异常：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/bb208c03b576515896aa151e5a12fa6c.webp"
loading="lazy"
>&lt;br>
修改下 &lt;code>local.settings.json&lt;/code> 的配置，把 &lt;code>AzureWebJobsStorage&lt;/code> 设置成 &lt;code>&amp;quot;UseDevelopmentStorage=true&amp;quot;&lt;/code>。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/f477dc6f98630c7d9911cd2d28eb7ab5.webp"
width="550"
loading="lazy"
alt="|550"
>&lt;br>
打开命令面板，运行 Azurite start 来启动服务&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/e96da6632ab1e656b5bcdb2978135a51.webp"
width="475"
loading="lazy"
alt="|475"
>&lt;br>
这时它们的启动非常快，一闪而过，没关系，它已经在跑了。&lt;br>
比较烦的时，运行时，会在当前目录下生成一些文件：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/d08188a1cf18ec9fc4a3dd1170c2f5e0.webp"
width="450"
loading="lazy"
alt="|450"
>&lt;/p>
&lt;ul>
&lt;li>&lt;em>blobstorage&lt;/em> 和 &lt;em>queuestorage&lt;/em>
&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：
&lt;ul>
&lt;li>这些文件夹通常用于存储本地开发时的 Azure Blob 存储和 Azure Queue 存储的模拟数据。当你在本地运行和测试 Azure Functions 时，这些文件夹可以帮助模拟真实的 Azure 存储环境。&lt;/li>
&lt;li>例如，如果你有一个 Azure Function，它从 Blob 存储中读取数据或者向 Queue 存储中写入数据，在本地开发环境中，这些文件夹会存储相关的数据，以便函数能够正常运行和测试。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>使用场景&lt;/strong>：
&lt;ul>
&lt;li>在没有连接到真实 Azure 存储账户的情况下，本地开发和调试函数时需要用到。如果删除这些文件夹，可能会导致本地运行的函数在涉及到 Blob 或 Queue 操作时出现错误，因为它们找不到模拟的存储数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>以 &lt;em>azurite_db&lt;/em> 开头的.json 文件
&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：
&lt;ul>
&lt;li>这些文件是 Azurite 数据库文件。Azurite 是一个本地的 Azure 存储模拟器，用于在本地模拟 Azure Blob、Queue 和 Table 存储服务。这些.json 文件存储了 Azurite 模拟存储服务的数据结构和数据内容。&lt;/li>
&lt;li>例如，&lt;em>azurite_db_blob&lt;/em>.json 文件用于存储模拟的 Blob 存储数据结构和数据，&lt;em>azurite_db_queue&lt;/em>.json 文件用于存储模拟的 Queue 存储数据等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>读《不上班咖啡馆》的收获</title><link>https://www.jsongo.top/articles/no-work-cafe/</link><pubDate>Fri, 13 Dec 2024 17:29:08 +0800</pubDate><guid>https://www.jsongo.top/articles/no-work-cafe/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/058b101b8325853cf16210d89529ed82.jpg" alt="Featured image of post 读《不上班咖啡馆》的收获" />&lt;blockquote>
&lt;p>这是这几天在看的一本很有趣的书，有感而发这篇读书笔记&lt;/p>
&lt;/blockquote>
&lt;h1 id="概述">概述
&lt;/h1>&lt;p>买这本书主要是冲着古典老师去的，之前对他的《跃迁》印象深刻，受益匪浅。刚看到书名我就想起了《世界尽头的咖啡馆》前两年还出了续集，我都看了。后来在读本书的时候，感觉就是在看国产的《世界尽头的咖啡馆》，叙述方式很像，内容上也是讲职场和生活，所以阅读起来我有种熟悉的感觉。&lt;br>
这几年经济不好，大家都在职场和创业的路上挣扎，都过得很不容易。随着越来越多人“毕业”，讲人生规划类的书籍或课程必定会大受欢迎。因为大量的城市精英突然就遇到了 10 几年一个周期的经济萧条，上一轮大概率没经历过，这么一来就有点措手不及，人生突然陷入迷茫。&lt;br>
有缘看到这篇文章的人，如果正好自在这个阶段，可以读读上面提到的这 3 本书（《世界尽头的咖啡馆》有两本），相信会有不错的启发。&lt;br>
本文主要摘录我在阅读过程中受到触动，结合自己思考写下来的一些笔记，希望能引发读者一些思考。&lt;/p>
&lt;hr>
&lt;h1 id="思考清楚自己的赛道">思考清楚自己的赛道
&lt;/h1>&lt;h2 id="下班后才是一个打工人最清醒的时刻">下班后才是一个打工人最清醒的时刻
&lt;/h2>&lt;p>全书多次提到这句话，故事中的那个咖啡馆也只有在晚上 9 点后才开门，因为打工人下班了。古典在书中说的这句话，主要想表达，在上班的时候，人容易迷失自己，沉浸在为做好工作而对其它事情浑然不觉的状态中，更不会抽时间去思考自己的现在、做事方式、未来的发展等，一心在做好当下的事。&lt;br>
不过在下班后，就有更多的时间回去“做自己”，这时就换了一个完全不一样的思维，可以思考更多的可能性，而不是工作干不好整个世界就完了的状态。&lt;/p>
&lt;h2 id="换赛道">换赛道
&lt;/h2>&lt;p>如果打算换赛道，尽可能地一步步切换，就像攀岩，不要一步就跳过去，容易失去抓手、然后掉下去。&lt;br>
即使是“毕业”，离开岗位时，也要留住人脉和技能，然后在这些基础上慢慢探索、切入适合自己的赛道。&lt;br>
书中古典老师化身的胖子，是一个耐心的人生导师。他针对职场，提出了一个公式：&lt;br>
&lt;strong>定位=行业 x 企业 x 职位&lt;/strong>&lt;br>
可以尝试先切换其中的一个变量。比如现在是在互联网行业，这个大前提可以不用换。之前一直在走“职位”这条路，一路往上爬。实际上还有其它思路，只是我们平时很少思路，一心盯着职位职级。公式中没有讲的很具体，没提职位怎么切，但这个变量给了我们一个思考的起点，即可以挪挪屁股，换一个部门或团队，如果一个产品 (业务) 自己不喜欢、不适合、或识别出不是自己未来发展方向的话，及时果断地换。比如想往 AI 技术方向发展，可以切换到 AI 相关的团队中去，找到一个让自己有更多学习的机会的环境中去。&lt;br>
大概的步骤可能是这样：&lt;/p>
&lt;ul>
&lt;li>先认真收尾手头的事，边观察机会、切换赛道；&lt;/li>
&lt;li>然后在新赛道中认真的学习、快速积累，不计得失，努力去做成一些事，有一些自己的创造或产出；&lt;/li>
&lt;li>在上一条的持续迭代中，不断地精进到某个高度，同时积累更多的技术和人脉；&lt;/li>
&lt;li>如果条件成熟，可以再考虑切换企业，继续创造，验证这套模式可行性，并不断完善相应框架，同时继续积累更多的技术经验和人脉；&lt;/li>
&lt;li>最后如果还有激情和条件，可以再切换到创业的赛道，有一份真正属于自己的事业。&lt;/li>
&lt;/ul>
&lt;h1 id="职场">职场
&lt;/h1>&lt;h2 id="职业的本质是什么">职业的本质是什么？
&lt;/h2>&lt;p>通过帮别人解决问题来获利。&lt;br>
&lt;strong>该给你多少钱，不是看你有多厉害，而是看别人的问题有多大&lt;/strong>。&lt;br>
我们一直以为只有把专业技能练到炉火纯青的地步才能赚大钱，其实不太对。赚钱的是那些，找对了痛点和问题、然后培养自己能力，最终能解决这类问题的人。&lt;br>
简单说，是&lt;strong>需求决定价格，而不是供给决定价格&lt;/strong>。&lt;br>
同样是销售，卖房子的就是比卖汽水的赚钱。虽然他们的本质都是跟人打交道，找到别人的痛点，把自己的东西包装下卖给别人。最关键的点，在于找对行业。怎么把一瓶水卖出天价，也许能做到这个的人你会觉得他很厉害，不过很可能他只是把水运到了沙漠中去卖而已。&lt;br>
当然这点可能不只一个人发现，那么随着加入的人越来越多，就成了红海。时机很重要，但如果已经晚了的话呢？这时我们只能去发现更多的新机会。新机会往往出现在新行业，这有点像废话，不过更多时候，我们只是看着新行业到来，也没什么行动。&lt;/p>
&lt;h2 id="宁当鸡头不做凤尾">宁当鸡头，不做凤尾
&lt;/h2>&lt;p>在一个不怎么重要的部门当尾部，还不如去一个新部门（缺人才的部门）承担非常重要的岗位，给自己更多的历练，最重要的是成长和突破过去的自我，往未来趋势的方向不断的前进，这才是最有意义的。&lt;br>
很多人一直盯着职级、地位看，干嘛要一直去跟别人做比较呢？要知道职级就是公司设置的游戏规则，把人牢牢地套在规则里面、认真的奉献，不过很多人即使知道这一点，还是会很执著地追求这些。可能是因为不甘心，也可能是因为自尊心太重…… 但不是正确的方向还要坚持，就很难过得好。&lt;/p>
&lt;h1 id="提升自我">提升自我
&lt;/h1>&lt;h2 id="打磨优势">打磨优势
&lt;/h2>&lt;p>没有人是完美的，要充分亮出自己的优势，像一把沙子中只有一点点金子，经常容易被埋没，如果你经常去擦亮你找到的金子，它就会在沙子中闪闪发光。&lt;br>
重要的是把优势放大，同时规避劣势。&lt;br>
找优势可以用排除法，看看失去什么会让我活不下去。每个人都有优势，只是说怎么在沙子中找到金子，以及怎么让别人看到。&lt;br>
风口没了，猪会不会摔死？&lt;br>
你进入了风口之后，要不断地学习、站稳，让自己长出翅膀来，趁着红利在这个领域站稳脚跟。翅膀就是这个培养出来的优势，如果没及时长出来、亮出来，风口过后就会摔得很惨。&lt;/p>
&lt;h2 id="多关注自己跟过去比">多关注自己、跟过去比
&lt;/h2>&lt;p>不用总盯着别人的优势、跟别人比，要多跟现在自己比，只要让自己过得更舒适、更充实就行。&lt;br>
不一定要超越别人才算成功，大家的起点或运气不一样，世界本就不公，抱怨改变不了一切，接受现实往往是很难的，总会有不满。但我们注意力不应该在这，而应该放在&lt;strong>怎么不断地去突破自我&lt;/strong>，要比之前的自己活得更好、变得更强。以前觉得自己不太行的地方，突然自己变得非常行了，这就是最有意义的事。&lt;/p>
&lt;h2 id="只要坚持着慢慢地跑就能赢过很多人">只要坚持着慢慢地跑，就能赢过很多人
&lt;/h2>&lt;p>人生就像一场马拉松。这点感受很深，平时我也经常去跑步，坚持很累，特别是突破之前跑过的距离，很多人都会在途中停下休息，如果能一直坚持，就能赢过大部分人。&lt;br>
人生更像是在操场上跑圈，时不时有人加入，不用羡慕刚加入的人的体力，他们刚下场体力就是好，开始时就是跑得快，也可能是基因好、祖上都是运动员。但你一直坚持下来了，总能超过大部分人，毕竟有先天优势的只是非常少数，干嘛一定要跟他们比呢。&lt;/p>
&lt;h2 id="读书的方法">读书的方法
&lt;/h2>&lt;p>读书就是&lt;strong>以自己为中心，以问题为导向，以改变为终点&lt;/strong>。&lt;/p>
&lt;h2 id="想不是办法干才有答案">想不是办法，干才有答案
&lt;/h2>&lt;p>路是走出来的，不是设计出来的。&lt;br>
人们总是喜欢提前规划路线，其实路不是想出来的，而是走出来的。没真走到那路口，也不一定了解那边的路况，只是听人说、或看地图知道的。这些都不一定准确，或者偏离的很多。&lt;/p>
&lt;h2 id="初心">初心
&lt;/h2>&lt;p>“如果当时……” 是人生最大的谎言。&lt;br>
或许当时的选择，已经是那会能找到了最好的选项之一。不用去想走了另一条路会怎么样，因为我们经常会去美化那些得不到的东西，这样它就变得不真实，而且会很后悔、搞坏了尽情…… 没必要，这些都是自己在找罪受。&lt;br>
认识到这一点后，怎么正确地去看待这些选择呢？重点还是“初心”，了解自己来自哪、有什么目标或使命要去完成。这样再去做选择的时候，至少知道方向。&lt;br>
每个苦苦坚持的不得不，都藏着巨大的初心。&lt;br>
我们可能都有一些比较初期的出发点，或许我们已经忘了，但它带来的动力和惯性，让我们一直往前走，只不过后来我们以&lt;strong>最近的幻想&lt;/strong>来衡量自己的行为和成果，忘了这个初心。&lt;br>
或许当时的初心只是不想在小城市一眼看到头，而是想探索更多的可能性，想不断地超越儿时玩伴或亲戚朋友，只不过慢慢地，买了房，有了房贷，想自由，想赚钱，然后迷失了最初的初心，变得浮躁，一切心赚钱为目标，但又碰到各种障碍，终日郁郁寡欢。&lt;br>
当一个人知道最初的“为何”，就能承受一切“如何”。&lt;br>
我们不是害怕苦难，而是怕苦得没有意义，白白花费了很多精力、最终没得到任何收获。&lt;/p>
&lt;h1 id="管理">管理
&lt;/h1>&lt;h2 id="项目管理中的-1-10-100-定律">项目管理中的 1-10-100 定律
&lt;/h2>&lt;p>解决一个问题：&lt;/p>
&lt;ul>
&lt;li>事前计划，只需要 1 的成本。&lt;/li>
&lt;li>事中改进，就需要 10 的成本。&lt;/li>
&lt;li>事后修正，那需要 100 的成本。&lt;br>
所以为什么要做重要但不紧急的事。因为这是最省成本的方法，如果每天都在做紧急的事，那基本都要付出 10 或 100 的成本。&lt;br>
如果大部分能预期的事，都提前做好事前的计划，并及时地执行，那你完成它们的成本就只有 1 x N，而不是 100xN。这时你就可以比别人省出更多的时间。&lt;/li>
&lt;/ul>
&lt;h2 id="做团队管理的两个重要的事">做团队管理的两个重要的事
&lt;/h2>&lt;ul>
&lt;li>1 是帮别人拿成果，要为他争取机会，且争取时间，及时、适当地推他一把。&lt;/li>
&lt;li>2 是保护大家，一方面不让一些杂事、不重要的投诉分心，另一方面 pk 掉不合适的需求直接找到他们，不要当一个传话筒或需求传送带。&lt;/li>
&lt;/ul>
&lt;h2 id="成为专家之路的几个阶段">成为专家之路的几个阶段
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>求助者&lt;/strong>，这是最开始的时候，什么都不太懂，开始入门&lt;/li>
&lt;li>&lt;strong>探索家&lt;/strong>，有了兴趣或任务，不断地深挖、学习更多这方面的知识&lt;/li>
&lt;li>&lt;strong>建筑师&lt;/strong>，把自己在这里面学到的一些有一定难度的东西沉淀下来，形成框架&lt;/li>
&lt;li>&lt;strong>助人者&lt;/strong>，在平时帮助别人解决问题的过程中，不断的完善自己的框架，补齐知识点&lt;/li>
&lt;li>&lt;strong>专家&lt;/strong>，最终自己的框架已经比大多数人认知更深了，在别人眼里就是半个专家了。&lt;br>
其实不一定要到了助人者或专家再开始发声，从探索时就可以开始，动手去慢慢打磨、创造一个产品，然后跟着它一起成长。同时也把这个成长的过程分享出来，让初学者都能从中受益。&lt;br>
这个世界其实初学者（求助者）远远多于其它阶段的人。这就是一个金字塔，越塔尖的人越专业、而大部分人都是在中等以下。所以市场及需求最大的往往都是上面说的“探索家”和“求助者”。&lt;/li>
&lt;/ul></description></item><item><title>踩坑：如何避免被 aws 悄悄地收费</title><link>https://www.jsongo.top/articles/avoid-aws-charges/</link><pubDate>Fri, 13 Dec 2024 15:59:05 +0800</pubDate><guid>https://www.jsongo.top/articles/avoid-aws-charges/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/1f46848857f50464c097c5ea752ee538.jpg" alt="Featured image of post 踩坑：如何避免被 aws 悄悄地收费" />&lt;p>最近被 aws 算计了好多钱，之前一直没在意。后来才知道，是当时开了一个 cloud9。
&lt;img src="https://cdn.jsongo.top/2024/12/8004e7b22145d8b77b7bcca05c34f06b.webp"
loading="lazy"
alt="a0ca56c580cb92b784f7a891d694a46c_MD5"
>
EC2 一个月扣我 10 刀，Virtual Private Cloud 应该是 cloud9 启动后，内部建立的容器集群。Tax 这个就不用说了，10%的税
刚开始进入控制面板首页时，看不到什么异常，点 EC2 也没看到什么不对的地方：&lt;/p>
&lt;ul>
&lt;li>这个页面：https://us-east-1.console.aws.amazon.com/console/home?region=us-east-1
&lt;img src="https://cdn.jsongo.top/2024/12/5f2935beac626250341b78204dba3aaa.webp"
loading="lazy"
alt="dc4d2f7b2f6541fdf855791c014cd6bc_MD5"
>
看起来很正常，也没有实例在跑&lt;/li>
&lt;li>后来点了 global view 才知道，原来其它区域还有，aws 它是分区域隔离的，我一直在用 us-east 的，所以一直没发现。
&lt;img src="https://cdn.jsongo.top/2024/12/4f04b71f829cf419a34b05797f7e6cd6.webp"
loading="lazy"
alt="07fe0255dd659d8be840fad26fa1025a_MD5"
>
&lt;a class="link" href="https://us-east-1.console.aws.amazon.com/ec2globalview/home" target="_blank" rel="noopener"
>这里找 global 使用中的实例&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Daily Meditations - W50</title><link>https://www.jsongo.top/articles/meditations-w50/</link><pubDate>Mon, 09 Dec 2024 13:34:29 +0800</pubDate><guid>https://www.jsongo.top/articles/meditations-w50/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/99b74ba8e0135b5536a125e3596d5212.jpg" alt="Featured image of post Daily Meditations - W50" />&lt;h1 id="职业的本质是什么">职业的本质是什么？
&lt;/h1>&lt;p>&lt;!-- raw HTML omitted -->通过帮别人解决问题来获利。&lt;!-- raw HTML omitted -->&lt;br>
该给你多少钱，不是你有多厉害，而是别人的问题有多大。&lt;br>
我们一直以为只有把专业技能，练到炉火纯青的地步才能赚大钱，其实不一定对。不排除这种可能性，那些真正赚钱的是找对了目标问题，然后培养自己能力，最终能越来越好地解决这类问题的人。&lt;br>
简单说，是&lt;!-- raw HTML omitted -->需求决定价格，而不是供给决定价格&lt;!-- raw HTML omitted -->。&lt;/p>
&lt;h2 id="例子">例子
&lt;/h2>&lt;p>同样是销售，卖房子的就是比卖汽水的赚钱。他们的本质都是跟人打交道，找到别人的痛点，把自己的东西包装下卖给别人。&lt;br>
关键在于找对行业。怎么把一瓶水卖出天价，或许能做到这个的人，你会觉得很厉害，不过可能，他只是把水运到了沙漠中去卖而已，会的技能可能就是开车运货，以及经过探索学会了低成本把水运到沙漠、并全身而退的经验。&lt;br>
这或许不只一个人发现了，可能加入的人越来越多，就成了红海。&lt;!-- raw HTML omitted -->我们需要去发现更多的新机会&lt;!-- raw HTML omitted -->。新机会往往出现在新行业。这有点像废话，但更多时候，我们只是看着新行业、新机遇到来，却没什么行动，原来的地方太舒服了，不想动，也或者是因为觉得自己根本玩不来。&lt;/p>
&lt;h1 id="工作中真正有价值的东西">工作中真正有价值的东西
&lt;/h1>&lt;p>真正有价值的东西，是你&lt;!-- raw HTML omitted -->离开现在的工作环境后，你还剩什么&lt;!-- raw HTML omitted -->，还有多少人认可你。你现在的职级、带多少人、老板多看重你，这些都没有价值，它或许能短期能帮助你过得更好，但不是你长期可以保有的东西。某天公司不行了，或者你被迫离开公司后，这些都不再是你的。&lt;/p>
&lt;ul>
&lt;li>职级，在你离开后，只是一个饭后谈资，也可能在下一份职业中帮你得到了一个更好的定位，但前提是真有公司需要，说白了还是得看其它公司的脸色（需求）。&lt;/li>
&lt;li>带多少人，这更没意义了，离开公司，谁记得你曾经带过多少人？&lt;/li>
&lt;li>老板多看重你，这只是他个人的主观看法，离开这个老板（转岗）就没意义了，可能他地位比较高，能在一些事情上帮你一把，但你真离开公司了，他又能为你做啥呢？况且你的离开可能本身就是对他的伤害。&lt;/li>
&lt;/ul>
&lt;p>只要不是老板，你平时的工作更多的是在为别人实现“梦想”。&lt;br>
这里说的“老板”，是指你有不少股权，或从中能得到不错的声誉等，把你跟公司的兴衰绑定在了一起。&lt;br>
“价值”这个事，其实是变化的。&lt;/p>
&lt;ul>
&lt;li>刚毕业时，主要的时间都是在学习，边学习还能边赚钱养活自己，这样就够了。&lt;/li>
&lt;li>等积累多了，成了这方面的资源员工、或团队负责人、或专家，这时你就是在不断运营自己的影响力，让自己被更多人认可，能得到更多的好处。&lt;/li>
&lt;li>之后离开公司了，你留下来的技能、人脉，这些才是你自己的东西，是真正有价值的。&lt;/li>
&lt;/ul></description></item><item><title>开发 Office Add-ins 应用（一）：在 word 里使用大模型</title><link>https://www.jsongo.top/articles/office-add-ins-1/</link><pubDate>Fri, 06 Dec 2024 13:08:16 +0800</pubDate><guid>https://www.jsongo.top/articles/office-add-ins-1/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/8c1ce5c3e62a16997b7cf83e5164726c.jpg" alt="Featured image of post 开发 Office Add-ins 应用（一）：在 word 里使用大模型" />&lt;h1 id="介绍">介绍
&lt;/h1>&lt;p>借助 Office Add-ins 可以在 word 里使用大模型与用户输入的内容做交互。甚至可以尝试接入 RTC 让用户用嘴写作，动口不动手。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/d306f3c989ebb5b3882644abfbd5a49d.webp"
width="500"
loading="lazy"
alt="b453b1cce3c6e66c8f7ee107a10961d5_MD5|500"
>&lt;/p>
&lt;blockquote>
&lt;p>Office Add-ins，中文 “加载项”。&lt;br>
下文中，讲到 Add-ins 主要是指这个技术，提到具体应用时，会用“加载项”概念，主要是指 Office 应用中、下图所示的功能。&lt;/p>
&lt;/blockquote>
&lt;h2 id="概念">概念
&lt;/h2>&lt;p>Office &lt;strong>Add-ins&lt;/strong> 可以理解为是一种可以扩展 Microsoft Office 应用程序（如 Word、Excel、PowerPoint 等）功能的小程序，能增强 Office 应用程序的能力，能与 Office 文档中的内容进行交互。&lt;br>
从技术栈来说，它是基于 Web 技术（如 HTML、CSS 和 JavaScript）构建的，可以利用熟悉的 Web 技术栈来创建它们。&lt;br>
LLM 这两年来的火热，结合强大的内容生产工具套件——Office，其实可以给很多专业的内容工作者带来很大的帮助。&lt;/p>
&lt;h2 id="工作原理">工作原理
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>加载机制&lt;/strong>：用户在 Office 应用程序（如 Excel）中通过特定的界面（如 “插入” 选项卡中的 “我的加载项”）来加载和运行 Office Add-ins。当用户启动时，Office 应用程序会创建一个运行环境，加载相关的 Web 资源（HTML、CSS、JavaScript），并为 Add-ins 提供访问 Office 文档和应用程序功能的接口。&lt;/li>
&lt;li>&lt;strong>交互方式&lt;/strong>：Add-ins 使用 JavaScript 调用 Office JavaScript API，来跟 Office 应用程序进行交互。这个 API 提供了许多对象和方法，允许 Add-ins 读取和写入文档内容、操作 UI 元素（如自定义任务窗格、功能区按钮）等。比如，一个 Word Add-ins 可以使用 API 获取当前文档中的段落数量，或者在文档的特定位置插入文本，或者获取内容然后与 LLM 对话。&lt;/li>
&lt;/ul>
&lt;h2 id="应用场景">应用场景
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>数据可视化&lt;/strong>：可以将复杂的数据以直观的图表或图形形式展示在 Office 文档中。例如，在 Excel 中创建一个加载项，能够根据工作表中的数据自动生成精美的数据可视化图表，而且这些图表可以根据数据的更新而实时变化。&lt;/li>
&lt;li>&lt;strong>协作工具&lt;/strong>：增强 Office 应用程序的协作功能。比如在 Word 文档中添加一个加载项，实现多人同时在线编辑文档时的实时评论和沟通功能，类似于在文档旁边开启一个小型的即时通讯窗口，方便团队成员交流想法。&lt;/li>
&lt;li>&lt;strong>内容生成与自动化&lt;/strong>：帮助用户自动生成文档内容或进行格式设置。以 PowerPoint 为例，一个加载项可以根据用户输入的主题和要点自动生成一套完整的幻灯片，包括添加合适的图表、图片和布局等&lt;/li>
&lt;/ul>
&lt;h2 id="why-add-ins">Why Add-ins
&lt;/h2>&lt;p>官网给了一张图：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/ff7e6c77ddcf6130227a8ba4b47e6875.webp"
loading="lazy"
alt="09c7cc8c5fb5ab19a79d21aac9c36d04_MD5"
>&lt;/p>
&lt;ul>
&lt;li>可以跨端，不同端上都有 Office，你写的功能在不同平台上都可以跑起来&lt;/li>
&lt;li>中心化的分发，不用你自己到处去做上线（如 app Store）&lt;/li>
&lt;li>很容易下载安装&lt;/li>
&lt;li>开发的技术栈也都比较友好（Web）&lt;/li>
&lt;/ul>
&lt;h1 id="市场appsource">市场（AppSource）
&lt;/h1>&lt;p>&lt;a class="link" href="https://appsource.microsoft.com/zh-cn/marketplace/apps?product=office%3Bword&amp;amp;page=1&amp;amp;src=office&amp;amp;corrid=1f1d6156-7354-6d5f-d739-b9841f6e1c48&amp;amp;omexanonuid=&amp;amp;referralurl=&amp;amp;ClientSessionId=e4728826-ce48-4ae1-83a3-f11b7f195f63" target="_blank" rel="noopener"
>业务应用 - Microsoft AppSource&lt;/a>&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/f4e96ef3446b8a5867243039bbea65ee.webp"
loading="lazy"
alt="31a5772abd77fa083a40bbabf855bf21_MD5"
>&lt;br>
可以看到已经有很多 AI 应用了，这个截图还只是首页的前几个应用。有不少官方也都上线了 Office Add-ins 应用，比如 Grammarly、Draw.io、Adobe、Wekipedia、Mermaid 等。生态已经比较成熟了。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/4bf99f0f5b0dbfe9c178f6a779071743.webp"
loading="lazy"
alt="d9eb88a665c0acd52243e001fb941aa8_MD5"
>&lt;br>
过滤了下 Microsoft 365 相关的（如 Excel/Word/OneNote/Outlook/PPT 等）就有 7000+ 个。&lt;/p>
&lt;h1 id="交互形态">交互形态
&lt;/h1>&lt;p>目前看到的主要交互形态有：&lt;br>
1、Excel 等里作为一个嵌入内容显示在表格中。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/0718a4c5c68f59a0dac54be3613db317.webp"
loading="lazy"
>&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/0bdcf9ded954ee9ec42fb3066cf850e8.webp"
width="500"
loading="lazy"
alt="|500"
>&lt;br>
2、Excel/Word/PPT 中作为侧边窗格可以单独进行交互。&lt;/p>
&lt;ul>
&lt;li>这种交互其中有两个操作点，一个是顶部，它也可以触发一个事件；另一个是侧边，本质上它是在侧边开一个类似 Webview 的容器，里面跑 Web 页面。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/8f588b5eba7bcc45fd9d37358ce0ab99.webp"
width="500"
loading="lazy"
alt="|500"
>&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/43b2b8f25fa14664239034833ae828b9.webp"
width="500"
loading="lazy"
alt="|500"
>&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/9ae3d75c01e2fae11e25ab81ed8f6340.webp"
width="500"
loading="lazy"
alt="|500"
>&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/328217d99c5ba98b83784ac03fba1858.webp"
width="500"
loading="lazy"
alt="|500"
>&lt;/li>
&lt;/ul>
&lt;h1 id="开发">开发
&lt;/h1>&lt;h2 id="工具安装">工具安装
&lt;/h2>&lt;h3 id="基础开发环境">基础开发环境
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pnpm install -g yo generator-office
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果没成功可能是依赖 mem-fs，直接安装下就可以：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pnpm install -g mem-fs
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="生成代码">生成代码
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">yo office
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://cdn.jsongo.top/2024/12/308db6a261cf76acf4114a4a78ab2557.webp"
loading="lazy"
alt="091737356a84529f6186ece9c4b25f10_MD5"
>&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/41cedbbf9a12160ae1f0e4368a4dc876.webp"
loading="lazy"
alt="8fc4fc480f6fddbdf826d2095a18622c_MD5"
>&lt;br>
生成后它默认用 npm 来 install，觉得慢的话直接把进程杀掉，然后重新跑 &lt;code>pnpm install&lt;/code>。&lt;br>
后面就是熟悉的 &lt;code>npm run start&lt;/code> 了，写真正的代码逻辑了。&lt;/p>
&lt;h2 id="辅助开发工具">辅助开发工具
&lt;/h2>&lt;p>Office Addin 项目创建和基架工具是 Office 加载项的 Yeoman 生成器，简称为 &lt;code>yo&lt;/code>：&lt;a class="link" href="https://github.com/yeoman/yo" target="_blank" rel="noopener"
>GitHub - yeoman/yo: CLI tool for running Yeoman generators&lt;/a>。&lt;/p>
&lt;h3 id="vs-codecursor-开发插件">Vs code/cursor 开发插件
&lt;/h3>&lt;p>可以安装下这个：&lt;a class="link" href="https://marketplace.visualstudio.com/items?itemName=msoffice.microsoft-office-add-in-debugger" target="_blank" rel="noopener"
>Microsoft Office Add-ins Development Kit&lt;/a>&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/94b2a20f155e46bba502cec36e009b1f.webp"
loading="lazy"
alt="06ed2b1e5c337d53818b449c6a6ead71_MD5"
>&lt;br>
当然也可以用 npm start，不过运行前一定要记得先运行 &lt;code>npm run dev-server&lt;/code>，要不然只是 start 个客户端、背后没服务是跑不起来的。如果一直失败，那直接把所有在 run 的都关掉，word 也退出，运行几次 &lt;code>npm stop&lt;/code> （因为我也遇到了，当时运行了好几次 start，它起了多个背后的进程）。所以其实用插件还是比较方便些，命令行可能会遇到一些想不通的问题。&lt;/p>
&lt;blockquote>
&lt;p>用命令行如果遇到问题，可以参考这里：&lt;a class="link" href="https://learn.microsoft.com/en-us/office/dev/add-ins/quickstarts/word-quickstart-yo" target="_blank" rel="noopener"
>Build your first Word task pane add-in - Office Add-ins | Microsoft Learn&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="script-lab">Script Lab
&lt;/h3>&lt;p>Script Lab 是一种用于快速创建调用 Office JavaScript 库 API 的“原型代码”。&lt;/p>
&lt;blockquote>
&lt;p>Script Lab is a tool for quickly prototyping code that calls the Office JavaScript Library APIs.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>安装时，公司账号可能会用不了，可能跟公司的安全策略有关。最好切换个人账号。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/766add3fe8dd77c7b29ce094a1f8b986.webp"
loading="lazy"
alt="481f65c8228eb4e2a18b297bba34e058_MD5"
>&lt;br>
可以到 &lt;a class="link" href="https://learn.microsoft.com/en-us/office/dev/add-ins/overview/explore-with-script-lab" target="_blank" rel="noopener"
>这里&lt;/a> 或 &lt;a class="link" href="https://appsource.microsoft.com/en-us/product/office/WA104380862" target="_blank" rel="noopener"
>这里&lt;/a> 来直接下载安装，需要登录，这里如果用公司的账号可能会失败，可以尝试下个人的账号。如果是走的公司内部的采购，有个小技巧：公司内部申请下来之后，用它激活，然后退出登录自己的账号，我这么测试了下，用自己账号依然保持着激活状态，看来它激活的是软件本身，跟账号没关系。&lt;br>
第一次登录 AppSource 的话，会有一堆流程，一会儿要认证，一会儿要补充信息……&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/ed446538cfc84f72e0e5b86b639fc8ed.webp"
loading="lazy"
alt="a5222986bf0607d4b24cef11d34a7e99_MD5"
>&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/92fa65ed60838d1e687557ce3418cdc6.webp"
loading="lazy"
alt="6ce02359d39da2d74996140ea160c735_MD5"
>&lt;br>
装完之后，打开 word 就可以看到了：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/8889f62079f35926fb5ab63fe45b0d05.webp"
loading="lazy"
alt="02913cb0e00b47cca7a08800297d3910_MD5"
>&lt;/li>
&lt;/ul>
&lt;h2 id="运行">运行
&lt;/h2>&lt;p>运行起来后，如图所示：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/5020607f6dca911463819e1884f959f0.webp"
loading="lazy"
alt="b71eb2e0a6e37ecb7264538e8b0e8e3c_MD5"
>&lt;br>
Word 是自己弹出来的，vscode 插件背后是起了一个 server （默认在 3000 端口），为侧边这个“页面”提供调试服务。&lt;/p>
&lt;h1 id="限制">限制
&lt;/h1>&lt;p>从生成的代码中可以看出，微软对 Add-ins 其实做了一些环境限制：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/779ca230a5c6deef84980df0246a0c51.webp"
loading="lazy"
alt="8933d8a34dc9ebc2133a5ddb8bbcc6b7_MD5"
>&lt;br>
只有 IE 和 Edge 浏览器内核才能跑，当然 Office 版本也有限制，这个倒还好。&lt;/p>
&lt;h1 id="相关资源">相关资源
&lt;/h1>&lt;ul>
&lt;li>&lt;a class="link" href="https://learn.microsoft.com/en-us/office/dev/add-ins/tutorials/word-tutorial" target="_blank" rel="noopener"
>Word add-in tutorial - Office Add-ins | Microsoft Learn&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Claude MCP 体验</title><link>https://www.jsongo.top/articles/claude-mcp-101/</link><pubDate>Fri, 06 Dec 2024 00:56:02 +0800</pubDate><guid>https://www.jsongo.top/articles/claude-mcp-101/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/b87a43aef0ebf4a4d13f45ad57e9b5d2.jpeg" alt="Featured image of post Claude MCP 体验" />&lt;h1 id="概念">概念
&lt;/h1>&lt;p>MCP 即 Model Context Protocol，模型上下文协议，它能通过借助外部或历史信息，来更高效地构建信息更全面的上下文信息。&lt;br>
这是一个非常重要的协议，刚发布的时候，x 上大家都乐开了花，一个比较典型的说法是“&lt;a class="link" href="https://x.com/eviljer/status/1861333739730804848" target="_blank" rel="noopener"
>村里通网了 - Claude MCP 开启数据连接和操作的新宇宙&lt;/a>”。我一直认为，LLM 要能跟外界真正的能交互起来才能有更大的想像空间。之前见过一些有趣的如操作电脑的辅助 LLM 的工作，还有一些辅助浏览器操作的插件，这次是从协议上就定出一个标准，大家只要按照标准来，都可以相互打通。&lt;/p>
&lt;h1 id="功能">功能
&lt;/h1>&lt;h2 id="介绍">介绍
&lt;/h2>&lt;p>&lt;img src="https://cdn.jsongo.top/2024/11/88311bd3dfca6df4998441df0654ee91.webp"
width="850"
loading="lazy"
alt="图片来自 x|850"
>&lt;/p>
&lt;blockquote>
&lt;p>参考：&lt;a class="link" href="https://x.com/nicekate8888/status/1861323082969030978" target="_blank" rel="noopener"
>Claude秒变Cursor！MCP让AI直接编辑本地文件 | Anthropic MCP实测&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>官方文档：&lt;a class="link" href="https://www.anthropic.com/news/model-context-protocol" target="_blank" rel="noopener"
>Introducing the Model Context Protocol - Anthropic&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="使用">使用
&lt;/h2>&lt;ul>
&lt;li>安装（以 Mac 来讲）
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">brew install uv git sqlite3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>然后下载 Claude &lt;a class="link" href="https://claude.ai/download" target="_blank" rel="noopener"
>桌面端&lt;/a>，&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>开启
&lt;ul>
&lt;li>如何启用具体可以参考：[[https://modelcontextprotocol.io/quickstart#installing-prerequisites-macos]]&lt;/li>
&lt;li>简单说，这个功能桌面端才有，Mac 上可以打开 &lt;code>~/Library/Application Support/Claude/claude_desktop_config.json&lt;/code> 编辑下这个 JSON 文件，然后重启下 Claude 客户端就自动启用了。往 JSON 文件里写内容：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;mcpServers&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;sqlite&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;command&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;uvx&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;args&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;mcp-server-sqlite&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;--db-path&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;/Users/&amp;lt;my-user-name&amp;gt;/claude.db&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="示例">示例
&lt;/h2>&lt;p>官方给的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Create a new SQLite database&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sqlite3 ~/claude.db &lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">CREATE TABLE products (
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> id INTEGER PRIMARY KEY,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> name TEXT,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> price REAL
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">INSERT INTO products (name, price) VALUES
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Widget&amp;#39;, 19.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Gadget&amp;#39;, 29.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Gizmo&amp;#39;, 39.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Smart Watch&amp;#39;, 199.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Wireless Earbuds&amp;#39;, 89.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Portable Charger&amp;#39;, 24.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Bluetooth Speaker&amp;#39;, 79.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Phone Stand&amp;#39;, 15.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Laptop Sleeve&amp;#39;, 34.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Mini Drone&amp;#39;, 299.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;LED Desk Lamp&amp;#39;, 45.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Keyboard&amp;#39;, 129.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Mouse Pad&amp;#39;, 12.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;USB Hub&amp;#39;, 49.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Webcam&amp;#39;, 69.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Screen Protector&amp;#39;, 9.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Travel Adapter&amp;#39;, 27.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Gaming Headset&amp;#39;, 159.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Fitness Tracker&amp;#39;, 119.99),
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> (&amp;#39;Portable SSD&amp;#39;, 179.99);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>创建一个表，然后往里面写一些数据。&lt;/p>
&lt;h2 id="运行">运行
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">uvx mcp-server-sqlite
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它会用 &lt;a class="link" href="https://docs.astral.sh/uv/guides/tools/" target="_blank" rel="noopener"
>uvx&lt;/a> 来运行 mcp 服务。&lt;br>
Prompt Demo:&lt;br>
&lt;code>Can you connect to my SQLite database and tell me what products are available, and their prices?&lt;/code>&lt;/p>
&lt;h1 id="原理">原理
&lt;/h1>&lt;p>其实就是加了一个 MCP server 作为本地代理，架构如下：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/11/fe0e494830be8e36f62559f1729cb921.webp"
width="725"
loading="lazy"
alt="|725"
>&lt;br>
MCP 是一个开放协议：&lt;/p>
&lt;ul>
&lt;li>首先会建立与外部数据源的连接。它使用预定义的接口和数据格式来识别和访问这些外部源。例如，当需要从一个关系型数据库获取信息来为语言模型（LLM）提供上下文时，MCP 会通过数据库驱动程序按照数据库的协议（如 SQL）进行通信，检索数据。&lt;/li>
&lt;li>另一方面 MCP 也类似 Prompt 模板一样，提供了&lt;strong>动态上下文构建&lt;/strong>的能力：
&lt;ul>
&lt;li>MCP 能够留空的方式，动态地构建上下文。&lt;/li>
&lt;li>例如，在聊天界面应用中，当用户询问一个关于特定产品的问题时，MCP 可以快速从产品数据库中获取产品的规格、用户评价等相关信息，并将这些信息组合成一个有意义的上下文提供给 LLM。&lt;/li>
&lt;li>还可以根据用户的交互历史来调整上下文。&lt;br>
它本身会不断更新和优化提供给 LLM 的上下文，确保 LLM 能够跟上用户的思路，通过这些方式，MCP 能提高 LLM 的工作效率和回答质量。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>图像生成：角色场景形象适配</title><link>https://www.jsongo.top/articles/ipadapter-lora-controlnet/</link><pubDate>Sun, 01 Dec 2024 11:29:47 +0800</pubDate><guid>https://www.jsongo.top/articles/ipadapter-lora-controlnet/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/3c463375cc35ddc5e78d71b95ddcbd51.jpeg" alt="Featured image of post 图像生成：角色场景形象适配" />&lt;hr>
&lt;h1 id="几种方案">几种方案
&lt;/h1>&lt;h2 id="ip-adapter">IP-Adapter
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>原理&lt;/strong>：IP-Adapter 的核心是其 “解耦交叉注意力机制”，它将文本特征和图像特征的处理分开，为每种输入类型创建了不同的路径，从而能够更好地将视觉提示信息整合到模型中，同时不影响模型对文本指令的理解和执行能力。通过这种机制，IP-Adapter 可以识别参考图的艺术风格、内容以及特定的角色形象等信息，并生成与之相似的作品。&lt;/li>
&lt;li>&lt;strong>使用方式&lt;/strong>：以 Stable Diffusion 为例，需先下载对应版本的 IP-Adapter 预处理器和模型，如 sd1.5 版本的 “ip-adapter_clip_sd15” 预处理器及相关模型。在使用时，将打斗场景图作为输入图像，将角色形象图作为参考图，通过调整相关参数和权重，IP-Adapter 就能根据角色形象图的特征对打斗场景图中的角色进行适配和修改，生成符合预期的新图像。&lt;/li>
&lt;/ul>
&lt;h2 id="dreambooth">DreamBooth
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>原理&lt;/strong>：DreamBooth 是一种基于扩散模型的微调技术，它允许用户使用少量的特定主题图像（如你的角色形象图）对预训练的文本到图像生成模型进行微调，使模型能够学习到与该主题相关的特定特征和细节，从而在生成图像时能够更准确地生成符合该主题的内容。&lt;/li>
&lt;li>&lt;strong>使用方式&lt;/strong>：首先收集包含角色形象的高质量图像数据集，然后选择一个预训练的基础模型，如 Stable Diffusion 等。使用 DreamBooth 技术对基础模型进行微调，将角色形象与特定的唯一标识符绑定，让模型学习到角色的特征。最后，将微调后的模型应用于打斗场景图，通过输入相关的文本提示，模型会根据学习到的角色特征对场景图中的角色进行适配和生成。&lt;/li>
&lt;/ul>
&lt;h2 id="lora-low-rank-adaptation-of-large-language-models">LoRA (Low-Rank Adaptation of Large Language Models)
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>原理&lt;/strong>：LoRA 的基本思想是通过在大型语言模型的基础上，添加少量的可训练参数来实现对模型的微调，从而在保持模型原有性能的基础上，快速适应特定的任务或领域。对于图像生成任务，同样可以利用类似的原理，通过对预训练的图像生成模型添加 LoRA 模块，使其能够根据特定的角色形象图进行微调，学习到角色的特征表示，进而在生成图像时能够更好地适配这些角色形象。&lt;/li>
&lt;li>&lt;strong>使用方式&lt;/strong>：先确定预训练的图像生成模型，然后针对你的角色形象图准备相应的数据集。接着，设计并训练适合该模型的 LoRA 模块，使其能够捕捉到角色形象的关键特征。在实际应用中，将训练好的 LoRA 模块与预训练模型结合，输入包含打斗场景和角色相关的文本提示，模型就会根据 LoRA 模块中学习到的角色特征，对场景图中的角色进行相应的适配和生成。&lt;/li>
&lt;/ul>
&lt;h2 id="controlnet">ControlNet
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>原理&lt;/strong>：ControlNet 是一种用于控制图像生成过程的神经网络架构，它可以通过添加额外的条件控制信息来引导图像生成模型生成符合特定要求的图像。在你的需求中，可以将角色形象图作为 ControlNet 的输入条件，通过网络中的特定模块对生成过程进行约束和引导，使生成的打斗场景图中的角色能够更好地适配给定的角色形象.&lt;/li>
&lt;li>&lt;strong>使用方式&lt;/strong>：选择合适的 ControlNet 预训练模型，并将其与基础的图像生成模型结合，如 Stable Diffusion。将打斗场景图作为基础图像输入，同时将角色形象图作为 ControlNet 的条件输入，通过调整 ControlNet 中的各种参数和权重，如控制线条、色彩、形状等方面的参数，来精确控制生成的图像中角色的外观和姿态，使其与给定的角色形象相匹配。&lt;/li>
&lt;/ul>
&lt;h1 id="成本分析">成本分析
&lt;/h1>&lt;ul>
&lt;li>&lt;strong>IP-Adapter&lt;/strong>：IP-Adapter 无需进行模型训练，主要成本在于寻找符合预期的参考图，其成本相对较低，能在几分钟内看到结果，大大节省了时间。&lt;/li>
&lt;li>&lt;strong>DreamBooth&lt;/strong>：训练成本相对较高，需要至少 20 张不同角度的人物图像，并且对硬件要求较高，至少需要 24GB 的显存以及性能较好的 GPU，若使用云服务训练则还需额外产生费用。&lt;/li>
&lt;li>&lt;strong>LoRA&lt;/strong>：LoRA 可以冻结预训练模型的全部参数权重，然后只在新增的网络层去做训练，训练数据量可根据具体需求而定，因此成本相对较低。&lt;/li>
&lt;li>&lt;strong>ControlNet&lt;/strong>：ControlNet 的训练成本相对较高。例如，其 canny edge detector 模型的训练需要 300 万张边缘 - 图像 - 标注对的语料，在 A100 80g 的环境下要花费 600 个 gpu 小时；human pose 模型则需 8 万张姿态 - 图像 - 标注对的语料及 400 个 gpu 时。&lt;/li>
&lt;/ul>
&lt;h1 id="思路">思路
&lt;/h1>&lt;h2 id="lora">LoRA
&lt;/h2>&lt;h3 id="过拟合问题">过拟合问题
&lt;/h3>&lt;p>需要准备多张形象比较一致的图片，要不然只有一张图会有&lt;strong>过拟合问题&lt;/strong>，以及&lt;strong>特征不全面&lt;/strong>的问题。简单说，仅靠一张图片，LoRA 可能无法学习到角色的完整特征，导致在生成场景图中角色的其他角度或状态时出现不匹配的情况。例如，角色在训练图片中是正面微笑的形象，在生成侧面打斗场景时，可能会出现面部结构变形或者表情不自然的问题。&lt;br>
这个方法可以作为后续优化的方向，当可以生成多张形象一致的图片时，再来试试这个思路。&lt;/p>
&lt;h3 id="猫箱类软件">猫箱类软件
&lt;/h3>&lt;p>这些软件会让使用者先上传几张自己的图片，之后它其实会拿这些去做 LoRA 训练（也可能是其它方式的微调， 如 DreamBooth），之后再用这个用户专属的模型去生成他后续的各场景图。这类软件使用方式上，稍微有些麻烦，因为上传图片用户得好好挑挑，都上传同一时间或穿着、光线下的图片时，其实效果也一般也容易过拟合。不过训练完后，就可以非常自由的生成非常丰富、多样的场景下的个人图片，弄得好的话非常逼真，真假难辨。&lt;/p>
&lt;h2 id="controlnet-1">ControlNet
&lt;/h2>&lt;h3 id="硬件要求">硬件要求
&lt;/h3>&lt;p>ControlNet 需要一定的硬件支持来运行，由于它在原始扩散模型基础上增加了控制模块，对 GPU 等硬件资源的需求相对较高，特别是在处理复杂的控制条件和高分辨率图像生成时，可能需要更强大的 GPU 来保证生成速度和质量。&lt;/p>
&lt;h3 id="时间成本">时间成本
&lt;/h3>&lt;p>训练 ControlNet 所需的时间较长，从数据收集、标注到模型训练完成，整个过程可能需要数天甚至数周，这取决于训练数据的规模和硬件设备的性能。&lt;/p>
&lt;blockquote>
&lt;p>总体看，成本上不一定划得来。相比之下，IP-Adapter 不需要训练模型，只需找到符合预期的参考图即可开始生成，大大节省了时间和资源，能够在几分钟内看到结果，其模型参数只有 22m，存储占用小，对硬件资源的要求相对较低，下面展开讲下&lt;/p>
&lt;/blockquote>
&lt;h2 id="ip-adapter-1">IP-Adapter
&lt;/h2>&lt;p>IP-Adapter 确实有其独特的优势，使其成为一种很有吸引力的图像生成辅助方法，以下是对其优点的详细介绍。&lt;/p>
&lt;h3 id="无需训练模型">无需训练模型
&lt;/h3>&lt;p>与需要收集大量数据并进行长时间训练的 LoRA 等方法不同，IP-Adapter 不需要训练模型，大大节省了时间和资源，仅需找到符合预期的参考图即可开始生成，能在几分钟内看到结果，效率极高。&lt;/p>
&lt;h3 id="单图即可实现风格迁移">单图即可实现风格迁移
&lt;/h3>&lt;p>只需一张图片就能实现风格迁移，将该图片的风格特征融入到生成的图像中。例如，如果有一张具有独特画风的角色图片，IP-Adapter 可以把这种画风应用到新生成的打斗场景图中，让场景图中的角色呈现出与参考图一致的风格，为生成特定风格的图像提供了极大的便利。&lt;/p>
&lt;h3 id="支持多图多特征提取">支持多图多特征提取
&lt;/h3>&lt;p>可以同时读取多张参考图，并提取它们的特征，从而使生成的结果拥有更丰富的多样性和随机性。比如，你有几张同一角色在不同状态下的图片，IP-Adapter 能够综合这些图片的特征，生成更全面、更具变化的角色形象，使其在打斗场景中的表现更加自然和丰富。&lt;/p>
&lt;h3 id="与-prompt-配合度高">与 Prompt 配合度高
&lt;/h3>&lt;p>对 Prompt 有强注意力，能使 Prompt 中的信息更直观地反映在生成结果中。用户可以通过替换 Prompt 里的关键词，在继承参考图风格的同时，指向不同的结果，形成 Prompt 的组合矩阵，进一步拓展生成结果的多样性。例如，在生成打斗场景图时，通过修改 Prompt 中的关键词，如 “激烈打斗”“轻松打斗” 等，可以生成不同氛围和情节的场景图，且都带有参考图的风格特征。&lt;/p>
&lt;h3 id="兼容性强">兼容性强
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>适配多种基础模型&lt;/strong>：IP-Adapter 基于预训练的文本到图像扩散模型开发，具有很强的通用性和兼容性，可以适配 Stable Diffusion 等多种基础模型，而无需针对不同的基础模型进行重新训练或调整.&lt;/li>
&lt;li>&lt;strong>可与 ControlNet 等结合&lt;/strong>：能够与 ControlNet 等其他可控生成工具结合使用，实现更强大的图像生成控制能力。比如，通过 ControlNet 可以对生成图像的线条、边缘等细节进行控制，再结合 IP-Adapter 的风格迁移和内容引导，能够生成更加精细、准确且符合风格要求的图像。&lt;/li>
&lt;/ul>
&lt;h3 id="模型参数小">模型参数小
&lt;/h3>&lt;p>IP-Adapter 本身的模型参数只有 22M，存储占用小，对硬件资源的要求相对较低，在普通的硬件设备上也能够较为流畅地运行，降低了使用门槛，更便于广泛应用和推广。&lt;/p>
&lt;h1 id="方案选择">方案选择
&lt;/h1>&lt;p>最终还是决定先用 IP-Adapter 来推进。&lt;/p></description></item><item><title>Flux 图像生成模型</title><link>https://www.jsongo.top/articles/flux-101/</link><pubDate>Sun, 24 Nov 2024 23:31:34 +0800</pubDate><guid>https://www.jsongo.top/articles/flux-101/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/2679aa8e01ac3a9721f4b6f4e919a651.jpg" alt="Featured image of post Flux 图像生成模型" />&lt;h1 id="flux-基础">Flux 基础
&lt;/h1>&lt;blockquote>
&lt;p>Flux 是多模态和并行扩散 Transformer 块的混合架构，拥有 120 亿参数，是目前最大的开源文本到图像模型之一，能够生成高质量、细节丰富且风格多样的图像。&lt;br>
性能和效果可以与 Midjourney V6 媲美。&lt;br>
Flux 一般通过 ComfyUI 来调用。&lt;/p>
&lt;/blockquote>
&lt;h2 id="黑森林实验室与团队背景">黑森林实验室与团队背景
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>核心成员&lt;/strong>：黑森林实验室由 Stable Diffusion 的核心开发者 Robin Rombach 领衔创立，团队成员大多来自 Stability AI，如 Andreas Blattmann、Axel Sauer 等多位原 Stable Diffusion 项目的关键人物，他们在生成式模型开发领域经验丰富，为 Flux 的诞生奠定了坚实基础。大家可能听说过 Stability AI 团队内部不和，各种破事把公司折腾得够呛，所以由原班核心人马出来创业做的 Flux 受到很大的关注。&lt;/li>
&lt;li>&lt;strong>融资情况&lt;/strong>：这个实验室已获得 3200 万美元的种子轮融资，由著名风投机构 Andreessen Horowitz (a16z) 领投，多位业内知名人士参与投资，充足的资金支持使其能够大力推进模型的研发与优化等工作。主要还是因为它的背景实在太好了。&lt;/li>
&lt;/ul>
&lt;h2 id="flux-模型特点">Flux 模型特点
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>架构与参数&lt;/strong>：Flux 基于多模态和并行扩散 Transformer 块的混合架构，拥有 &lt;!-- raw HTML omitted -->120 亿参数&lt;!-- raw HTML omitted -->，是目前最大的开源文本到图像模型之一。这种架构和庞大的参数规模使其能够学习到更丰富的图像特征和语义信息，从而生成高质量的图像。&lt;/li>
&lt;li>&lt;strong>性能优势&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>图像质量&lt;/strong>：在视觉质量、图像细节和输出多样性等方面达到了新高度，生成的图像更加逼真、细腻，细节丰富度高，风格多样，能与闭源的 Midjourney v6.1 模型不相上下，甚至在一些方面表现更优，如复杂场景生成、人物细节处理等。&lt;/li>
&lt;li>&lt;strong>提示词遵循能力&lt;/strong>：对提示词的理解和遵循能力很强，能够准确地根据输入的文本描述生成符合要求的图像，包括对复杂指令、长文本描述以及特定场景和细节要求的准确呈现，减少了因提示词理解不准确而导致的图像与预期不符的问题。&lt;/li>
&lt;li>&lt;strong>文字生成能力&lt;/strong>：在图像中生成文字的效果出色，可以处理重复字母等棘手情况，生成的文字内容准确、排版合理，这在一些需要在图像中呈现文字信息的场景中具有很大优势，如生成带有文字标识的产品图片、包含文字说明的场景图片等。&lt;/li>
&lt;li>&lt;strong>手部细节处理&lt;/strong>：相较于之前的一些模型，Flux 在手部细节生成上有了显著改进，减少了手指等部位的畸形或错误，使生成的人物图像更加自然、真实。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>不同版本特点&lt;/strong>：&lt;br>
有 3 个核心版本，Pro/dev/schnell
&lt;ul>
&lt;li>&lt;strong>FLUX (pro)&lt;/strong>：闭源模型，自家压箱底的货。具备最佳性能，包括最先进的提示跟随能力、视觉质量、图像细节和输出多样性，适用于专业用户和对图像质量要求极高的场景，可通过注册官方 API 申请访问权限，同时支持企业定制。&lt;/li>
&lt;li>&lt;strong>FLUX (dev)&lt;/strong>：开源模型，不可商用，直接从 FLUX (pro) 蒸馏而来，具备相似的图像质量和提示词遵循能力，但更高效，适合开发者进行研究和实验等非商业用途的使用。&lt;/li>
&lt;li>&lt;strong>FLUX (schnell)&lt;/strong>：开源模型，可&lt;!-- raw HTML omitted -->商用&lt;!-- raw HTML omitted -->，专门为本地开发和个人使用量身定制，生成速度最快，内存占用最小，是个人用户体验和进行简单开发测试的不错选择。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>初识 Diffusion（概念）</title><link>https://www.jsongo.top/articles/diffusion-101/</link><pubDate>Sun, 24 Nov 2024 11:26:10 +0800</pubDate><guid>https://www.jsongo.top/articles/diffusion-101/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/96539755245eb88510f037ed2d24f60d.jpeg" alt="Featured image of post 初识 Diffusion（概念）" />&lt;p>Diffusion（扩散模型）是一类生成式模型，在机器学习和人工智能领域应用广泛，特别是在图像生成、语音合成等领域发挥了重要作用。&lt;/p>
&lt;h1 id="model--checkpoint">Model &amp;amp; Checkpoint
&lt;/h1>&lt;p>开源模型发布出来的文件一般都很大，里面包含了很多模型参数、快照等。Model 和 checkpoint 在开源这个层面上，两个概念可以认为大体上是等价的，只不过我们一般不叫 checkpoint，而是说某个 model 开源了。&lt;/p>
&lt;ul>
&lt;li>Model 是一个比较抽象的概念，它包括模型的架构（例如神经网络中的层数、每层神经元数量、连接方式等）和训练目标（例如是进行分类任务、生成任务还是回归任务）&lt;/li>
&lt;li>Checkpoint 是在模型训练过程中定期保存的模型参数快照，与 Model 密切相关。Checkpoint 包含了 Model 的架构定义、参数值、优化器状态以及训练过程的元数据等，是对 Model 在特定训练阶段状态的完整记录。&lt;/li>
&lt;/ul>
&lt;h1 id="clip">CLIP
&lt;/h1>&lt;h2 id="概念">概念
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>CLIP 模型&lt;/strong>：CLIP 是 Contrastive Language-Image Pre-training 的缩写，由 OpenAI 在 2021 年 1 月 5 日发布，是一种将计算机视觉与自然语言处理相结合的神经网络模型。
&lt;ul>
&lt;li>它通过对 400,000,000 组（图像，文本）对数据进行预训练，从而能够在给定图像的情况下，根据自然语言指令预测出最相关的文本片段，展现出了类似 GPT-2 和 GPT-3 的 zero-shot 学习能力，即模型可以在未针对特定任务进行直接优化训练的情况下，对未曾见过的数据类别进行较好地预测&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>CLIP Vision&lt;/strong>：CLIP Vision 主要负责处理视觉信息，也就是对输入的图像数据进行特征提取和编码等操作，将图像转化为模型能够理解和处理的向量表示，以便与文本信息进行对比学习和关联。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>
&lt;ul>
&lt;li>例如，在图像生成领域，CLIP Vision 可以帮助模型理解图像的内容和特征，从而生成更符合语义描述的图像。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>CLIP Text&lt;/strong>：我们常看到的这个 CLIP Text 概念，主要是指作为参考文本来对图像进行调整的文本描述。&lt;/li>
&lt;/ul>
&lt;h2 id="应用">应用
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>图像生成&lt;/strong>：如在 Paints-Undo 项目中，CLIP Vision 作为模型架构的一部分，与其他组件共同作用，通过对输入图像的处理和分析，为生成模拟人类绘画过程的动画提供视觉信息基础，帮助模型理解图像的内容和结构，从而更准确地生成绘画过程中的各个中间状态。&lt;/li>
&lt;li>&lt;strong>图像分类与标注&lt;/strong>：可以根据图像的视觉特征，结合预训练时学习到的图像与文本的关联，对未见过的图像进行分类或自动生成相应的文本标注，例如判断一张图片是风景照、人物照还是动物照，并给出相应的文字描述。&lt;/li>
&lt;li>&lt;strong>图像检索&lt;/strong>：基于 CLIP Vision 对图像特征的提取和与文本的关联能力，可以实现根据文本描述来检索相关的图像，或者根据图像来查找与之语义相关的文本信息，提高图像检索的准确性和效率。&lt;/li>
&lt;li>&lt;strong>视觉问答系统&lt;/strong>：帮助系统理解图像中的视觉内容，结合对自然语言问题的理解，生成准确的文本答案，例如回答关于图像中物体的位置、颜色、数量等问题 。&lt;/li>
&lt;/ul>
&lt;h1 id="vae">VAE
&lt;/h1>&lt;p>VAE 主要用于将图像数据压缩到一个潜在空间，然后再从这个潜在空间中生成新的图像，侧重于图像的生成和重建。&lt;/p>
&lt;h2 id="latent-image">Latent Image
&lt;/h2>&lt;p>经过某种变换或编码后隐藏在数据中的图像信息。例如，在使用变分自编码器（VAE）进行图像生成或处理时，图像数据会被压缩到一个潜在空间（latent space），这个潜在空间中的向量可以被看作是潜像的一种表示形式。这些潜像向量包含了图像的关键特征，如形状、颜色、纹理等信息，通过解码器可以将这些潜像向量转换回可见的图像。&lt;/p>
&lt;h1 id="lora">Lora
&lt;/h1>&lt;p>LoRA 是一种用于微调预训练模型的技术，通过在原始模型的基础上添加少量可训练的参数来实现对模型的微调。&lt;/p>
&lt;hr>
&lt;h1 id="footnotes">Footnotes
&lt;/h1>&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>简单说就是，主要用于处理和理解图像信息，能够提取图像的特征表示，进而与文本特征进行对比和匹配等操作，以实现如根据文本描述生成相应图像、图像分类、图像检索等多种与图像和文本相关的任务&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>About me</title><link>https://www.jsongo.top/about/</link><pubDate>Fri, 22 Nov 2024 00:48:28 +0800</pubDate><guid>https://www.jsongo.top/about/</guid><description>&lt;img src="https://cdn.jsongo.top/2024/11/57bb06afa963ce540f0629c84f866978.png" alt="Featured image of post About me" />&lt;p>一个很普通的程序员，喜欢折腾，喜欢看书和思考。&lt;/p></description></item><item><title>Stable Diffusion 生图技术（一）</title><link>https://www.jsongo.top/articles/stable-diffusion-gen-image-1/</link><pubDate>Tue, 19 Nov 2024 16:36:27 +0800</pubDate><guid>https://www.jsongo.top/articles/stable-diffusion-gen-image-1/</guid><description>&lt;img src="https://cdn.jsongo.top/banners/772c64fbb07e3cd46573602f922a7829.jpg" alt="Featured image of post Stable Diffusion 生图技术（一）" />&lt;h1 id="概述">概述
&lt;/h1>&lt;h2 id="背景">背景
&lt;/h2>&lt;p>Stable Diffusion 最初是由德国慕尼黑大学的 CompVis 研究小组、纽约的 RunwayML 公司等组成的国际研究团队开发的，后来 Stability AI 参与其中并推动了其发展。&lt;br>
Stable Diffusion 的发展历程如下：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/afb65322de6b531c0c01e86e6d27c0e0.webp"
width="900"
loading="lazy"
alt="|900"
>&lt;/p>
&lt;h2 id="技术简介">技术简介
&lt;/h2>&lt;p>Stable Diffusion 在模型架构中采用了 Transformer 架构的一些特性，基于扩散模型架构来生成图片。&lt;br>
它的原理用白话说，比较简单：加噪和去噪（专业术语叫前向扩散和反向扩散）。加噪后的图片主要用于训练或作为初始输入（latent），然后训练一个模型去实现某些图像生成目标（去噪过程）。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>前向扩散&lt;/strong>：在前向阶段，通过向原始图像数据（如真实的照片或绘画）添加噪声，逐步将图像转换为纯噪声。这个过程是在多个时间步（time - steps）中完成的，每一步都按照一定的规则（通常是基于高斯分布）添加噪声，使得图像信息逐渐被噪声掩盖。例如，开始时图像可能还比较清晰，随着时间步的增加，图像越来越模糊，最终变成完全的噪声。&lt;/li>
&lt;li>&lt;strong>反向扩散&lt;/strong>：这是生成图像的关键阶段。从纯噪声开始，模型通过学习到的去噪过程，逐步恢复图像信息。模型会预测每个时间步中需要去除的噪声，经过多个时间步的迭代，最终生成一张类似于训练数据分布的图像。这个过程类似于从无序的噪声中逐渐 “雕刻” 出有意义的图像。&lt;/li>
&lt;/ul>
&lt;h1 id="生图过程">生图过程
&lt;/h1>&lt;p>&lt;img src="https://cdn.jsongo.top/2024/11/d66a5473be54d712b3aa8e879f9a8c3a.webp"
width="700"
loading="lazy"
alt="|700"
>&lt;/p>
&lt;h2 id="模型-checkpoint跟采样的关系">模型 （Checkpoint）跟采样的关系
&lt;/h2>&lt;p>Checkpoint 包含了模型在特定训练阶段的所有权重、偏置以及优化器的状态等信息，而采样模型的参数是由 Checkpoint 所确定的，采样模型使用该 Checkpoint 中存储的权重和其他参数进行计算。不同的 Checkpoint 会导致采样模型在生成图像时表现出不同的性能和风格。例如，某些 Checkpoint 可能侧重于生成高分辨率的图像，而另一些可能更擅长生成具有特定艺术风格的图像。这是因为在训练过程中，不同的 Checkpoint 所对应的训练数据和训练目标可能有所不同，从而影响了采样模型的行为。&lt;/p>
&lt;h2 id="clip-text-encode">CLIP Text Encode
&lt;/h2>&lt;p>属于 Condition 节点，它用 CLIP 模型对文本 Prompt 进行编码，对模型生成的结果进行方向上的引导，其实可能理解为文本模型中的 embedding。&lt;/p>
&lt;h2 id="采样">采样
&lt;/h2>&lt;p>生图其实就是一个反向扩散的过程，从一个完全是噪声的图像开始，通过模型逐步去除噪声来生成图像。这个过程通过一个采样函数来实现，它基于模型预测的噪声来更新噪声图像。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/12/dd2433499e7a9229aa5bd816177c8988.webp"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Steps&lt;/strong>，迭代生图，每次更新噪声图像，需要经过多个 Step 的迭代。随着 Step 反复执行，图像中的噪声逐渐减少，最终生成一个近似原始图像分布的图像。不过生成的图像质量可能会受到多种因素的影响，如模型的性能、采样方法、时间步数等。在实际应用中，可能需要对生成的图像进行后处理（如调整颜色、对比度等）来提高图像质量。&lt;/li>
&lt;li>&lt;strong>seed&lt;/strong>，种子值，用于初始化随机数生成器。相同的种子值在相同的模型和参数设置下会生成相同的图像，这有助于复现结果。&lt;/li>
&lt;li>&lt;strong>control_after_generate&lt;/strong>：这个参数可能与生成后的控制操作有关，例如对生成的图像进行随机化处理&lt;/li>
&lt;li>&lt;strong>steps&lt;/strong>：指生成过程中的迭代步数。步数越多，生成的图像通常会越精细，但也会增加计算时间。&lt;/li>
&lt;li>&lt;strong>cfg&lt;/strong>（Classifier-Free Guidance）：无分类器引导的强度，它是一种在生成式模型（如 Stable Diffusion）中用于引导图像生成方向的技术，决定了模型在生成图像时对正向提示（你希望在图像中出现的内容）的遵循程度。较高的 CFG 值会使生成的图像更紧密地遵循正向 Prompt，但也有可能导致图像过度拟合。
&lt;ul>
&lt;li>取值范围：
&lt;ul>
&lt;li>CFG 的值通常在 1 到 20 之间，理论上可以取更高的值，但在实际应用中，过高的值往往会导致图像质量下降。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>较低值（1 - 4）：
&lt;ul>
&lt;li>当 CFG 值较低时，生成的图像会更具随机性和创造性。模型对正向提示的遵循程度较弱，因此可能会生成一些与提示不太相关但具有独特创意的图像。这种情况下，图像可能会包含一些意外的元素或风格。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>中等值（4 - 10）：
&lt;ul>
&lt;li>在这个范围内，是比较常用的取值。模型会在遵循正向提示和保持一定的创造性之间取得较好的平衡。能够生成与提示较为符合的图像，同时也不会显得过于刻板。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>较高值（10 - 20）：
&lt;ul>
&lt;li>当 CFG 值较高时，生成的图像会非常紧密地遵循正向提示。这可能会导致图像过于 “完美” 地符合提示，但也可能会出现一些问题，比如图像的细节可能会显得不自然，色彩可能会过于饱和，或者图像可能会失去一些自然的随机性和美感&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>sampler_name&lt;/strong>：这是指采样器的名称。不同的采样器（如 Euler、Langevin 等）有不同的特性，会影响图像生成的速度和质量。&lt;/li>
&lt;li>&lt;strong>scheduler&lt;/strong>：调度器，用于控制生成过程中的步长和其他参数。不同的调度器会影响生成的效率和结果。&lt;/li>
&lt;li>&lt;strong>denoise&lt;/strong>：去噪参数控制生成过程中对噪声的去除程度。较低的去噪值会使生成的图像更具随机性，而较高的值会使图像更平滑和可预测。&lt;/li>
&lt;/ul>
&lt;h2 id="vae-decoder变分自解码器">VAE Decoder（变分自解码器）
&lt;/h2>&lt;p>图像数据往往是高维的，包含大量的像素信息，所以一般训练和计算时，往往要压缩到低维来处理，用更紧凑的方式表示图像的关键特征，就像文本模型中的 Embedding 处理，变成稠密的数据，在图像处理领域叫潜在空间（Latent Space）。而解码器则是将潜在空间中的表示再转换回图像数据空间，尽可能地重建原始图像。&lt;br>
生成新图的过程，由于潜在空间是连续的，稍微改变潜在空间中的向量值，就可以生成与原始图像在某些特征上有所变化的新图像。例如，在生成人脸图像的 VAE 模型中，在潜在空间中沿着某个方向移动向量可能会改变人脸的表情、发型或者年龄等特征。&lt;/p>
&lt;h2 id="latent-image">Latent Image
&lt;/h2>&lt;p>一般在整个 ComfyUI 流程中，会插入一张空的（Empty） Lantent Image，它提供了一个初始的 “画布”，让模型在这个基础上进行生成或转换操作。&lt;br>
当然如果是对已有的图片进行调整、修复或优化，则可以把空的图换成一张现成的图片，这时就要把它加载并转换为合适的潜在表示形式后，可以作为生成过程的起点。在 ComfyUI 中，可能涉及到将图片通过适当的预处理步骤，如调整大小、归一化等操作后，然后将其编码为潜在空间中的表示，这样就可以基于已有的图像内容进行修改、风格转换或者其他生成操作。&lt;/p>
&lt;h1 id="stability-ai-官方">Stability AI 官方
&lt;/h1>&lt;p>Stable Diffusion 的官方可用的模型，可以从 API 文档中看到： &lt;a class="link" href="https://platform.stability.ai/pricing" target="_blank" rel="noopener"
>Stability AI - Developer Platform&lt;/a>。最新的是 SD 3.5（2024 年 11 月）。&lt;/p>
&lt;ul>
&lt;li>1 credit = $0.01&lt;/li>
&lt;li>这么算，生成一张 SD 3.5 的图片，medium 要 $0.035，差不多 0.25 元，4 张 1 块。&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/11/207f1abc8b1be591d3f76ec236344c3c.webp"
width="700"
loading="lazy"
alt="736deaffc1c02497df089d14539fba5d_MD5|700"
>&lt;/li>
&lt;/ul>
&lt;h2 id="体验">体验
&lt;/h2>&lt;p>&lt;a class="link" href="https://stabledifffusion.com/tools/ai-image-generator" target="_blank" rel="noopener"
>Free AI Image Generator - Turn Text to Image Online | Stable Diffusion Online&lt;/a>&lt;/p>
&lt;h1 id="字节的-lighting-模型">字节的 Lighting 模型
&lt;/h1>&lt;p>&lt;a class="link" href="https://huggingface.co/ByteDance/SDXL-Lightning" target="_blank" rel="noopener"
>ByteDance/SDXL-Lightning at main&lt;/a> 字节的这个模型生成效果相当不错。&lt;br>
它同时提供了 Full UNet 和 LoRA 版本，都是相对比较小的蒸馏模型（虽然 UNet 也有几个 G）。&lt;/p>
&lt;blockquote>
&lt;p>We provide both full UNet and LoRA checkpoints. The full UNet models have the best quality while the LoRA models can be applied to other base models.&lt;/p>
&lt;/blockquote>
&lt;h2 id="小科普可跳过">小科普（可跳过）
&lt;/h2>&lt;h3 id="概念">概念
&lt;/h3>&lt;ul>
&lt;li>UNet 是卷积神经网络（CNN）的一种特殊架构，在生成对抗网络 (GANs) 和扩散模型中广泛使用。它是一种完整的网络架构，专门用于图像分割任务，从输入图像到输出分割结果，有自己独立的结构和训练流程。&lt;/li>
&lt;li>LoRA 不是一种独立的网络架构，而是一种模型微调策略，可以应用于各种现有的预训练模型（包括但不限于基于 UNet 架构的模型），用于在不大量修改原始模型结构的情况下进行任务适配。&lt;/li>
&lt;/ul>
&lt;h3 id="从参数规模与训练成本来看">从参数规模与训练成本来看
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>UNet&lt;/strong>：在训练过程中，需要对整个网络的参数进行学习和更新，尤其是在处理高分辨率图像或复杂任务时，可能需要大量的训练数据和计算资源。&lt;/li>
&lt;li>&lt;strong>LoRA&lt;/strong>：通过低秩分解减少了需要训练的参数数量，在对大型预训练模型进行微调时，训练成本显著降低，对数据量的要求也相对较少。&lt;br>
UNet 的模型一般都比较大：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/11/8f1f152a35835044e0ea8fc381a9333b.webp"
width="475"
loading="lazy"
alt="|475"
>&lt;br>
LoRA 则小很多&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/11/36b48790266f80b2cb03cfc22ded0f13.webp"
width="475"
loading="lazy"
alt="|475"
>&lt;/li>
&lt;/ul>
&lt;h2 id="使用">使用
&lt;/h2>&lt;p>它们都有 2-Step, 4-Step, 8-Step，其中 1-step 只是实验性的、效果不好、质量不稳定，一般建议用折中的 4-step，如果资源充足可以选质量最好的 8-step。&lt;br>
ComfyUI 中的使用非常简单：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/11/fc799454d0483ec8b7fea253e7ce45e4.webp"
width="675"
loading="lazy"
alt="|675"
>&lt;br>
如果只是想玩玩，可以直接在 huggingface 上试试：&lt;a class="link" href="https://huggingface.co/spaces/ByteDance/SDXL-Lightning" target="_blank" rel="noopener"
>SDXL-Lightning spaces&lt;/a> ，效果还是不错的：&lt;br>
&lt;img src="https://cdn.jsongo.top/2024/11/22638b08323398c180c2d2ff0d1e59f8.webp"
width="700"
loading="lazy"
alt="|700"
>&lt;/p></description></item><item><title>成本思维</title><link>https://www.jsongo.top/articles/thoughts/cost-thinking/</link><pubDate>Sun, 03 Nov 2024 13:35:12 +0800</pubDate><guid>https://www.jsongo.top/articles/thoughts/cost-thinking/</guid><description>&lt;img src="https://cdn.jsongo.top/2024/11/053cc313b6d764b5ee7d6b645fdca2bc.jpg" alt="Featured image of post 成本思维" />&lt;h1 id="成本思维">成本思维
&lt;/h1>&lt;p>大多数看起来有所利益的事情，肯定有成本，而且有风险。风险本质上也是一种成本。&lt;br>
用成本 + 风险的思维来看问题，不要只想着好处。成本和风险往往是在巨大的利益面前，特别容易被忽视的东西。&lt;br>
塔勒布在《非对称风险》中表达了一个观点，他反复提到在真实的世界里，一定要风险共担，如果有人不愿意承担风险，却要享受好处，这样的人是有问题的。&lt;/p>
&lt;h2 id="企业最大的成本是老大的决策成本">企业最大的成本，是老大的决策成本
&lt;/h2>&lt;p>如果动不动就来个调整，发现不对，马上再折腾几回，这损耗的是非常大的。决策成功率越低，企业就会被越来越快消磨掉。我们说大公司病，其实有一层逻辑是：公司小的时候，10 个决策中，有一两个正确的决策可能就能把营收和规模做上来；但当公司越来越大的时候，10 个决策中如果有一两个决策做错了，那都是在损耗。所以大公司病往往不是因为决策人变笨了，而是企业到了那个阶段，决策的成本变高了。&lt;br>
看过一篇文章《&lt;a class="link" href="https://news.qq.com/rain/a/20241015A04JNI00" target="_blank" rel="noopener"
>只有10%的产品值得用AI再做一遍&lt;/a>》，标题就直接表明了作者的观点。文中提到了 AI 时代，各大厂争先恐后地攻城略地，但后来发现，做了很多产品功能都是徒劳，浪费了很多资源。比如：&lt;/p>
&lt;ul>
&lt;li>支小宝虽有创意但操作路径复杂且多数功能未发挥 AI 能力；&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>如果我用支小宝坐公交，我需要把 APP 打开，点开对话，再输入指令“我要坐公交”，等待 2-3s 加载出来，这个过程至少需要 5s 以上。&lt;br>
实际上，用手机的 NFC 直接刷码上车，不需要打开任何 App 就完成了这个操作。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>淘宝问问、京东京言等电商 AI 助手功能空泛、多轮对话理解能力差且 AI 划重点功能无实际价值；&lt;/li>
&lt;li>饿了么的 AI 评价总结功能上线又下线，因为既无价值还浪费费用；&lt;/li>
&lt;li>携程问道生成的内容干巴巴且缺乏实用性。&lt;br>
这些都表明很多产品为跟上 AI 潮流而做 AI，未解决用户痛点，在未成熟阶段盲目投入，造成大师的资源浪费。&lt;br>
当然也不能说探索就是浪费，只是想表达决策是需要成本的，而且经常是最大的企业成本。&lt;/li>
&lt;/ul>
&lt;h2 id="制度本身也要成本">制度本身也要成本
&lt;/h2>&lt;p>坏的制度增加企业&lt;strong>成本&lt;/strong>，而好的制度是降低企业&lt;strong>成本&lt;/strong>的。&lt;br>
制度虽然有时让人诟病，但它们能带来一些确定性。一个集体如果制度有问题，一方面在遇到事时，经常会有模棱两可的疑惑，直到有个人做了表率，其它人慢慢地也跟上了。到后来，大家苦于不合理制度的约束，他们可能会不断地试探，直到看到不好的信号或良心觉得不妥，从而确定了一个心里底线，形成了自己的“制度”。&lt;br>
刘润讲到一个案例：一家文化教育的企业，老板从来不管教学质量，这家公司里的老师能偷懒就偷懒，因为没有制度去管理他们，慢慢的好老师就都走了，留下的越来越烂，这是会传染的。&lt;br>
问题制度带来的成本，就是人才流失，导致最后没有优秀的人来高效的做事，成本急剧增加。&lt;/p>
&lt;blockquote>
&lt;p>题外话，刘润在书中提到，对公司的管理的三种手段：&lt;/p>
&lt;ul>
&lt;li>鼓励白，即激励一些对的事；&lt;/li>
&lt;li>压缩灰，即用文化作为共同的价值观，给大家一个底层的判断标准，从而遇到模棱两可的事时能有一个基础的良知判断；&lt;/li>
&lt;li>禁止黑，即什么事一定不能做，这是一个更强硬的制度，防止公司烂掉。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="团队的规模也有成本">团队的规模也有成本
&lt;/h2>&lt;p>我在之前的其它文章里提到了亚马逊的 &lt;code>Two Pizza team&lt;/code> 原则：&lt;/p>
&lt;blockquote>
&lt;p>把整个系统拆分成微服务或独立模块，不同的 team 各负责一个单位的事情。Two Pizza team 是指用两块 pizza 就能吃饱的团队规模，一个业务的团队超过了这个规模，信息传递的成本就很高，沟通协作就变得困难。&lt;/p>
&lt;/blockquote>
&lt;p>小团队沟通高效，目标也容易对齐。团队大了经常要各种对齐，很多时间花在开会上。很多会都是用来同步信息的，没有它们反而可以跑的更快。所以团队规模越来，沟通协作的成本越高，这些都是决策时要考虑的成本问题。&lt;/p>
&lt;h2 id="机会成本">机会成本
&lt;/h2>&lt;p>那些看似免费或便宜的东西、或能直接带来利益的事情，往往也是有机会&lt;strong>成本&lt;/strong>的。你可能要花挺多时间在上面，研究它到底对你有没有用，是忽悠人还是可能有少许好处可以捞。&lt;br>
总之不管什么样的情况，你总需要付出时间，要拿机会&lt;strong>成本&lt;/strong>来换，而且很多并不划算，你完全可以拿这些时间来做更有价值的事情。&lt;br>
忘了哪本书里提到：&lt;br>
你得到的越多，选择放弃的机会成本就越大，就越不敢往前走，就越需要勇气和智慧。&lt;br>
另外还有社交，也是要成本。放弃无效社交，它们会占用你原本可用于提升自己的时间。&lt;br>
总之，如果尝试用成本思维去思考下，你很可能会得出不一定的决策。&lt;/p>
&lt;h1 id="阅读">阅读
&lt;/h1>&lt;p>这周还在阅读子皮的《价值生长》。再分享一个有趣的观点：人一辈子抓住几次机会就够了，不用怕有什么好机会在眼前错过了。&lt;br>
永远把质量排在第一位，弱水三千，只取一瓢。在自己擅长的领域，找到绝对信任的人、靠谱的事，哪怕只搭上一趟火箭就够了。&lt;br>
买股票也一样，不要怕错过什么妖股、潜力股，那太多了。全都要的话，你的钱根本不够用，也不用天天去刷 K 线、抢先看新闻、生怕错过，找到一些真正有价值的，投入并在一段时间内看好它、坚定持有，长期看是会给你带来回报的。&lt;br>
不过不管怎么样，保住本金还是第一要务，不要乱投，耐心地蹲守、观察，找准时机再动手。&lt;/p>
&lt;blockquote>
&lt;p>投资的第一条原则 ，永远不要失去本金；第二条原则，牢牢记住第一条。—— 巴菲特&lt;/p>
&lt;/blockquote></description></item><item><title>打开心智 - 读书笔记</title><link>https://www.jsongo.top/articles/unlock-the-mind/</link><pubDate>Tue, 29 Oct 2024 00:08:41 +0800</pubDate><guid>https://www.jsongo.top/articles/unlock-the-mind/</guid><description>&lt;img src="https://cdn.jsongo.top/2024/11/82c4155b2681df9665519ffb08d4e346.jpeg" alt="Featured image of post 打开心智 - 读书笔记" />&lt;h1 id="一如何阅读">一、如何阅读
&lt;/h1>&lt;h2 id="避免做题式的阅读那到底要怎么读怎么用这个方法来改变我的阅读习惯">避免做题式的阅读，那到底要怎么读，怎么用这个方法来改变我的阅读习惯？
&lt;/h2>&lt;h3 id="避免备考式的阅读">避免备考式的阅读
&lt;/h3>&lt;p>之前看书，大都是从头看到尾，没意识地想去把整本书的结构都理清楚，最后还会把所有的重点都整理出来、形成一个比较大的笔记。&lt;br>
最近在阅读《打开心智》，里面提到的不太好的阅读习惯，貌似每条都在说我。想想确实很有道理，不过主要还是习惯、观念和心态的问题。观念是可以改变的，但就是比较顽固；习惯则可以通过培养和践行新习惯来覆盖；而心态可能就是一个需要比较漫长的磨练，才能去改变的。&lt;br>
书里主要提倡“以我为主，为我所用”的阅读习惯。书中内容的结构、甚至作者的看法都不重要，我自己的看法才重要，也就是它对我的思维造成了什么影响，给我带来了什么帮助。&lt;br>
书中提到一个“计数器陷阱”，讲的是太过追求数量，设置错了目标（即使也是按 smart 原则来制订的）。“为我所用”才是真正的上的。&lt;br>
不要去追求看完、看几本，这些数量并不是我的目的，但我之前常把它们当目的。&lt;br>
也不用追求把一本书里的知识全掌握，这不是在备考，可能我们都没太注意到，中学时留下的一些习惯一直跟着大多数人。除非看那种比较体系的教材去体系化的学习。大部分书，挑对自己有用、自己感兴趣的部分去阅读就好，或者每个阶段都有自己感兴趣的主题，可能后面还会翻到这本书。&lt;/p>
&lt;h3 id="主动式地学习经验--提炼--看书完善--强化方法论">主动式地学习：经验 -&amp;gt;提炼 -&amp;gt;看书完善 -&amp;gt;强化方法论
&lt;/h3>&lt;p>作者在书中给了一个模型：&lt;br>
![[assets/local_image_plus/7854b0e4882ba4957ecba9e5d142f1fd_MD5.jpg]]&lt;br>
从实践运用中去获取一些经验，提炼出思维模型或行为模型，然后通过阅读去完善这些模型，甚至去完全纠正。不过也没关系，有了实践，再去思考，肯定会比光思考深刻很多，理解的更透。&lt;br>
带着问题去阅读，是主动式学习的最好方式。开始看一本书的时候，先通过目录去思考有哪些内容跟我现阶段感兴趣的事情相关，我想通过阅读它来弄懂什么问题，就比如现在的这个过程，就是在回答一个问题。最终我要能得到一个答案，可能是一个观点，也可能是改变我习惯的方法，也可能是一种新的思维，也或者是打开了一个新领域的知识，让我产生了新的兴趣，开始系统地去学习，等等，这些都是收获。&lt;/p>
&lt;h3 id="作者的例子">作者的例子
&lt;/h3>&lt;p>他发现自己的知识不成体系，怎么整理好像都没用。于是通过实践思考总结出了需要让知识流动起来才有用，于是去学习了 GTD 的方法（通过阅读等），把里面的思想和理念跟自己的想法结合，总结出了一个知识管理模型。后面的阅读、思考过程中，都在完善他的这个模型，得出自己实用的方法。&lt;/p>
&lt;h3 id="想法">想法
&lt;/h3>&lt;ul>
&lt;li>或许可以把我收藏的书的目录，收集起来，然后喂给大模型，未来想看某些主题的时候就让大模型去帮我找出合适的章节。可以在 coze 上去实现这个功能。&lt;/li>
&lt;li>用 python 写，去抓微信读书上的内容&lt;/li>
&lt;li>展示的时候，让大模型做下格式化&lt;/li>
&lt;li>我把相关的书发给它，它给我返回列表，我选择相关的书籍查看目录结构，然后能导入我的知识库，直接做向量化，后面用于做检索&lt;/li>
&lt;li>检索也在 coze 上面实现，可能得想想怎么打通到知识库，动态补充&lt;/li>
&lt;/ul>
&lt;h2 id="如何通过边阅读边思考来记忆知识点而不是读过就忘了另外怎么把这些知识点形成体系结构">如何通过边阅读边思考来记忆知识点，而不是读过就忘了，另外怎么把这些知识点形成体系结构
&lt;/h2>&lt;h3 id="关于记忆">关于记忆
&lt;/h3>&lt;p>3 种阅读方式：照抄、看结构回忆，以及完全自由的回想。&lt;/p>
&lt;ul>
&lt;li>第一种，基本都没怎么经过思考，也是我之前做读书笔记的方式，一直想去梳理出书的结构、以及作者的写作思路。但这些真的重要吗，我去了解书的结构干嘛，要理完整个结构那就是要通读整本书。但真没太多必要，理完也没怎么思考，就是整理出了一个文档，平时需要的时候可以查看，把纸书电子化了，也自己结构化了一遍。&lt;/li>
&lt;li>第二种 ，看结构（脑图、目录等）去回忆，这里面也是有一点想把整个知识点都消化掉的思路。刻意去回忆，确实能加深记忆，不定时地去看，根据记忆遗忘曲线是可以记住更多的内容。不过想想，这不就是备考的思路吗，为啥要去背知识点呢？背不是目的。&lt;/li>
&lt;li>第三种，自由回想，一方面把一些记忆深刻的点 recall 出来，另一方面自由地随想，可能会创建一些意外的关联。还有一点更重要的是，想到一些点，就要去结合自身的行为、习惯、思维方式去思考，要有一些收获，或者改变，可能是行为习惯上的、也可能是思维方式上的，能有一些不一样的收获就好。&lt;/li>
&lt;/ul>
&lt;h3 id="知识结构">知识结构
&lt;/h3>&lt;p>读不同的知识点，可以逐步地完善自己的知识结构。这个词我的认知一直是构建一个脑图，把不同的知识点、结构分支等整理上去，形成一个树状或网状的结构。后者没法用脑图表示。&lt;br>
那有什么软件或工具能更好的描绘出我的知识结构呢？&lt;br>
理下目前知道的工具主要有：&lt;/p>
&lt;ul>
&lt;li>飞书画脑图工具、processon 的脑图，这两个可以画回路；&lt;/li>
&lt;li>标签体系，如 flomo，可惜它没有可视化，只能通过点标签目录去大概看出网状，而且是得用标签查询去找线索；&lt;br>
![[assets/local_image_plus/65355c728f54c7468e9b262411f74a72_MD5.jpg]]&lt;br>
←像这种标签树，看起来也是一种可视化，但它有两个问题，一是只是一个图，没法链接；另一方面是它没法通过两个标签来定位一个知识点，即没法网状地找东西。&lt;/li>
&lt;li>flowUs 的脑图，每个节点都是一个 block，这个很创新，可以建立很多链接，我觉得是一个不错的建立知识库的工具，不过可能要实践探索一下，目前还没有比较系统的思路。&lt;/li>
&lt;/ul>
&lt;h3 id="心态">心态
&lt;/h3>&lt;ul>
&lt;li>没必要去记住或用上书里提到的每一个知识点，这不是要去考试；&lt;/li>
&lt;li>书不要看完，培养自己能释怀的心态，不要老追求从头到尾读完每一本书，这中间会浪费很多时间，虽然这样经常会有一些额外的收获，但就像刘润讲的，从沙子里挑出较大的金子，其它较细的金沙没必要去慢慢抠，读书是淘金，而且密度很高，但粒度不同，书有很多，没必要每次都要把金子收集干净；&lt;/li>
&lt;/ul>
&lt;h3 id="正确的使用知识">正确的使用知识
&lt;/h3>&lt;ul>
&lt;li>获得核心的知识点，与自己结合，给自己带来收获或改变&lt;/li>
&lt;li>数据和细节等，记到一个笔记里就行，后面通过 AI 来对接，让 AI 帮你 retrieve，不用去记&lt;/li>
&lt;li>大知识点形成结构，笔记里画脑图记下来，链接起来，不求多，这主要是为了形成更深刻的知识结构，时不时看，在脑子里刻下来&lt;/li>
&lt;li>弄个工具去查找未接触的知识或内容，如书籍，向量化并通过 AI 来查找&lt;br>
之前看书，大都是从头看到尾，没意识地想去把整本书的结构都理清楚，最后还会把所有的重点都整理出来、形成一个比较大的笔记。&lt;br>
最近在阅读《打开心智》，里面提到的不太好的阅读习惯，貌似每条都在说我。想想确实很有道理，不过主要还是习惯、观念和心态的问题。观念是可以改变的，但就是比较顽固；习惯则可以通过培养和践行新习惯来覆盖；而心态可能就是一个需要比较漫长的磨练，才能去改变的。&lt;br>
书里主要提倡“以我为主，为我所用”的阅读习惯。书中内容的结构、甚至作者的看法都不重要，我自己的看法才重要，也就是它对我的思维造成了什么影响，给我带来了什么帮助。&lt;br>
书中提到一个“计数器陷阱”，讲的是太过追求数量，设置错了目标（即使也是按 smart 原则来制订的）。“为我所用”才是真正的上的。&lt;br>
不要去追求看完、看几本，这些数量并不是我的目的，但我之前常把它们当目的。&lt;br>
也不用追求把一本书里的知识全掌握，这不是在备考，可能我们都没太注意到，中学时留下的一些习惯一直跟着大多数人。除非看那种比较体系的教材去体系化的学习。大部分书，挑对自己有用、自己感兴趣的部分去阅读就好，或者每个阶段都有自己感兴趣的主题，可能后面还会翻到这本书。&lt;/li>
&lt;/ul>
&lt;h1 id="二构建知识体系">二、构建知识体系
&lt;/h1>&lt;h2 id="怎么构建自己的知识体系--inkp">怎么构建自己的知识体系 － INKP
&lt;/h2>&lt;p>作者提出了 INKP 理论，我再结合最近在使用的 flowUs 软件，做一些梳理和结合，给一些实践和方法。&lt;/p>
&lt;ul>
&lt;li>Inbox&lt;/li>
&lt;li>阅读时，有一些好的点子或想法，都可以快速放到 inbox 里，一条一条记
&lt;ul>
&lt;li>可以创建一个页面，也可以用 flomo 来写。这里涉及到一个观念：创建页面感觉比用 flomo 快速在输入框里写一条记录更重些。为什么会有这种感觉，我想主要还是因为页面里，整个区域都是输入区，给人比较大的压力，觉得要写很多才不会浪费；而 flomo 像聊天窗口一样，只有底部有一个输入框，看起来压力很小，就是记录一张小卡片。另外 notion 类软件也是要删除两次才能彻底删除，简单的删除，它的链接什么的都还在，还可以打开这个文档，而且“最近打开”的列表里还有它，总感觉它还在占着空间。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>平时突然有一些好想法，也可以写到这个 Inbox 里&lt;/li>
&lt;li>Note&lt;/li>
&lt;li>主要就是记录一些概念，最重要的是，得经常去整理 inbox 的内容，把相关的概念弄清楚，然后打上一些标签之类的&lt;/li>
&lt;li>所以是不是 inbox 和 note 都用 flomo 来记，然后整理好的、比较确定的概念都落到 notion 类的笔记软件里，这些概念后面可能会被引用&lt;/li>
&lt;li>Knowledge&lt;/li>
&lt;li>实际上就是一个主题，比如“克服拖延”、“情绪”、“专注力”，它也是一个独立的页面，所有跟这个主题相关的，如果比较小，可以直接写进去，如果内容比较多，则可以链接进去。&lt;/li>
&lt;li>这个 knowledge 页面，就是这个主题的根据地，所有跟它相关的都要可以在这里找到&lt;/li>
&lt;li>这页面也要抽时间去做些结构上的整理，比如可以弄个脑图，或者整理下目录结构。flowUs 的脑图是一个非常好的工具，它每个节点是一个 block，可以做一些链接，让知识形成树状，同时链接也能把各个地方的知识连到一起，形成网状。知识树、链接网。&lt;/li>
&lt;li>如果一个概念，是跟这个主题相关，但又不太好归类或嵌入到架构合适的地方，那可以在页面底部加一个相关知识点，把这些整理进去。这样至少能保证相关的内容，都可以在这里找到的。&lt;/li>
&lt;li>用主题的方式，而不是标签的方式来关联，好处是它会被整理成一个整体，标签拉出来的笔记列表，它没法调顺序和结构，只能是一堆知识堆积，所以卡片笔记也是有弱点的。缺点就是得花时间去整理。&lt;/li>
&lt;li>主题页面，需不需要整理的很正式、甚至可以拿去发表的呢？其实有两种情况，一种是主题本身就比较简单，整理出来的东西，如果时间充足，就可以优化下表达、整个就是一篇可发表的小论文；另一种情况是，这个主题很复杂，还要添加很多知识才能看起来是完整的，要不读起来感觉东缺一块、西漏一些，整篇内容就显得不严谨。后面这种情况，结构整理起来也会比较复杂，可能会经常调整，随时都可能有变化。
&lt;ul>
&lt;li>所以如果要发表的话，直接用笔记是最合适的，flowUs 是可以，不过有个小问题是，所有的改动马上就直接发出去了，缺少一个发布的动作；notion 也有这个问题，语雀和印象笔记可能好一些，但印象的性能/体验实在不太行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Project&lt;/li>
&lt;li>由多个主题汇总而成， 当然这些主题也需要有关联，而且要能形成一个更大的知识体系。&lt;/li>
&lt;li>比如原则 2（应对变化中的世界秩序），把政治秩序、经济周期结合起来，通过对周期规律的分析来预测当下的环境、以及未来的发展趋势。经济周期里，包含了货币、信贷和经济活动等，每个都是一个大主题；而政治秩序双分为了内部秩序（内部的政权迭代）、外部的政治环境等等，每个也是一个主题。这么多主题最终形成了一个大周期的理论，它们之间的关系不是平铺的，而是有点树状的结构&lt;/li>
&lt;/ul>
&lt;h2 id="实践-inkp">实践 INKP
&lt;/h2>&lt;h3 id="基本操作流程">基本操作流程
&lt;/h3>&lt;p>平时有什么不错的输入，或好的想法，先记录到 inbox 笔记中，比如我的“随手记”目录中。快速写下当时触动我的点，简单些，也可以只写关键字。重要的是后面能明白是什么，以及不要打断太久当前的阅读。重在快速和写对点。&lt;br>
接着，晚上的时候，在书桌前打开电脑后，就先一个个的过 inbox，扩写下，补充查询些资料，升级成理论或概念，抽象出核心观点短语作为标题，从 inbox 移出，放到具体的分类目录里。如果跟某个主题相关，那么可以整个进去，看是在主题结构的哪个位置，整理整理。但如果是一个新主题，可能就要新建一个主题页面。&lt;br>
如果是比较大、比较复杂的概念，则可以在标题上加个待处理的标识，等周末或工作日有空时统一处理。&lt;br>
建立关联很重要，一方面是上文提到的归入某个主题，另一方面也有可能只是跟某个概念有关，那就找到相关的那个概念笔记，链接进去，notion 类产品会在底部显示本文档被那些地方引用，所以其实可以在目标概念文档、或主题文档中，通过行内链接的形式把文档关联进去。&lt;br>
周末抽半小时到一小时整理这周的待处理，查资料、问 AI，或者找视频资料等，学习并整合进去。如果发现某个主题比较完善，可以把它发表出来，如写入 thinking 或整理成一个主题分享，用费曼学习法反推自己更深入、更及时地学习下这个主题，沉淀下来，分享出去。&lt;br>
作者还有一个方法，为了避免笔记太多、内容太重复、知识层级太深或叶子结点过多，他每整理完一个概念笔记，或某些主题笔记，不再直接用它时，就把笔记归档。我理解这个归档其实可以平铺放入一个 archived 目录下，里面的东西不是没用，而是不会再直接去打开它，只会通过知识框架链接进去找他。这个方法很重要，要不然知识架构，跟目录就完全脱节，得另外维护一个脑图等，同步是个问题，不过也可能是更好的办法，这个得通过实践去看看哪种更适合自己。&lt;br>
可以把某个主题的笔记的复习任务，安排到某周的待办事项里，挤时间去整理它。要认真去经营自己的知识结构，回顾或复习，也不能漫无目的、随机的复习，平时整理笔记的时候，总会想到哪个主题最近得再复习整理下。&lt;br>
最后，项目是解决一个问题，比如提高自己的工作效率，涉及几个主题，去专注力、咖啡的研究、某个技能 等。&lt;br>
一个项目，可以有一些基础的配置：计划、方案或思路等，都可以链接到这个主页里。&lt;br>
当我在进行一个项目时，其实可以把 inbox 分个专业的类别，在 inbox 目录里，以项目或主题来全名。这样收集到的信息都会收敛到里面，晚上在整理的时候也能在 inbox 里看到他们。&lt;/p>
&lt;h3 id="主题和项目有什么明显的区别怎么区分呢">主题和项目有什么明显的区别，怎么区分呢
&lt;/h3>&lt;p>综合下，上面其实陆陆续续提到了一些。&lt;/p>
&lt;ul>
&lt;li>主题一般是一个比较小的话题，可能就是一个点，里面可以有多个概念 (note)，它们聚合起来充分地解释了这个主题的各个方面。&lt;/li>
&lt;li>例子先说 note，即概念，如精神内耗，这是个什么概念，有什么危害，我有没这方面的问题，要怎么避免&lt;/li>
&lt;li>然后就是主题，上面这个概念，可能涉及到生活质量、拖延、情绪调控等主题，如生活质量这是一个我追求的主题，里面肯定会涉及到“精神内耗”相关的东西，所以在生活质量的主题下，就会把精神内耗链接进去（行内链接）。&lt;/li>
&lt;li>项目，则是一个动作或一个很大的主题。&lt;/li>
&lt;li>例子：品质生活，涉及精神层面的提升生活质量，也涉及改善生活条件（居住环境、财务情况等），这个项目就要多个方面去推进。&lt;/li>
&lt;li>我其实还有一个领域的概念，它是某个方面的东西聚焦，比如家族、生活、读书笔记等，它们不是主题、也不是项目，不太好归类到里面去。它们往往是一个较大的同一类型的内容集合，跟项目可能就是平行的关系，并不是包含关系。&lt;br>
作者给的另一个比较形象的例子：看到一篇讲“会员积分体系”的文章，开一个 note 记录下，然后里面没讲清楚的地方，还可以继续查更多的资料（最后加一个参考资料的部分）。然后整理的时候，想到会员积分体系，其实是一种“激励”，也是一种“游戏化”、“增长黑客”等主题里的知识点，于是链接进去。后来，作者想起一个项目，做一个“内容社区”，这时这相关的主题也都可以引用到，基于相关的主题可以做些什么方面的规划和设计。&lt;br>
另一个例子，比较简单，即睡眠 (K) 这个主题，下面包含了“晨型和夜型”、“睡眠周期”、“睡眠对记忆的作用”、“睡眠与情绪”、“为什么我们需要睡眠”等这些概念 (N)。&lt;br>
&lt;strong>主题构成了我们知识体系的主干&lt;/strong>，而&lt;strong>概念则是比较零散的知识点小枝叶&lt;/strong>，没有主干来组织，就是散落一地的枝条叶片。而&lt;strong>项目则是做一张桌子&lt;/strong>，它可以从这棵树上切一条枝干做桌腿，从另一个更粗的树干中切出一片桌面，最后组装成一张桌子（当然这个例子不一定恰当，因为并不是真的“切”，而是一种可以无限复制的副本，切掉还在的情况，因为内容不会消失。领域呢，则是一个平行的东西，它研究的是苹果树、柳树、白桦树等，跟前面讲的不是一个位面的，但也可以有相互的包含，比如白桦树干比较坚挺，更适合做出什么样的成品等。&lt;br>
另外，主题、项目 一般也需要用脑图来组织。主题好理解，其实就是把树画出来（脑图跟树很像），而项目，则主要是用脑图来做一些整理，结构可能（前几层级）大体相同。这些画出来的脑图其实就是比较图形化的知识结构，好记，都是我的知识结构，打开一看就知道大体有哪些东西。&lt;/li>
&lt;/ul>
&lt;h3 id="自上而下还是自下而上">自上而下、还是自下而上
&lt;/h3>&lt;p>平时的记录，肯定是散乱的，这时应该是先有内容，自下而上。但其实一直是这么被动的整理，一方面知识体系不一定完整，另一方面也漫无目的、不知道什么时候是个头。所以作者给的建议是，先积累一波概念（素材），然后找个周末的时间建立主题结构，可以通过 AI 辅助、也可以请教别人，把结构画出来之后，再针对性地去研究每一个还没有涉及到的概念知识点。&lt;br>
这是一种先建立框架，再填充框架的思路。把自下而上和自上而下结合起来。&lt;br>
这里说的“上”是指主题 (K)，“下”是指概念或知识点 (N)。&lt;/p>
&lt;h3 id="总结">总结
&lt;/h3>&lt;p>简单一句话概括：&lt;strong>主题是小话题，项目是一次研究或改变，领域是一个学科、或一个方面的专业知识&lt;/strong>。不一定要区分的很清楚，大概判断下就行。&lt;br>
其实要建设好自己的知识体系，最最核心的还是要经常去整理，上面讨论了那么多，主要还是在讲整理的方法，如果压根就没时间腾出来去做整理，上面讲再多也是白搭。&lt;/p>
&lt;h1 id="三创造">三、创造
&lt;/h1>&lt;h2 id="作者关于创造的观点和方法是什么样的">作者关于创造的观点和方法是什么样的
&lt;/h2>&lt;p>你创造的东西定义了别人眼中你是一个什么样的人，而不是你拥有的东西定义的，拥有的只能定义出你是富人还是穷人，有什么样的品味和爱好。&lt;br>
时间管理的目的，是减少要做的事情，而不是增加。把很多价值不怎么大的事情规划出去，留下能创造价值的事，然后找到效率高的时间去更好的实现它。&lt;br>
创造是一种快乐，甚至是一在充实人生的意义。打个简单的比方，你去一个地方旅游，自己拍拍照，朋友圈晒一晒，这是消费的快乐，一下子就过去了。但如果你做了一个攻略，整理得自己都很满意，发布出去，别人看了之后也能得到帮助，经常有人评论或点赞，那就是创造之乐，它会持续地带来惊喜。而且这是你的一个“标志”，别人通过这个标志产生对你的第一印象。&lt;/p>
&lt;h2 id="找到自己喜欢的事情是什么">找到自己喜欢的事情是什么
&lt;/h2>&lt;p>去体验不同的事情，去接触不同的人，认识不同行业、不同思维方式的人，从他们身上找到能给你带来较持久激情、让你兴奋的事。当看到它的那一刻，你可能就知道这就是你的“公理”。所谓的“公理”是借用的数学领域的概念，公理是你不需要去证明的，它就是你的终极意义，确定下来就不用再去怀疑，遇到的事情对你来说有没有意义，反而要用这个公理去验证。&lt;br>
很多人活在自己的空间里，很少走出去，接触的也不多，陷入循环里，越是没什么兴趣，就越想去娱乐自己，天天刷抖音、头条、玩游戏等，打发时间，这样接触和体验就越少、越局限于一些无意义的小领域。&lt;br>
如果还没找到你的“公理”，遇到很多事尽量不要拒绝，去尝试，不要退缩。而且很多机会也是这么来的，一直待在自己舒适圈里，碰到的机会肯定不会多。&lt;br>
另外，体验或接触新领域，也意味着要行动，而不是碰到就了解下，这不叫体验，顶多叫看到。&lt;/p>
&lt;h3 id="怎么找到自己的兴趣">怎么找到自己的兴趣
&lt;/h3>&lt;p>其实兴趣本质是一种快乐，你去尝试了、解决了一个个的小问题，然后解决了更大的问题，得到了回报，内部的满足感和外部的金钱等激励，然后兴趣就上来了。&lt;br>
因为体验而发现擅长，因为擅长而产生兴趣，因为获得的激励而增强了动力。&lt;br>
接着反复地做了之后，积累了更多的经验和能力，然后学起相关的知识也比别人快且稳固，觉得自己就是做这块事情的料，兴趣越长久。&lt;/p>
&lt;h3 id="方法论找公理的步骤">方法论：找“公理”的步骤
&lt;/h3>&lt;p>1、每天抽点时间出来，去回想哪些方面或许可以接触到更多的新鲜事，接触到可能感兴趣的事。&lt;br>
2、每周抽时间去体验&lt;br>
3、沉浸到里面，并及时回想、复盘这些事，找更多资料去了解更多，然后再体验、尝试&lt;br>
4、找到其中最有可能是你人生意义的事，扩大范围去增加自己的影响力，用更多的时间和精力去尝试，看是否有可能性。&lt;/p>
&lt;h2 id="作者认为的更高层级的快乐是怎么样">作者认为的更高层级的快乐是怎么样
&lt;/h2>&lt;p>快乐分两类，一种是消费的快乐，另一种是创造的快乐。消费比如你拍照总是讲究用什么高端镜头，结果可能后面就陷入堆装备、跟圈子里的人攀比的快乐去了，买一个高端镜头就快乐一下，明天起来可能就消退了。但如果你花心思去钻研怎么用手机拍出更精致的照片，那注意力就聚焦在技巧上，大部分精力都在思考如果创造出更好的东西，拍出来的照片还能分享到更多的范围被人赞赏等，这种快乐就不一样。&lt;br>
读书其实也是，有些人停留在消费的快乐，听说某本书很流行，立马买了一本，放到书架里，而且整个书架很大、里面放了很多非常受欢迎的书，书架拍下来看都很漂亮，他也会经常站在书架前欣赏这些书。这是把它们当艺术品玩了。另一种快乐，不求多，也不追求读过的数量，而是从一些非常高价值的书里学到很有价值的知识或认知，去改变自己的生活，提升生活品质和职业技能，然后把相关的思想也沉淀下来，分享给别人、影响更多的人，让更多人受益。这于人于己都有重大意义，是你从已有的价值（书）里创造出来的新价值。&lt;/p>
&lt;h3 id="避开消费主义陷阱">避开消费主义陷阱
&lt;/h3>&lt;p>很简单，就问一个问题：&lt;br>
如果全世界除了我之外，没有人知道我拥有它，我还会想要它吗？如果答案是否定的，或者你犹豫了，那你很可能就落入陷阱了。&lt;/p>
&lt;h3 id="创造者视角">创造者视角
&lt;/h3>&lt;p>玩一个游戏，不要沉迷到里面，而是站在创造者的角度思考他设计的这游戏规则，他想要我们怎么通关，我们自己能从中锻炼什么技能（手指灵活度？快速反应能力？）。&lt;br>
进一步地，学了编程，玩游戏的时候，就会想创造者是怎么实现这个效果的。&lt;br>
更进一步，学了心理学，玩的时候则想这游戏背后 作者想怎么吸引大家来玩，有什么心理学上的设计等。&lt;br>
这些都是创造者视角，培养这种视角，会让自己习惯性地抽离出来，去看到全局而不是陷入别人的设计里。做同一个事，关注的角度不一样，会有不同的乐趣和收获。&lt;br>
创造者视角，其实是一种让我们脱离低级的消费快乐的方法，对自己来说是一种创造，如果把相关的思考也沉淀下来，分享出去，对别人来说，也是一种创造。&lt;/p>
&lt;h1 id="四时间精力管理">四、时间&amp;amp;精力管理
&lt;/h1>&lt;h2 id="作者是怎么安排好每天工作的">作者是怎么安排好每天工作的？
&lt;/h2>&lt;h3 id="化零为整">化零为整
&lt;/h3>&lt;p>化零为整，一切安排都要先去想办法挤出整段的时间用于创造。创造是困难的，肯定是需要大段时间去思考和整理，零散的时间见缝插针地做出来的东西，大概率是草率的。腾出整块的时间，然后专注去创造（工作），集中攻克。&lt;br>
作者专注的方法：&lt;/p>
&lt;ul>
&lt;li>把任务拆解，然后每个小任务安排一个倒计时做完&lt;/li>
&lt;li>不强求自己一定要专注，任其自然，走神了再拉回来，从发现到拉回的时间，越来越短之后，专注的时间就越来越长&lt;/li>
&lt;li>任务切换，一段时间后从一个事中抽离出来，安排另一个事，保持思考&lt;/li>
&lt;/ul>
&lt;h3 id="避免时间黑洞">避免时间黑洞
&lt;/h3>&lt;p>把琐事合并起来，集中到一个时间段去做完。&lt;br>
主动休息，如工作半小时就听一会儿音乐，看会儿小说等，不过要给这个放松提前设置个时间，如 15min，时间一到就立马停止。&lt;br>
弄一些小“仪式”再开始，比如开始前先深呼吸然后数到 10。&lt;/p>
&lt;h3 id="做符合长远目标的事">做符合长远目标的事
&lt;/h3>&lt;p>每个周期之后，安排一次复盘，很简单，只要把这段时间做的事都列出来，然后一个个打分，看下离自己的长远目标有多远，越符合分越高。如果发现自己花了很多时间在偏离的方向上，那后续对这个事就要更加警惕。其实我们很多时候都在惯性地做事，当时并不会去思考那个事是否真有意义，只是习惯性地就做了。如果经常复盘，发现了这些问题，后面对它们就会更加警惕。&lt;/p>
&lt;h2 id="作者怎么让自己每天效率爆表">作者怎么让自己每天效率爆表
&lt;/h2>&lt;h3 id="大脑的关联效应">大脑的关联效应
&lt;/h3>&lt;p>大脑喜欢不自觉地建立联系，所以你在不同的场景里会有不同的想法。比如你一坐到沙发上就想看电视，一坐到书桌前可能就想打电脑。因此也可以创造一些场景，比如阳台上的一把小沙发椅，坐上去就想看书。&lt;br>
还有一个点，就是工作桌子不用经常整理，乔布斯的就挺乱的，乱不是问题，每个东西各摆一个地方，甚至堆叠起来，这其实就是一种大脑能记忆的工作场景，你收拾了可能反而会打破场景。&lt;br>
不只是地点，习惯的触发也是一种大脑能自动建立的联系，比如你遇到复杂的事情就会习惯地打开脑图来整理思路，那每次有问题，就打开了脑图，思路自然地就涌出来了，这是大脑的一种场景关联。&lt;br>
所以&lt;strong>状态是可以创造出来的，而不是等出来的&lt;/strong>，虽然是会有一定的影响，但进入状态更多的取决于大脑的关联。&lt;/p>
&lt;h3 id="少量多次冲刺">少量多次冲刺
&lt;/h3>&lt;p>不用追求要专注多长时间，可以把更多地训练自己的快速进入专注状态的能力。&lt;br>
休息的时候，换换脑子，可以整理整理资料，回复下消息，通讯软件可以根据专注的时段来关闭和打开，减少对专注的干扰。&lt;br>
不过有个问题，一旦休息时，大脑的上下文就清空了，所以得让自己能暂存现场，办法就是记录当时做到哪，思路是怎么样的，下一步要干嘛等。等回头来继续工作的时候，很快就可以找到状态，再加上场景的关联，多训练训练，快速进入专注的能力就越来越强了。这实际上可以节省大把的时间，因为分段冲刺后，就多出了很多上下文切换的成本。&lt;/p>
&lt;h2 id="作者是怎么休息来保持精力的">作者是怎么休息来保持精力的
&lt;/h2>&lt;p>首选肯定是睡眠，作者建议每天睡 7.5h，5 个睡眠周期。&lt;br>
其它是一些方法或观念：&lt;br>
1、动脑休息&lt;br>
不要觉得工作这么累了，去刷刷手机放松，其实这只会让自己兴奋，提高了大脑的阈值和期望，不刷了之后会感到无聊，反而影响精力。&lt;br>
我们应该选择继续思考，意志力这东西，你认为是无限的，就可以是无限的，主要还是得通过主动选择去做一些有意义的事，取得成就，让大家保持一定兴奋度和自信。&lt;br>
2、交替工作&lt;br>
掌握好节奏，大概 1 小时休息个 10~15min。番茄工作法有一定的道理，不过不用这么死板，给自己设定个最长时间段，如果超过了就去做点其它事。比如可以拿出问题清单，去思考一些问题有什么解法，这类事情主要是让思维发散，不会像专注时那么耗精力，同时想出一些点子、把事情往前推进几步，也是一种成就，让大脑充满干劲，继续回到原来的工作中、精力充沛的战斗。当然中间去思考问题的那段时间也不能太短，要不然没弄出点什么就切走，大脑反而会一直思考原来的事，甚至会受到打击。&lt;br>
3、放松空间&lt;br>
放松空间，并不是就放空时间、随便度过。&lt;br>
每天早上 1 小时的读书时间，就是我的放松空间。这段时间可以不用管其它事，沉浸到书籍里，去学习、感悟、思考，其它烦恼也不会干扰到我（当然偶尔会因为一些事变得不专心）。&lt;br>
其实晚上也可以借助这个思路，给自己设定一个放松空间，一回家就赶紧把其它必做的事弄完（洗澡、哄娃、其它家务等），然后一闲下来就开始进入这个放松空间。半小时左右的整理、复盘、回顾思考等。&lt;br>
如果还有时间，那再来半小时学习。白天的精力一直波动在较好的水平，到晚上其实并不是就直接下来了，用好这个时间，主动去学习，创造出自己的放松空间。&lt;br>
这是个很虚的概念，说了好像等于没说，但其实是在脑子里创造了一个概念，默默地告诉自己，这个时间段就是固定用来做什么的，习惯了之后，未来就变成了一种“关联”，进入场景后就自然关联起那时该有的状态。比如早上我坐到咖啡厅，一个人，掏出书，大脑自动就关联起来，调出了看书的状态。&lt;br>
4、设定界限&lt;br>
得知道自己这周有哪些非常重要的事，必须要完成，得用多少时间，这些时间是被“锁住”的，然后这周还剩多少时间，心里得有这个大概的度量。&lt;br>
之后有个什么事过来，如果剩下的时间不太够了，那就可能要想办法拒绝、或转手，有这个界限就会让自己有个衡量的标准，而不会一直是迷茫的状态，不清楚做了这个事还有没有时间做其它事。这些事先就要先估好。&lt;br>
事情永远做不完，也不盘的很细，每天要什么事，做完才能回家。算到这么精细反而挺浪费时间和精力，还不如直接就用事先估好的这个“度”去评估每天是否该下班，是否有些事做不完了、得事先去沟通或安排。&lt;/p></description></item></channel></rss>